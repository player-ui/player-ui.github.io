(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9151],{30876:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(2784);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=d(n),u=s,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function u(e,t){var n=arguments,s=t&&t.mdxType;if("string"===typeof e||s){var i=n.length,r=new Array(i);r[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"===typeof e?e:s,r[1]=o;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8938:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/assets/custom",function(){return n(82726)}])},43857:function(e,t,n){"use strict";n.d(t,{Z:function(){return O}});var a=n(52322),s=n(2784),i=n(97729),r=n(64033),o=n(30876),l=n(21925),d=n(76808),p=n(55165),c=n(63637),h=n.n(c);function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function m(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}var g=["id"],f=["id"],k="chakra-skip-nav",y={userSelect:"none",border:"0",height:"1px",width:"1px",margin:"-1px",padding:"0",outline:"0",overflow:"hidden",position:"absolute",clip:"rect(0 0 0 0)",_focus:{clip:"auto",width:"auto",height:"auto"}},b=(0,d.Gp)((function(e,t){var n=(0,d.mq)("SkipLink",e),a=(0,d.Lr)(e),i=a.id,r=void 0===i?k:i,o=m(a,g),l=h()({},y,n);return s.createElement(d.m$.a,u({},o,{ref:t,href:"#"+r,__css:l}))}));p.Ts&&(b.displayName="SkipNavLink");var w=(0,d.Gp)((function(e,t){var n=e.id,a=void 0===n?k:n,i=m(e,f);return s.createElement(d.m$.div,u({ref:t,id:a,tabIndex:-1,style:{outline:0}},i))}));p.Ts&&(w.displayName="SkipNavContent");var v=n(46977),N=n(96882),x=function(e){var t;return(0,a.jsxs)(r.xu,{display:{base:"none",xl:"block"},children:["Table Of Contents",(0,a.jsx)(r.GS,{spacing:1,ml:"0",mt:"4",styleType:"none",children:null===(t=e.tableOfContents)||void 0===t?void 0:t.map((function(e){return(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#".concat(e.id),children:e.text})},e.text)}))})]})},j=function(e){var t=s.useContext(v.Il).bannerExpanded,n="72px",i="calc(100vh - 88px - ".concat(t?n:"0px",")"),o="calc(100vh - 88px - 105px - ".concat(t?n:"0px",")");return(0,a.jsxs)(r.xu,{minH:"100vh",children:[(0,a.jsx)(b,{children:"Skip to Main Content"}),(0,a.jsxs)(r.kC,{flexDir:"column",padding:"2",children:[(0,a.jsx)(N._g,{}),(0,a.jsx)(r.iz,{}),(0,a.jsx)(r.kC,{children:(0,a.jsx)(r.xu,{as:"main",w:"100%",mx:"auto",children:(0,a.jsxs)(r.xu,{display:{md:"flex"},children:[(0,a.jsx)(r.xu,{display:{base:"none",md:"block"},overflow:"auto",maxH:i,pr:"8",ml:"4",children:(0,a.jsx)(N.Hy,{})}),(0,a.jsxs)(r.xu,{flex:"1",minW:"0",overflow:"auto",maxH:i,children:[(0,a.jsxs)(r.xu,{minH:o,children:[(0,a.jsx)(w,{}),e.children]}),(0,a.jsx)(r.xu,{pt:"20",children:(0,a.jsx)(N.$_,{})})]}),e.tableOfContents&&(0,a.jsx)(x,{tableOfContents:e.tableOfContents})]})})})]})]})};function O(e){return function(t){return(0,a.jsxs)(j,{children:[(0,a.jsx)(i.default,{children:(0,a.jsxs)("title",{children:["Player - ",e.title]})}),(0,a.jsx)(r.kC,{alignItems:"center",children:(0,a.jsx)(r.W2,{maxW:"container.lg",children:(0,a.jsx)(o.Zo,{components:l.tl,children:t.children})})})]})}}},82726:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return l}});n(2784);var a=n(30876),s=n(43857);function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var r={},o=(0,s.Z)({title:"Custom Assets",tableOfContents:[{text:"Custom Assets",id:"custom-assets",level:1},{text:"React",id:"react",level:2},{text:"Create Your Asset",id:"create-your-asset",level:3},{text:"Register it Using a Plugin",id:"register-it-using-a-plugin",level:3},{text:"Rendering Nested Assets",id:"rendering-nested-assets",level:3},{text:"iOS",id:"ios",level:2},{text:"Data",id:"data",level:3},{text:"ModelReference",id:"modelreference",level:4},{text:"WrappedFunction",id:"wrappedfunction",level:4},{text:"WrappedAsset",id:"wrappedasset",level:4},{text:"View",id:"view",level:3},{text:"Asset",id:"asset",level:3},{text:"UncontrolledAsset",id:"uncontrolledasset",level:4},{text:"ControlledAsset",id:"controlledasset",level:4},{text:"Linking the View",id:"linking-the-view",level:4},{text:"Additional Topics",id:"additional-topics",level:3},{text:"Interacting with the Data Model without a transform",id:"interacting-with-the-data-model-without-a-transform",level:4},{text:"Registering your Asset",id:"registering-your-asset",level:4},{text:"Why Would I Register my Asset as a Variant?",id:"why-would-i-register-my-asset-as-a-variant",level:5},{text:"Android",id:"android",level:2},{text:"Extending DecodableAsset",id:"extending-decodableasset",level:3},{text:"Implementing initView",id:"implementing-initview",level:4},{text:"Implementing hydrate",id:"implementing-hydrate",level:4},{text:"Accessing Data",id:"accessing-data",level:4},{text:"Nested assets",id:"nested-assets",level:4},{text:"Styling",id:"styling",level:4},{text:"Registering assets",id:"registering-assets",level:3},{text:"Partial match asset registration overrides",id:"partial-match-asset-registration-overrides",level:4}]});function l(e){var t=e.components,n=i(e,["components"]);return(0,a.kt)(o,Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",Object.assign({},{id:"custom-assets"}),(0,a.kt)("a",Object.assign({parentName:"h1"},{href:"#custom-assets"}),"Custom Assets")),(0,a.kt)("p",null,"One of the conscious design decisions we made when building Player was to abstract away the actual asset implementation and open it up for users to bring their own when using Player. This way you can seamlessly integrate Player into your existing experiences and reuse UI assets you may have already built. Below we\u2019ve outlined the way to build custom assets on the various platforms Player supports. "),(0,a.kt)("h2",Object.assign({},{id:"react"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#react"}),"React")),(0,a.kt)("h3",Object.assign({},{id:"create-your-asset"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#create-your-asset"}),"Create Your Asset")),(0,a.kt)("p",null,"First and foremost you need to create a component to handle rendering of your asset. Without any form of transforms, the props to the component will be those from the incoming player content. It\u2019s recommended that you attach the ",(0,a.kt)("inlineCode",{parentName:"p"},"id"),", and any other html properties to the root of the asset\u2019s tree:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"const CustomAssetComp = (props) => {\n  return (\n    <div id={props.id} style={{ color: 'purple' }}>\n      {props.text}\n    </div>\n  );\n};\n")),(0,a.kt)("p",null,"Assuming your authored JSON has a string property named text, this will render that."),(0,a.kt)("h3",Object.assign({},{id:"register-it-using-a-plugin"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#register-it-using-a-plugin"}),"Register it Using a Plugin")),(0,a.kt)("p",null,"Now that we have a React component to render our asset, let\u2019s create a plugin to register with Player:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"class CustomAssetPlugin implements WebPlayerPlugin{\n  applyWeb(webplayer) {\n    new WebAssetProvider([['custom', CustomAssetComp]]).applyWeb(webplayer);\n  }\n}\n")),(0,a.kt)("p",null,"Typically you register assets by type, but the registry acts by finding the most specific partial object match. This allows you to register more specific implementations for assets of the same type."),(0,a.kt)("h3",Object.assign({},{id:"rendering-nested-assets"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#rendering-nested-assets"}),"Rendering Nested Assets")),(0,a.kt)("p",null,"Often times, assets contain a reference or slot to another asset. For this to function properly, the custom asset needs to defer to the React Player to render the sub-asset. Say for instance we change our custom asset to now support a ",(0,a.kt)("inlineCode",{parentName:"p"},"header")," property that takes another asset."),(0,a.kt)("p",null,"Use the Asset from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-ui/react-asset")," package with the nested asset as props to dynamically determine the rendering implementation to use:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"import { Asset } from '@player-ui/react-asset';\n\nconst CustomAssetComp = (props) => {\n  return (\n    <div id={props.id} style={{ color: 'purple' }}>\n      {props.header && <Asset {...props.header} />}\n      {props.text}\n    </div>\n  );\n};\n")),(0,a.kt)("p",null,"This would automatically find the appropriate handler for the ",(0,a.kt)("inlineCode",{parentName:"p"},"props.header")," asset and use that to render."),(0,a.kt)("h2",Object.assign({},{id:"ios"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#ios"}),"iOS")),(0,a.kt)("p",null,"SwiftUI Player assets are made of 3 parts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"/#Data"}),"Data"),": Decodable AssetData"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"/#View"}),"View"),": A SwiftUI View"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"/#Asset"}),"Asset"),": SwiftUIAsset implementation to tie the two together")),(0,a.kt)("h3",Object.assign({},{id:"data"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#data"}),"Data")),(0,a.kt)("p",null,"SwiftUI Player relies on assets decoding data that conforms to ",(0,a.kt)("inlineCode",{parentName:"p"},"AssetData"),", this is necessary, because ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," are needed to determine what registered Swift type to decode to. You can include any decodable types in this struct as needed to match the structure of the asset that is returned from the core player."),(0,a.kt)("p",null,"Beyond this, there are a few wrapper types that handle some player specific features:"),(0,a.kt)("h4",Object.assign({},{id:"modelreference"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#modelreference"}),"ModelReference")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ModelReference")," is a wrapper that gets the raw JSValue from Player for a specific node in your asset data. This wrapper exists because if a reference to the data model is used in content, such as:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n  "asset": {\n    "id": "someId",\n    "type": "text",\n    "value": "{{count}}"\n  }\n}\n')),(0,a.kt)("p",null,"While ",(0,a.kt)("inlineCode",{parentName:"p"},"count")," will not necessarily be a string, in the underlying JavaScript layer, if the entire string value is just a reference to the data model, it is replaced with the exact value from the data model. This means that if ",(0,a.kt)("inlineCode",{parentName:"p"},"count")," is a number in the data model, when you receive it in the swift layer it will be an ",(0,a.kt)("inlineCode",{parentName:"p"},"Int"),". So ",(0,a.kt)("inlineCode",{parentName:"p"},"ModelReference")," gives you a quick helper to get it as a string:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),"struct TextData: AssetData {\n  var id: String\n  var type: String\n  var value: ModelReference\n}\n...\ntextData.value.stringValue\n")),(0,a.kt)("p",null,"You can also access ",(0,a.kt)("inlineCode",{parentName:"p"},"someModelReference.rawValue")," if you need to access the underlying JSValue for some other casting."),(0,a.kt)("h4",Object.assign({},{id:"wrappedfunction"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#wrappedfunction"}),"WrappedFunction")),(0,a.kt)("p",null,"JavaScript plugins loaded into the core player, when you have a plugin that extends JSBasePlugin, can transform the resolved asset before it reaches the Swift layer. In many situations, this results in functions being added to an asset to ensure that the same functionality is used on all platforms, and reduce code duplication. ",(0,a.kt)("inlineCode",{parentName:"p"},"WrappedFunction")," gives you a light wrapper to help decode and call those functions. It takes generic parameter that defines the return type of the function:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),'struct ActionData: AssetData {\n  var id: String\n  var type: String\n  var run: WrappedFunction<Void>\n}\n\n// You can pass any number of arguments to the function\n// so it\'s important to know what the transform added function\n// expects\n\ndata.run()\ndata.run("arg1", 2)\n')),(0,a.kt)("h4",Object.assign({},{id:"wrappedasset"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#wrappedasset"}),"WrappedAsset")),(0,a.kt)("p",null,"Last but not least, ",(0,a.kt)("inlineCode",{parentName:"p"},"WrappedAsset")," represents another asset being defined as a part of this asset. This will be a very common pattern as Player content is intended to be semantic and dynamic. Therefore we need to know that there is an asset in our data, but not what it is, as the implementation is not guaranteed."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),"struct ActionData: AssetData {\n  var id: String\n  var type: String\n  var label: WrappedAsset\n  var run: WrappedFunction<Void>\n}\n")),(0,a.kt)("p",null,"Rendering these nested assets will be described below."),(0,a.kt)("h3",Object.assign({},{id:"view"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#view"}),"View")),(0,a.kt)("p",null,"The view for a SwiftUI Asset is a regular SwiftUI ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),". Any standard SwiftUI components and concepts will work as normal. The only differentiating factor when it comes to Player assets, is the ",(0,a.kt)("inlineCode",{parentName:"p"},"WrappedAsset")," and rendering it. ",(0,a.kt)("inlineCode",{parentName:"p"},"WrappedAsset")," contains a ",(0,a.kt)("inlineCode",{parentName:"p"},"SwiftUIAsset?"),", so in the event it was not decodable, it will be ",(0,a.kt)("inlineCode",{parentName:"p"},"nil"),", otherwise, you can access it\u2019s ",(0,a.kt)("inlineCode",{parentName:"p"},"view")," property to get a type-erased ",(0,a.kt)("inlineCode",{parentName:"p"},"AnyView")," and render it in your view:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),"struct ActionView: View {\n  var body: some View {\n    Button(action: {}, label: {\n      if let label = decodedAssetData.label.asset {\n        label.view\n      }\n    })\n  }\n}\n")),(0,a.kt)("h3",Object.assign({},{id:"asset"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#asset"}),"Asset")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"SwiftUIAsset")," is the glue between the ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"Data"),". Player will handle decoding data, and updating the data in an ",(0,a.kt)("inlineCode",{parentName:"p"},"ObservableObject")," viewModel that contains the ",(0,a.kt)("inlineCode",{parentName:"p"},"Data")," you tell it to decode."),(0,a.kt)("h4",Object.assign({},{id:"uncontrolledasset"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#uncontrolledasset"}),"UncontrolledAsset")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"UncontrolledAsset")," is uncontrolled because you do not specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"viewModel")," type, and receive an implicit ",(0,a.kt)("inlineCode",{parentName:"p"},"AssetViewModel<T: AssetData>"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),"class ActionAsset: UncontrolledAsset<ActionData> {\n    // Populated for you, but copied here for reference\n    @ObservedObject var model: AssetViewModel<ActionData>\n}\n")),(0,a.kt)("h4",Object.assign({},{id:"controlledasset"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#controlledasset"}),"ControlledAsset")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ControlledAsset")," lets you define the viewModel type, as long as it subclasses ",(0,a.kt)("inlineCode",{parentName:"p"},"AssetViewModel<T: AssetData>"),", this way you still receive updated data whenever Player changes state, but you can add other functionality to the ",(0,a.kt)("inlineCode",{parentName:"p"},"viewModel"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),"class ActionViewModel: AssetViewModel<ActionData> {\n    public required init(_ data: ActionData) {\n      super.init(data)\n    }\n}\nclass ActionAsset: ControlledAsset<ActionData, ActionViewModel> {\n    // Populated for you, but copied here for reference\n    @ObservedObject var model: ActionViewModel\n}\n")),(0,a.kt)("h4",Object.assign({},{id:"linking-the-view"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#linking-the-view"}),"Linking the View")),(0,a.kt)("p",null,"In either situation, your asset implementation needs only to override the view property and return the type erased view you want to use."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),"class ActionAsset: UncontrolledAsset<ActionData> {\n        public override var view: AnyView { ActionView(model: model) }\n}\n")),(0,a.kt)("h3",Object.assign({},{id:"additional-topics"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#additional-topics"}),"Additional Topics")),(0,a.kt)("h4",Object.assign({},{id:"interacting-with-the-data-model-without-a-transform"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#interacting-with-the-data-model-without-a-transform"}),"Interacting with the Data Model without a transform")),(0,a.kt)("p",null,"If data needs to be set or retrieved without the use of a transform, the ",(0,a.kt)("inlineCode",{parentName:"p"},"InProgressState")," is available in an environment object, where the ",(0,a.kt)("inlineCode",{parentName:"p"},"DataController")," can be accessed, as well as other utilities:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),'struct SomeView: View {\n  @Environment(\\.inProgressState) var state: InProgressState?\n  var body: some View {\n    Button(action: {\n      state?.controllers?.data.set(["count": 5])\n    }, label: {...})\n  }\n}\n')),(0,a.kt)("p",null,"If your experience will be used on multiple platforms, it is not advised to use this method, a transform will ensure the same logic is followed on all 3 platforms and is strongly encouraged."),(0,a.kt)("h4",Object.assign({},{id:"registering-your-asset"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#registering-your-asset"}),"Registering your Asset")),(0,a.kt)("p",null,"When registering your asset with an ",(0,a.kt)("inlineCode",{parentName:"p"},"AssetRegistry"),", it can either be registered as a new type, if it is an entirely new construct, or registered as a variant of an existing asset type, to only be rendered under certain conditions."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),'// Convenience function for just registering for type\nplayer.assetRegistry.register("example", asset: ExampleAsset.self)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-swift"}),'player.assetRegistry.register(["type": "example", "metaData": ["role": "someRole"]], for: ExampleAsset.self)\n')),(0,a.kt)("p",null,"In the latter case, it is recommended to extend the original asset, so as to avoid boilerplate for data and construction, and just override the render function. If your variant will have additional data decoded that the original asset does not have, you will need to create the whole asset."),(0,a.kt)("h5",Object.assign({},{id:"why-would-i-register-my-asset-as-a-variant"}),(0,a.kt)("a",Object.assign({parentName:"h5"},{href:"#why-would-i-register-my-asset-as-a-variant"}),"Why Would I Register my Asset as a Variant?")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Transform backed assets have functions that are attached to them, through shared JavaScript plugins. This simplifies setting data from the asset, by giving simple functions like ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," in the reference ",(0,a.kt)("inlineCode",{parentName:"p"},"ActionAsset")," for example. Swift only asset types will not have any convenience functions.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Registering as a variant allows you to maintain usage of the transform backed asset as well as your new asset, so both can be used by the same ",(0,a.kt)("inlineCode",{parentName:"p"},"SwiftUIPlayer")," instance, including in the same flow. This also maintains the semantics of Player content, an ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," asset is always an ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," type of interaction, but with ",(0,a.kt)("inlineCode",{parentName:"p"},"metaData"),", it can be displayed differently."))),(0,a.kt)("h2",Object.assign({},{id:"android"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#android"}),"Android")),(0,a.kt)("p",null,"In order to render an asset a renderer for that type must be registered in the Android Player. If a renderer is found, then Player will delegate rendering when that type is encountered, otherwise Player will skip that node. Creating and registering such a renderer requires the following:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"#extending-decodableasset"}),"Extending DecodableAsset"),(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"#implementing-initview"}),"Implementing ",(0,a.kt)("inlineCode",{parentName:"a"},"initView")," and ",(0,a.kt)("inlineCode",{parentName:"a"},"hydrate"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"#accessing-data"}),"Define data structure")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"#nested-assets"}),"Nested assets")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"#styling"}),"Styling")))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",Object.assign({parentName:"li"},{href:"#registering-assets"}),"Registering assets"))),(0,a.kt)("h3",Object.assign({},{id:"extending-decodableasset"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#extending-decodableasset"}),"Extending DecodableAsset")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"DecodableAsset")," is a subclass of ",(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset")," that contains data decoding capabilities built on ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://github.com/Kotlin/kotlinx.serialization"}),"Kotlinx Serialization"),". This is the recommended approach for creating an asset and will be consolidated with ",(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset")," in future versions of the Android Player. On top of the requirements for subclassing ",(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset"),", subclassing ",(0,a.kt)("inlineCode",{parentName:"p"},"DecodableAsset")," requires passing a ",(0,a.kt)("inlineCode",{parentName:"p"},"KSerializer<Data>")," for the data class that represents the data for that asset."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset")," is the base structure used by Player to convert parsed content into Android Views. Each implementation is instantiated with an ",(0,a.kt)("inlineCode",{parentName:"p"},"AssetContext")," and is required to implement two methods, ",(0,a.kt)("inlineCode",{parentName:"p"},"initView")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"hydrate"),". The separation of logic between these two methods allow for views to be cached and optimize the render process. However, both of these methods are only used internally via the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," method. ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," is the main entry point for getting the Android view representation of that asset. It automatically handles the caching and hydration optimizations, only rebuilding and rehydrating when a dependency has changed. The caller would be responsible for handling that view (i.e. injecting it into a ViewGroup)."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset")," instance is ",(0,a.kt)("em",{parentName:"p"},"not")," guaranteed, meaning that state maintained within a ",(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset")," may not persist between ",(0,a.kt)("inlineCode",{parentName:"p"},"initView")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"hydrate")," calls. If state is required, that can be accomplished by creating a custom ",(0,a.kt)("inlineCode",{parentName:"p"},"View"),"."),(0,a.kt)("p",null,"Some asset implementations may encounter a situation where the cached view is no longer the corresponding representation of the asset. Under this circumstance, the asset can request a full re-render by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"invalidateView")," from any point in the hydration context."),(0,a.kt)("h4",Object.assign({},{id:"implementing-initview"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#implementing-initview"}),"Implementing ",(0,a.kt)("inlineCode",{parentName:"a"},"initView"))),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"fun initView(): View\n")),(0,a.kt)("p",null,"The only goal of ",(0,a.kt)("inlineCode",{parentName:"p"},"initView")," is to build an Android View. This can be done through inflation, programmatic building, or some framework, as long as the View that is returned represents the corresponding asset. Top-level view creation and any one-time configuration operations should be done in this step. It is best practice to ensure that any access of the asset model is not done in this phase, as ",(0,a.kt)("inlineCode",{parentName:"p"},"initView")," is not guaranteed to be called if the data changes."),(0,a.kt)("h4",Object.assign({},{id:"implementing-hydrate"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#implementing-hydrate"}),"Implementing ",(0,a.kt)("inlineCode",{parentName:"a"},"hydrate"))),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"fun View.hydrate()\n")),(0,a.kt)("p",null,"Hydration is the process responsible for populating the view with the data from the asset model. Any dependencies on the data model should be handled in this step. This includes accessing data, transform functions, or even nested assets. Any views created in ",(0,a.kt)("inlineCode",{parentName:"p"},"hydrate")," will not be automatically cached, but will persist on the UI unless explicitly removed. It is necessary to be vigilant when constructing and removing these views."),(0,a.kt)("h4",Object.assign({},{id:"accessing-data"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#accessing-data"}),"Accessing Data")),(0,a.kt)("p",null,"In most cases, there is some additional data that is used to make the rendering more meaningful. For instance, the intent of the previous ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," asset example was to render a View that displayed the string contained in ",(0,a.kt)("inlineCode",{parentName:"p"},"value"),". Access to such data will be provided through a ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," member on the ",(0,a.kt)("inlineCode",{parentName:"p"},"DecodableAsset"),". This ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," member is a type specified when defining the subclass."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"class TextAsset(assetContext: AssetContext) : DecodableAsset<TextAsset.Data>(Data.serializer()) {\n   \n    @Serializable\n    data class Data(\n       val value: String\n    )\n    \n}\n")),(0,a.kt)("p",null,"With this defined, the ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," can be accessed as an instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"TextAsset.Data"),". It\u2019s important to note that if ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," isn\u2019t defined in the content, this will cause a crash because there isn\u2019t a default value provided. If you have optional fields, make sure the data class is structured appropriately:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"@Serializable\ndata class Data(\n   val value: String? = null\n)\n")),(0,a.kt)("p",null,"As a fallback, data can still be accessed via the Asset instance attached to the AssetContext. The Asset instance is a link into the underlying asset node, which provides a set of getter methods to retrieve data."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),'// type specific getters should throw an error if the type doesn\'t conform\n// although, in some cases, the getter may just return null\nval stringToRender: String = asset.getString("value")\n')),(0,a.kt)("h4",Object.assign({},{id:"nested-assets"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#nested-assets"}),"Nested assets")),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'// ...\n{\n    "id": "some-card",\n    "type": "card",\n    "title": {\n        "asset": {\n            "id": "some-text",\n            "type": "text",\n            "value": "This is a text asset"\n        }\n    }\n}\n// ...\n')),(0,a.kt)("p",null,"Compound assets can be defined such that the asset model contains child assets. These child assets must be wrapped in an asset object. In the example above, there is an ",(0,a.kt)("inlineCode",{parentName:"p"},"card")," asset that delegates to a ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," asset to render a title. The child asset can be directly described as a ",(0,a.kt)("inlineCode",{parentName:"p"},"RenderableAsset")," in the data class."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"@Serializable\ndata class Data(\n   val title: RenderableAsset? = null\n)\n")),(0,a.kt)("p",null,"A helper is provided to reduce overhead with rendering an asset into a layout. ",(0,a.kt)("inlineCode",{parentName:"p"},"into")," will show or hide the target ",(0,a.kt)("inlineCode",{parentName:"p"},"ViewGroup")," based on whether the ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," is null."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"// title_container is a view extension referencing a FrameLayout in an XML layout\ndata.title.render() into title_container \n")),(0,a.kt)("h4",Object.assign({},{id:"styling"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#styling"}),"Styling")),(0,a.kt)("p",null,"Styling can be done completely independently, but the API is designed such that ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," can accept any number of style resources. This allows parent assets to declare any styles that they\u2019d like the child asset to use. These styles are automatically overlaid onto the current Android Context."),(0,a.kt)("p",null,"In the above ",(0,a.kt)("inlineCode",{parentName:"p"},"card")," asset example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"card")," may want to set some text styles to make any text that\u2019s rendered look like a title (i.e. bold, larger, etc)."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"// from the card render\n// assuming that R.style.Text_Title defines these text styles\nval title: View = data.title.render(R.style.Text_Title)\n// the above is shorthand for:\nval title: View = data.title.withStyles(R.style.Text_Title).render()\n")),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),"// from the text render\n// create TextView with the styled context\nfun initView() = TextView(context)\n\n// ensure that the provided view is a TextView and set the text accordingly\n// otherwise, invalidate the view\nfun View.hydrate() {\n    when (this) {\n        is TextView -> text = data.value\n        else -> invalidateView()\n    }\n}\n")),(0,a.kt)("h3",Object.assign({},{id:"registering-assets"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#registering-assets"}),"Registering assets")),(0,a.kt)("p",null,"Registering assets is done in the ",(0,a.kt)("inlineCode",{parentName:"p"},"AndroidPlayerPlugin"),". Each plugin only needs to implement an ",(0,a.kt)("inlineCode",{parentName:"p"},"apply")," method which gives the plugin the opportunity to supplement core player functionality. The ",(0,a.kt)("inlineCode",{parentName:"p"},"AndroidPlayer")," instance contains an asset registry where assets should be register. A helper method has been created to make registration as simple as providing the type and a factory. The factory method must take an AssetContext, and is recommended to just be the constructor of your asset."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),'// registering "some-asset" with SomeAsset constructor\nandroidPlayer.registerAsset("some-asset", ::SomeAsset)\n')),(0,a.kt)("h4",Object.assign({},{id:"partial-match-asset-registration-overrides"}),(0,a.kt)("a",Object.assign({parentName:"h4"},{href:"#partial-match-asset-registration-overrides"}),"Partial match asset registration overrides")),(0,a.kt)("p",null,"This allows registration of multiple assets for the same type, but can match based on other parts of the object"),(0,a.kt)("p",null,"Consider the following asset structure with metaData:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'// ...\n{\n    // unique identifier to distinguish between other assets in the content\n    "id": "some-asset",\n    // type identifier that is used to determine how to render\n    "type": "action",\n    // additional fields used for rendering\n    "label": {...},\n    // metadata\n    "metaData": {\n        "role": "back"\n    }\n}\n// ...\n')),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-kotlin"}),'// registering "action" with BackActionAsset constructor\nval map = mapOf("type" to "action", "metaData" to mapOf("role" to "back"))\nandroidPlayer.assetRegistry.set(map, ::BackActionAsset)\n')),(0,a.kt)("p",null,"This asset will only be used when decoding a view in the JSON tree that is type action, and has the ",(0,a.kt)("inlineCode",{parentName:"p"},"back")," role.\nIn this scenario, the custom action asset implementation would still have access to the transformed values of a regular action asset, such as the ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," method."),(0,a.kt)("p",null,"When creating a new plugin, remember to register it when building the AndroidPlayer!"))}l.isMDXComponent=!0}},function(e){e.O(0,[6525,204,3795,9774,2888,179],(function(){return t=8938,e(e.s=t);var t}));var t=e.O();_N_E=t}]);