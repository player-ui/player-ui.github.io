"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3705],{33705:function(e){e.exports=JSON.parse('{"/./about":{"path":"/./about","content":"\\n\\nPlayer Logo\\nPlayer Logo\\n","title":"About"},"/./about#what-is-player":{"path":"/./about#what-is-player","content":"What Is Player?\\n\\nWhat is Player? Simply put, Player is a framework that enables users to natively render experiences across multiple platforms via a declarative content payload. At Intuit engineers use Player to accelerate the development of new experiences as Player allows them offload data/state management and fit seamlessly with other applications all with minimal configuration.\\n","header":"What Is Player?","title":"About"},"/./about#why-did-we-build-it":{"path":"/./about#why-did-we-build-it","content":"Why Did We Build It?\\nPlayer is the second iteration of this kind of framework. The first iteration that was developed for internal use and worked well but had its limitations. With limited extensibility, limited platform support, and no type support the framework stated to rapidly show its age as we tried to move into newer spaces. It was then determined that we needed to take our learnings from the past few years and rearchitect it from the ground up. And that\'s how we got Player.\\n","header":"Why Did We Build It?","title":"About"},"/./faqs":{"path":"/./faqs","content":"\\n\\n","title":"FAQs"},"/./faqs#frequently-asked-questions":{"path":"/./faqs#frequently-asked-questions","content":"Frequently Asked Questions\\n\\n","header":"Frequently Asked Questions","title":"FAQs"},"/./faqs#how-much-do-i-need-to-know-about-player-to-use-it":{"path":"/./faqs#how-much-do-i-need-to-know-about-player-to-use-it","content":"How much do I need to know about Player to use it?\\nWhile it definitely helps to understand how it works under the hood, as long as you understand the how Assets & Views, Data & Expressions, and Navigation works you should be ready to author Player content.\\n\\nIf you are an engineer integrating Player into your experience you should probably be familiar with what Plugins are available and how to write your own to support the folks who will be authoring the content. The more advanced your use case is you can explore topics as they become applicable.\\n","header":"How much do I need to know about Player to use it?","title":"FAQs"},"/./faqs#where-can-i-see-player-how-player-is-being-used":{"path":"/./faqs#where-can-i-see-player-how-player-is-being-used","content":"Where can I see Player how player is being used?\\nOne of the easiest ways to see Player in action is through our Storybook. This will allow you to take a look at how some of the JSON is passed into player, and what that might look like with our set of reference assets.\\nIf you wanted to get started on using player, please check out our Getting Started Guide.\\n","header":"Where can I see Player how player is being used?","title":"FAQs"},"/./faqs#how-is-player-versioned":{"path":"/./faqs#how-is-player-versioned","content":"How is Player versioned?\\nPlayer follows semantic versioning. We will also publish changelogs for every release.\\n\\nA Major release will denote a breaking change such that it would not, without changes to your implementation or content, work as a drop in replacement. We try and avoid these and will typically batch many breaking changes into a major release to make updating more of a \\"all in one go\\" effort. Additionally we will typically announce these releases and make a RC available for users to test and proactively start updates. A migration guide will also be published with an advisory on the changes and what the recommended migration path is.\\n\\nA Minor release will denote the addition of new functionality that is backward compatible with the previous release. When a new minor version is published we highly encourage users to update promptly.\\n\\nA Patch release will denote a bugfix or a minor non-functional change.\\n","header":"How is Player versioned?","title":"FAQs"},"/./faqs#i-am-having-issues-using-player-how-can-i-get-help":{"path":"/./faqs#i-am-having-issues-using-player-how-can-i-get-help","content":"I am having issues using Player, how can I get help?\\nHead over to our issues page on Github and feel free to open a ticket with the bug report template and we\'ll do our best to get back to you. The more detail you include the easier it will be for us to help troubleshoot.\\n","header":"I am having issues using Player, how can I get help?","title":"FAQs"},"/./faqs#contributing":{"path":"/./faqs#contributing","content":"Contributing\\nCheck out the Contributing Guide as this will show you all of the requirements to get started using Player, how to contribute, and some platform specific guides.\\n","header":"Contributing","title":"FAQs"},"/./other":{"path":"/./other","content":"\\n\\n"},"/./getting-started":{"path":"/./getting-started","content":"\\n\\n","title":"Getting Started"},"/./getting-started#getting-started":{"path":"/./getting-started#getting-started","content":"Getting Started\\n\\nGetting started with Player is simple. Below we have guides per platform on how to integrate Player into your platform of choice.\\n","header":"Getting Started","title":"Getting Started"},"/./getting-started#react":{"path":"/./getting-started#react","content":"React\\n\\n","header":"React","title":"Getting Started"},"/./getting-started#install-dependencies":{"path":"/./getting-started#install-dependencies","content":"Install Dependencies\\n\\nThe first dependency you\'ll need to pull in in the React Player itself. You can do this by running\\n\\nyarn add @player-ui/react\\n\\nor\\n\\nnpm install @player-ui/react\\n","header":"Install Dependencies","title":"Getting Started"},"/./getting-started#configuration":{"path":"/./getting-started#configuration","content":"Configuration\\n\\nNext, in your code you\'ll need to initialize Player. This is where you would also initialize any plugins you want to use with Player and create the configuration for Player itself. Below is a minimal example of this.\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { ReferenceAssetsPlugin } from \'@player-ui/reference-assets-plugin-react\';\\n\\n// create a new web-player instance\\n\\nconst reactPlayer = new ReactPlayer({\\n  plugins: [new ReferenceAssetsPlugin()],\\n});\\n","header":"Configuration","title":"Getting Started"},"/./getting-started#render-content":{"path":"/./getting-started#render-content","content":"Render Content\\n\\nNow that you have a Player instance created. You\'ll need to start it with some content.\\n\\nconst content = {/* your content here */}\\nreactPlayer.start(content);\\n\\nWith Player running your content, you\'ll need to actually render out what is processes. To do this, you can use the React Player\'s component API to inster it into your React tree.\\n\\nconst MyApp = () => {\\n  return ;\\n};\\n\\nCongrats! You\'ve got Player up and running. If you need additional functionality you can add more plugins to extend Player\'s functionality. Head over to the Plugins section to take a look at the Plugins we\'ve developed or take a look at the Architecture section to see how you can write your own.\\n","header":"Render Content","title":"Getting Started"},"/./getting-started#ios-swift":{"path":"/./getting-started#ios-swift","content":"iOS (Swift)\\n\\n","header":"iOS (Swift)","title":"Getting Started"},"/./plugin-implementation":{"path":"/./plugin-implementation","content":"\\n\\n","title":"Plugin Implementation"},"/./team":{"path":"/./team","content":"\\n\\n","title":"Player Team"},"/./team#the-player-team":{"path":"/./team#the-player-team","content":"The Player Team\\n\\n","header":"The Player Team","title":"Player Team"},"/./team#who-we-are":{"path":"/./team#who-we-are","content":"Who We Are\\nThe Player Team is comprised of a group of engineers at Intuit who are passionate about dynamic experiences. Our multidisciplinary background and our multi-platform experience has allowed our team to create and support the Player framework internally for the past few years. You may have seen some of the other open-source projects from out team including auto, design-systems-cli, hooks, proof, and more. We are excited to share our work with the open source community and see how Player grows in the years to come.\\n","header":"Who We Are","title":"Player Team"},"/./writing-plugins":{"path":"/./writing-plugins","content":"\\n\\n","title":"Player Team"},"/./writing-plugins#writing-a-plugin":{"path":"/./writing-plugins#writing-a-plugin","content":"Writing a Plugin\\n\\n While we have published a majority of the plugins we have developed, there will always be new use cases that may require new functionality. Writing a plugin in the easiest way to extend Player functionality for these cases. Plugins work slightly differently on each platform so in this guide we will cover how to write a plugin for each platform.\\n\\nCore plugins are the easiest way to extend Player functionality regardless of what platform you are using Player on. To make writing core plugins easy @player-ui/player exposes an interface PlayerPlugin that denotes everything needed. The two mandatory features are a name property which is lets Player know how to refer to the plugin and an implemented apply function that takes a player object. Optionally a symbol property can be used to provide a unique identifier that can be used to retrieve the plugin from Player.\\n\\nThe first step for creating a plugin is making our plugin class, making sure it implements the PlayerPlugin interface from @player-ui/player. By convention, a name attribute with the dash-cased name of your plugin should be defined.\\n\\nexport default class ExamplePlayerPlugin implements PlayerPlugin {\\n  name = \'example-player-plugin\';\\n\\n  {/* A constructor can go here */}\\n\\n  apply(player: Player) {\\n    {/* Your logic here */}\\n  }\\n\\n  {/* Helper methods can go here */}\\n}\\n\\nThe apply function is where the actual logic of the plugin lives. By tapping the hooks exposed via player.hooks you gain access to the internal pipeline of components that comprise Player and can inject your functionality into their exposed hooks. For example if you want to do something any time Player\'s state changes you could do the following:\\n\\napply(player: Player) {\\n  player.hooks.state.tap(this.name, (state) => {\\n    {/* Your logic here */}\\n  });\\n}\\n\\nSome components expose hooks themselves which may require multiple levels of taps which is not uncommon. For example if you wanted to modify the ViewInstance before it was resolved you would do the following:\\napply(player: Player) {\\n  player.hooks.viewController.tap(this.name, (vc) => {\\n    vc.hooks.view.tap(this.name, (vc) => {\\n      {/* Your logic here */}\\n    })\\n  });\\n}\\n\\nIt is not uncommon for core plugins to have constructors for cases where the plugin needs to take some configuration. In cases where plugin configs are more complicated than basic feature flags, it is recommended to make an interface to represent the config object. As an added benefit it also makes it easier to down stream consumers to use your plugin.\\n\\nFor a more comprehensive guide on plugins, check out this Plugin Implementation example.\\n\\nNote: For the React Player you can import and load the plugin the same way you would a React Player Plugin but for the iOS and Android Players you will need to wrap the javascript bundle in a iOS/Android plugin to ensure it is available on your platform.\\n\\nReact Player Plugins are very similar to core plugins in both their composition and use. The @player-ui/react package exposes an interface ReactPlayerPlugin that, much like the PlayerPlugin interface provides the necessary attributes that are required for a React Player plugin. Again a dash-cased name attribute should be used by convention, and a function applyReact is required that takes a ReactPlayer instance. Similarly to core plugins in the applyReact function you have access to the React Player object and access to the three exposed hooks:\\n\\nThe webComponent hook allows you to modify a React component that is stored in the React Player for use when it renders content. This happens during the initialization phase and ise useful if you want to wrap components in various content providers.\\nThe playerComponent hook allows you to modify a component or execute functionality when the React Player is rendering a component after the view has been reconciled in Player. This is useful if you want to inject additional props to components or collect data on which component was rendered.\\nThe onBeforeViewReset hook is fired when the view is resetting to undefined and you want to execute some asynchronous tasks.\\n\\nBelow is an example of a basic ReactPlayerPlugin that would expose a function to every component that gets loaded in the React Player:\\n\\nexport const FunctionContext = React.createContext({ handler: () => {} });\\n\\nexport const useFunction = (): () => {\\n  const { function } = React.useContext(FunctionContext);\\n  return function;\\n};\\n\\nexport class FunctionPlugin implements ReactPlayerPlugin {\\n  name = \'function-plugin\';\\n  private function: ();\\n\\n  constructor(fn = defaultFunction) {\\n    this.function = fn;\\n  }\\n\\n  applyReact(rp: ReactPlayer) {\\n    rp.hooks.webComponent.tap(this.name, (Comp) => {\\n      const { function } = this;\\n\\n      return () => (\\n\\n      );\\n    });\\n  }\\n\\n  {/* Helper methods can go here */}\\n}\\n\\nLastly React plugins can also act as a core plugin in cases where core functionality needs to be extended for the React plugin to work. Since both the PlayerPlugin and ReactPlayerPlugin are typescript interfaces a plugin can implement both and be considered a valid plugin.\\n\\niOS Player Plugins are very similar to core and react plugins in both their composition and use.\\n","header":"Writing a Plugin","title":"Player Team"},"/./writing-plugins#nativeplugin":{"path":"/./writing-plugins#nativeplugin","content":"NativePlugin\\n\\nThe PlayerUI/Core subspec exposes an interface NativePlugin that, much like the core PlayerPlugin interfaces, provides the necessary attributes that are required for an iOS Player plugin. A pluginName attributed is required, and a function apply is required that takes an instance of a Player implementation. Similarly to core plugins, in the apply function you have access to the Player object and access to the hooks. apply uses generics to future proof so plugins can be used for multiple Player implementations should they be created.\\n\\nThe player passed to apply exposes hooks from the core player, as well as hooks specific to that player implementation. For the current state of this project, the SwiftUIPlayer is the primary iOS Player, and exposes two hooks for the SwiftUI layer specifically:\\n\\nThe view hook allows you to modify the root view that will be displayed in the SwiftUIPlayer body. This is useful for applying changes to the environment for the SwiftUI view tree, or apply ViewModifiers and such.\\nThe transition hook allows you to specify a PlayerViewTransition object to be applied when the flow transitions from one view to another, to animate the transition.\\n","header":"NativePlugin","title":"Player Team"},"/./writing-plugins#basic-example":{"path":"/./writing-plugins#basic-example","content":"Basic Example\\nBelow is an example of a basic NativePlugin that sets a value in the EnvironmentValues when the plugin is included:\\n\\nimport PlayerUI\\n\\nclass EnvironmentPlugin: NativePlugin {\\n    let pluginName = \\"EnvironmentPlugin\\"\\n\\n    func apply(player: P) where P: HeadlessPlayer {\\n      guard let player = player as? SwiftUIPlayer else { return }\\n      player.hooks.view.tap(name: pluginName) { (view: AnyView) -> AnyView in\\n          return AnyView(view.environment(\\\\.someEnvironmentKey, someValue))\\n      }\\n    }\\n}\\n","header":"Basic Example","title":"Player Team"},"/./writing-plugins#asset-registration":{"path":"/./writing-plugins#asset-registration","content":"Asset Registration\\nLikely the most common usecase for plugins is to register assets:\\n\\nimport PlayerUI\\n\\nclass ExampleAssetPlugin: NativePlugin {\\n    let pluginName = \\"ExampleAssetPlugin\\"\\n\\n    func apply(player: P) where P: HeadlessPlayer {\\n      guard let player = player as? SwiftUIPlayer else { return }\\n      player.assetRegistry.register(\\"text\\", asset: TextAsset.self)\\n      player.assetRegistry.register(\\"action\\", asset: ActionAsset.self)\\n    }\\n}\\n","header":"Asset Registration","title":"Player Team"},"/./writing-plugins#jsbaseplugin":{"path":"/./writing-plugins#jsbaseplugin","content":"JSBasePlugin\\nBuilding native features on top of shared functionality is one of the primary benefits of using player. As such we expose convenience utilities to enable loading JavaScript Player Plugins as the base for your NativePlugin.\\n","header":"JSBasePlugin","title":"Player Team"},"/./writing-plugins#basic-setup":{"path":"/./writing-plugins#basic-setup","content":"Basic Setup\\nThis example will load the SharedJSPlugin in the JavaScript layer when included as a plugin to SwiftUIPlayer.\\nimport PlayerUI\\n\\nclass SharedJSPlugin: JSBasePlugin {\\n    convenience init() {\\n      // pluginName must match the exported class name in the JavaScript plugin\\n      self.init(fileName: \'shared-js-plugin-bundle\', pluginName: \'SharedJSPlugin\')\\n    }\\n\\n    // Construct the URL to load the JS bundle\\n    override open func getUrlForFile(fileName: String) -> URL? {\\n      ResourceUtilities.urlForFile(\\n        fileName: fileName,\\n        ext: \\"js\\",\\n        bundle: Bundle(for: YourPlugin.self),\\n        pathComponent: \\"YOUR_POD.bundle\\"\\n      )\\n    }\\n}\\n","header":"Basic Setup","title":"Player Team"},"/assets/custom":{"path":"/assets/custom","content":"\\n\\n","title":"Custom Assets"},"/assets/custom#custom-assets":{"path":"/assets/custom#custom-assets","content":"Custom Assets\\n\\nOne of the conscious design decisions we made when building Player was to abstract away the actual asset implementation and open it up for users to bring their own when using Player. This way you can seamlessly integrate Player into your existing experiences and reuse UI assets you may have already built. Below we\'ve outlined the way to build custom assets on the various platforms Player supports.\\n","header":"Custom Assets","title":"Custom Assets"},"/assets/custom#react":{"path":"/assets/custom#react","content":"React\\n\\n","header":"React","title":"Custom Assets"},"/assets/custom#create-your-asset":{"path":"/assets/custom#create-your-asset","content":"Create Your Asset\\n\\nFirst and foremost you need to create a component to handle rendering of your asset. Without any form of transforms, the props to the component will be those from the incoming player content. It\'s recommended that you attach the id, and any other html properties to the root of the asset\'s tree:\\n\\nconst CustomAssetComp = (props) => {\\n  return (\\n\\n      {props.text}\\n\\n  );\\n};\\n\\nAssuming your authored JSON has a string property named text, this will render that.\\n","header":"Create Your Asset","title":"Custom Assets"},"/assets/custom#register-it-using-a-plugin":{"path":"/assets/custom#register-it-using-a-plugin","content":"Register it Using a Plugin\\n\\nNow that we have a React component to render our asset, let\'s create a plugin to register with Player:\\n\\nimport WebAssetProvider from \'@player-ui/asset-provider-plugin-react\';\\n\\nclass CustomAssetPlugin implements ReactPlayerPlugin{\\n  applyReact(reactPlayer) {\\n    new WebAssetProvider([[\'custom\', CustomAssetComp]]).applyReact(reactPlayer);\\n  }\\n}\\n\\nTypically you register assets by type, but the registry acts by finding the most specific partial object match. This allows you to register more specific implementations for assets of the same type.\\n","header":"Register it Using a Plugin","title":"Custom Assets"},"/assets/custom#rendering-nested-assets":{"path":"/assets/custom#rendering-nested-assets","content":"Rendering Nested Assets\\n\\nOften times, assets contain a reference or slot to another asset. For this to function properly, the custom asset needs to defer to the React Player to render the sub-asset. Say for instance we change our custom asset to now support a header property that takes another asset.\\n\\nUse the ReactAsset Component from the @player-ui/react package with the nested asset as props to dynamically determine the rendering implementation to use:\\n\\nimport { ReactAsset } from \'@player-ui/react\';\\n\\nconst CustomAssetComp = (props) => {\\n  return (\\n\\n      {props.header && }\\n      {props.text}\\n\\n  );\\n};\\n\\nThis would automatically find the appropriate handler for the props.header asset and use that to render.\\n","header":"Rendering Nested Assets","title":"Custom Assets"},"/assets/custom#ios":{"path":"/assets/custom#ios","content":"iOS\\n\\nSwiftUI Player assets are made of 3 parts:\\n\\nData: Decodable AssetData\\nView: A SwiftUI View\\nAsset: SwiftUIAsset implementation to tie the two together\\n","header":"iOS","title":"Custom Assets"},"/assets/custom#data":{"path":"/assets/custom#data","content":"Data\\n\\nSwiftUI Player relies on assets decoding data that conforms to AssetData, this is necessary, because id and type are needed to determine what registered Swift type to decode to. You can include any decodable types in this struct as needed to match the structure of the asset that is returned from the core player.\\n\\nBeyond this, there are a few wrapper types that handle some player specific features:\\n","header":"Data","title":"Custom Assets"},"/assets/custom#modelreference":{"path":"/assets/custom#modelreference","content":"ModelReference\\n\\nModelReference is a wrapper that gets the raw JSValue from Player for a specific node in your asset data. This wrapper exists because if a reference to the data model is used in content, such as:\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"someId\\",\\n    \\"type\\": \\"text\\",\\n    \\"value\\": \\"{{count}}\\"\\n  }\\n}\\n\\nWhile count will not necessarily be a string, in the underlying JavaScript layer, if the entire string value is just a reference to the data model, it is replaced with the exact value from the data model. This means that if count is a number in the data model, when you receive it in the swift layer it will be an Int. So ModelReference gives you a quick helper to get it as a string:\\n\\nstruct TextData: AssetData {\\n  var id: String\\n  var type: String\\n  var value: ModelReference\\n}\\n...\\ntextData.value.stringValue\\n\\nYou can also access someModelReference.rawValue if you need to access the underlying JSValue for some other casting.\\n","header":"ModelReference","title":"Custom Assets"},"/assets/custom#wrappedfunction":{"path":"/assets/custom#wrappedfunction","content":"WrappedFunction\\n\\nJavaScript plugins loaded into the core player, when you have a plugin that extends JSBasePlugin, can transform the resolved asset before it reaches the Swift layer. In many situations, this results in functions being added to an asset to ensure that the same functionality is used on all platforms, and reduce code duplication. WrappedFunction gives you a light wrapper to help decode and call those functions. It takes generic parameter that defines the return type of the function:\\n\\nstruct ActionData: AssetData {\\n  var id: String\\n  var type: String\\n  var run: WrappedFunction\\n}\\n\\n// You can pass any number of arguments to the function\\n// so it\'s important to know what the transform added function\\n// expects\\n\\ndata.run()\\ndata.run(\\"arg1\\", 2)\\n","header":"WrappedFunction","title":"Custom Assets"},"/assets/custom#wrappedasset":{"path":"/assets/custom#wrappedasset","content":"WrappedAsset\\n\\nLast but not least, WrappedAsset represents another asset being defined as a part of this asset. This will be a very common pattern as Player content is intended to be semantic and dynamic. Therefore we need to know that there is an asset in our data, but not what it is, as the implementation is not guaranteed.\\n\\nstruct ActionData: AssetData {\\n  var id: String\\n  var type: String\\n  var label: WrappedAsset\\n  var run: WrappedFunction\\n}\\n\\nRendering these nested assets will be described below.\\n","header":"WrappedAsset","title":"Custom Assets"},"/assets/custom#view":{"path":"/assets/custom#view","content":"View\\n\\nThe view for a SwiftUI Asset is a regular SwiftUI View. Any standard SwiftUI components and concepts will work as normal. The only differentiating factor when it comes to Player assets, is the WrappedAsset and rendering it. WrappedAsset contains a SwiftUIAsset?, so in the event it was not decodable, it will be nil, otherwise, you can access it\'s view property to get a type-erased AnyView and render it in your view:\\n\\nstruct ActionView: View {\\n  var body: some View {\\n    Button(action: {}, label: {\\n      if let label = decodedAssetData.label.asset {\\n        label.view\\n      }\\n    })\\n  }\\n}\\n","header":"View","title":"Custom Assets"},"/assets/custom#asset":{"path":"/assets/custom#asset","content":"Asset\\n\\nThe SwiftUIAsset is the glue between the View and the Data. Player will handle decoding data, and updating the data in an ObservableObject viewModel that contains the Data you tell it to decode.\\n","header":"Asset","title":"Custom Assets"},"/assets/custom#uncontrolledasset":{"path":"/assets/custom#uncontrolledasset","content":"UncontrolledAsset\\n\\nThe UncontrolledAsset is uncontrolled because you do not specify a viewModel type, and receive an implicit AssetViewModel.\\n\\nclass ActionAsset: UncontrolledAsset {\\n    // Populated for you, but copied here for reference\\n    @ObservedObject var model: AssetViewModel\\n}\\n","header":"UncontrolledAsset","title":"Custom Assets"},"/assets/custom#controlledasset":{"path":"/assets/custom#controlledasset","content":"ControlledAsset\\n\\nThe ControlledAsset lets you define the viewModel type, as long as it subclasses AssetViewModel, this way you still receive updated data and user info whenever Player changes state, but you can add other functionality to the viewModel.\\n\\nclass ActionViewModel: AssetViewModel {\\n    public required init(_ data: ActionData, userInfo: [CodingUserInfoKey: Any]) {\\n      super.init(data, userInfo: userInfo)\\n    }\\n}\\nclass ActionAsset: ControlledAsset {\\n    // Populated for you, but copied here for reference\\n    @ObservedObject var model: ActionViewModel\\n}\\n","header":"ControlledAsset","title":"Custom Assets"},"/assets/custom#linking-the-view":{"path":"/assets/custom#linking-the-view","content":"Linking the View\\n\\nIn either situation, your asset implementation needs only to override the view property and return the type erased view you want to use.\\n\\nclass ActionAsset: UncontrolledAsset {\\n\\t\\tpublic override var view: AnyView { AnyView(ActionView(model: model)) }\\n}\\n","header":"Linking the View","title":"Custom Assets"},"/assets/custom#additional-topics":{"path":"/assets/custom#additional-topics","content":"Additional Topics\\n\\n","header":"Additional Topics","title":"Custom Assets"},"/assets/custom#interacting-with-the-data-model-without-a-transform":{"path":"/assets/custom#interacting-with-the-data-model-without-a-transform","content":"Interacting with the Data Model without a transform\\n\\nIf data needs to be set or retrieved without the use of a transform, the InProgressState is available in an environment object, where the DataController can be accessed, as well as other utilities:\\n\\nstruct SomeView: View {\\n  @Environment(\\\\.inProgressState) var state: InProgressState?\\n  var body: some View {\\n    Button(action: {\\n      state?.controllers?.data.set([\\"count\\": 5])\\n    }, label: {...})\\n  }\\n}\\n\\nIf your experience will be used on multiple platforms, it is not advised to use this method, a transform will ensure the same logic is followed on all 3 platforms and is strongly encouraged.\\n","header":"Interacting with the Data Model without a transform","title":"Custom Assets"},"/assets/custom#registering-your-asset":{"path":"/assets/custom#registering-your-asset","content":"Registering your Asset\\n\\nWhen registering your asset with an AssetRegistry, it can either be registered as a new type, if it is an entirely new construct, or registered as a variant of an existing asset type, to only be rendered under certain conditions.\\n\\n// Convenience function for just registering for type\\nplayer.assetRegistry.register(\\"example\\", asset: ExampleAsset.self)\\n\\nplayer.assetRegistry.register([\\"type\\": \\"example\\", \\"metaData\\": [\\"role\\": \\"someRole\\"]], for: ExampleAsset.self)\\n\\nIn the latter case, it is recommended to extend the original asset, so as to avoid boilerplate for data and construction, and just override the render function. If your variant will have additional data decoded that the original asset does not have, you will need to create the whole asset.\\n","header":"Registering your Asset","title":"Custom Assets"},"/assets/custom#why-would-i-register-my-asset-as-a-variant":{"path":"/assets/custom#why-would-i-register-my-asset-as-a-variant","content":"Why Would I Register my Asset as a Variant?\\n\\nTransform backed assets have functions that are attached to them, through shared JavaScript plugins. This simplifies setting data from the asset, by giving simple functions like run in the reference ActionAsset for example. Swift only asset types will not have any convenience functions.\\n\\nRegistering as a variant allows you to maintain usage of the transform backed asset as well as your new asset, so both can be used by the same SwiftUIPlayer instance, including in the same flow. This also maintains the semantics of Player content, an action asset is always an action type of interaction, but with metaData, it can be displayed differently.\\n","header":"Why Would I Register my Asset as a Variant?","title":"Custom Assets"},"/assets/custom#android":{"path":"/assets/custom#android","content":"Android\\n\\nIn order to render an asset a renderer for that type must be registered in the Android Player. If a renderer is found, then Player will delegate rendering when that type is encountered, otherwise Player will skip that node. Creating and registering such a renderer requires the following:\\n\\nExtending DecodableAsset\\n    Implementing initView and hydrate\\n    Define data structure\\n    Nested assets\\n    Styling\\nRegistering assets\\n","header":"Android","title":"Custom Assets"},"/assets/custom#extending-decodableasset":{"path":"/assets/custom#extending-decodableasset","content":"Extending DecodableAsset\\n\\n\\nDecodableAsset is a subclass of RenderableAsset that contains data decoding capabilities built on Kotlinx Serialization. This is the recommended approach for creating an asset and will be consolidated with RenderableAsset in future versions of the Android Player. On top of the requirements for subclassing RenderableAsset, subclassing DecodableAsset requires passing a KSerializer for the data class that represents the data for that asset.\\n\\nRenderableAsset is the base structure used by Player to convert parsed content into Android Views. Each implementation is instantiated with an AssetContext and is required to implement two methods, initView and hydrate. The separation of logic between these two methods allow for views to be cached and optimize the render process. However, both of these methods are only used internally via the render method. render is the main entry point for getting the Android view representation of that asset. It automatically handles the caching and hydration optimizations, only rebuilding and rehydrating when a dependency has changed. The caller would be responsible for handling that view (i.e. injecting it into a ViewGroup).\\n\\nThe RenderableAsset instance is not guaranteed, meaning that state maintained within a RenderableAsset may not persist between initView and hydrate calls. If state is required, that can be accomplished by creating a custom View.\\n\\nSome asset implementations may encounter a situation where the cached view is no longer the corresponding representation of the asset. Under this circumstance, the asset can request a full re-render by calling invalidateView from any point in the hydration context.\\n","header":"Extending DecodableAsset","title":"Custom Assets"},"/assets/custom#implementing-initview":{"path":"/assets/custom#implementing-initview","content":"Implementing initView\\n\\nfun initView(): View\\n\\nThe only goal of initView is to build an Android View. This can be done through inflation, programmatic building, or some framework, as long as the View that is returned represents the corresponding asset. Top-level view creation and any one-time configuration operations should be done in this step. It is best practice to ensure that any access of the asset model is not done in this phase, as initView is not guaranteed to be called if the data changes.\\n","header":"Implementing initView","title":"Custom Assets"},"/assets/custom#implementing-hydrate":{"path":"/assets/custom#implementing-hydrate","content":"Implementing hydrate\\n\\nfun View.hydrate()\\n\\nHydration is the process responsible for populating the view with the data from the asset model. Any dependencies on the data model should be handled in this step. This includes accessing data, transform functions, or even nested assets. Any views created in hydrate will not be automatically cached, but will persist on the UI unless explicitly removed. It is necessary to be vigilant when constructing and removing these views.\\n","header":"Implementing hydrate","title":"Custom Assets"},"/assets/custom#accessing-data":{"path":"/assets/custom#accessing-data","content":"Accessing Data\\n\\nIn most cases, there is some additional data that is used to make the rendering more meaningful. For instance, the intent of the previous text asset example was to render a View that displayed the string contained in value. Access to such data will be provided through a data member on the DecodableAsset. This data member is a type specified when defining the subclass.\\n\\nclass TextAsset(assetContext: AssetContext) : DecodableAsset(Data.serializer()) {\\n\\n    @Serializable\\n    data class Data(\\n       val value: String\\n    )\\n\\n}\\n\\nWith this defined, the data can be accessed as an instance of TextAsset.Data. It\'s important to note that if value isn\'t defined in the content, this will cause a crash because there isn\'t a default value provided. If you have optional fields, make sure the data class is structured appropriately:\\n\\n@Serializable\\ndata class Data(\\n   val value: String? = null\\n)\\n\\nAs a fallback, data can still be accessed via the Asset instance attached to the AssetContext. The Asset instance is a link into the underlying asset node, which provides a set of getter methods to retrieve data.\\n\\n// type specific getters should throw an error if the type doesn\'t conform\\n// although, in some cases, the getter may just return null\\nval stringToRender: String = asset.getString(\\"value\\")\\n","header":"Accessing Data","title":"Custom Assets"},"/assets/custom#nested-assets":{"path":"/assets/custom#nested-assets","content":"Nested assets\\n\\n// ...\\n{\\n    \\"id\\": \\"some-card\\",\\n    \\"type\\": \\"card\\",\\n    \\"title\\": {\\n        \\"asset\\": {\\n            \\"id\\": \\"some-text\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"This is a text asset\\"\\n        }\\n    }\\n}\\n// ...\\n\\nCompound assets can be defined such that the asset model contains child assets. These child assets must be wrapped in an asset object. In the example above, there is an card asset that delegates to a text asset to render a title. The child asset can be directly described as a RenderableAsset in the data class.\\n\\n@Serializable\\ndata class Data(\\n   val title: RenderableAsset? = null\\n)\\n\\nA helper is provided to reduce overhead with rendering an asset into a layout. into will show or hide the target ViewGroup based on whether the View is null.\\n\\n// title_container is a view extension referencing a FrameLayout in an XML layout\\ndata.title.render() into title_container\\n","header":"Nested assets","title":"Custom Assets"},"/assets/custom#styling":{"path":"/assets/custom#styling","content":"Styling\\n\\nStyling can be done completely independently, but the API is designed such that render can accept any number of style resources. This allows parent assets to declare any styles that they\'d like the child asset to use. These styles are automatically overlaid onto the current Android Context.\\n\\nIn the above card asset example, the card may want to set some text styles to make any text that\'s rendered look like a title (i.e. bold, larger, etc).\\n\\n// from the card render\\n// assuming that R.style.Text_Title defines these text styles\\nval title: View = data.title.render(R.style.Text_Title)\\n// the above is shorthand for:\\nval title: View = data.title.withStyles(R.style.Text_Title).render()\\n\\n// from the text render\\n// create TextView with the styled context\\nfun initView() = TextView(context)\\n\\n// ensure that the provided view is a TextView and set the text accordingly\\n// otherwise, invalidate the view\\nfun View.hydrate() {\\n    when (this) {\\n        is TextView -> text = data.value\\n        else -> invalidateView()\\n    }\\n}\\n","header":"Styling","title":"Custom Assets"},"/assets/custom#registering-assets":{"path":"/assets/custom#registering-assets","content":"Registering assets\\n\\nRegistering assets is done in the AndroidPlayerPlugin. Each plugin only needs to implement an apply method which gives the plugin the opportunity to supplement core player functionality. The AndroidPlayer instance contains an asset registry where assets should be register. A helper method has been created to make registration as simple as providing the type and a factory. The factory method must take an AssetContext, and is recommended to just be the constructor of your asset.\\n\\n// registering \\"some-asset\\" with SomeAsset constructor\\nandroidPlayer.registerAsset(\\"some-asset\\", ::SomeAsset)\\n","header":"Registering assets","title":"Custom Assets"},"/assets/dsl":{"path":"/assets/dsl","content":"\\n\\n","title":"Writing DSL Components"},"/assets/dsl#creating-tsx-components":{"path":"/assets/dsl#creating-tsx-components","content":"Creating TSX Components\\n\\nIn order to take advantage of the auto-completion and validation of TypeScript types, asset libraries can export a component library for content authoring. Creating components isn\'t much different than writing a React component for the web. The primative elements uses the react-json-reconciler to create the JSON content tree, with utilities to make it quick and painless to create new asset-components.\\n","header":"Creating TSX Components","title":"Writing DSL Components"},"/assets/dsl#creating-a-basic-component":{"path":"/assets/dsl#creating-a-basic-component","content":"Creating a Basic Component\\n\\nThe Asset component from the @player-tools/dsl package is the quickest way to create a new component. The Asset component will take all the Asset\'s properties and convert them to their equivalent JSON representation when serialized.\\n\\nIn the examples below, we\'ll be creating a TSX component for the action asset in our reference set.\\n\\nThe action asset has a label slot (which is typically used as a text asset), a value (for flow transitions), and an exp for evaluating expressions.\\nFor this example we\'ll use a resemblance of this type, but in practice types should be imported directly from their asset rather than duplicating them.\\n\\nimport type { Asset, AssetWrapper, Expression } from \'@player-ui/player\';\\n\\nexport interface ActionAsset extends Asset {\\n  /* The transition value of the action in the state machine /\\n  value?: string;\\n\\n  /* A text-like asset for the action\'s label /\\n  label?: AssetWrapper;\\n\\n  /* An optional expression to execute before transitioning /\\n  exp?: Expression;\\n}\\n\\nNote: The Asset type we\'re importing here from the @player-ui/player package is different than the Asset component from the @player-tools/dsl package. The former is the basic TypeScript definition for what an Asset in Player is while the latter is a helper function for allowing DSL components to be created. Fundamentally they share a name to reinforce the abstraction of foundational capabilities to core libraries\\n\\nTo turn this interface into a usable component, create a new React component that renders an Asset:\\n\\nimport { Asset, AssetPropsWithChildren } from \'@player-tools/dsl\';\\n\\nexport const Action = (props: AssetPropsWithChildren) => {\\n  return ;\\n}\\n\\nThis would allow users to import the Action component, and render it to JSON:\\n\\nconst myView =\\n\\nwhich when compiled would look like\\n\\n{\\n    \\"id\\": \\"root\\",\\n    \\"type\\": \\"action\\",\\n    \\"value\\": \\"next\\"\\n}\\n\\nThe AssetPropsWithChildren type is a utility type to help convert the Asset type (which has a required id and type properties) to a type more suited for components. It changes the id to be optional, and adds a applicability property automatically.\\n","header":"Creating a Basic Component","title":"Writing DSL Components"},"/assets/dsl#slots":{"path":"/assets/dsl#slots","content":"Slots\\n\\nContinuing the example fo the ActionAsset, we need a way for users to users to specify the nested label property, which itself is another asset. This can be accomplished using the createSlot utility function. The createSlot function also accept components to enable automatically creating text and collection assets when they aren\'t specified where needed. If these components aren\'t passed into the slot when used, the resulting content may be invalid. Let\'s add a Label slot to our Action component to allow it to be easily authored. Lets assume we already have a Text and Collection component.\\n\\nimport React from \'react\';\\nimport { Asset, AssetPropsWithChildren, createSlot } from \'@player-tools/dsl\';\\n\\nexport const Action = (props: AssetPropsWithChildren) => {\\n  return ;\\n}\\n\\nAction.Label = createSlot({\\n  name: \'label\',\\n  wrapInAsset: true,\\n  TextComp: SomeTextComponent\\n  CollectionComp: SomeCollectionComponent\\n})\\n\\nThis adds component (Action.Label) that will automatically place any nested children under the label property of the parent asset:\\n\\nconst myView = (\\n\\n);\\n\\nimport React from \'react\';\\n\\nconst myView = (\\n\\n    Continue\\n\\n);\\n\\nwhich when compiled would look like (note the auto injection of the Text asset and corresponding Asset Wrapper):\\n\\n{\\n    \\"id\\": \\"root\\",\\n    \\"type\\": \\"action\\",\\n    \\"value\\": \\"next\\",\\n    \\"label\\": {\\n        \\"asset\\": {\\n            \\"id\\": \\"root-label-text\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"Continue\\"\\n        }\\n    }\\n}\\n\\nAnd if we wanted to have the label property to have to text assets we could write the following DSL\\n\\nconst myView = (\\n\\n        Some\\n        Text\\n\\n);\\n\\nwhich when compiled would look like the following (note the automatic insertion of the Collection Asset):\\n\\n{\\n    \\"id\\": \\"root\\",\\n    \\"type\\": \\"action\\",\\n    \\"value\\": \\"next\\",\\n    \\"label\\": {\\n        \\"asset\\": {\\n            \\"id\\": \\"root-collection\\",\\n            \\"type\\": \\"text\\",\\n            \\"values\\": [\\n                {\\n                    \\"asset\\": {\\n                        \\"id\\": \\"root-collection-1-text\\",\\n                        \\"type\\": \\"text\\",\\n                        \\"value\\": \\"Some\\"\\n                    }\\n                },{\\n                    \\"asset\\": {\\n                        \\"id\\": \\"root-collection-2-text\\",\\n                        \\"type\\": \\"text\\",\\n                        \\"value\\": \\"Text\\"\\n                    }\\n                }\\n            ]\\n        }\\n    }\\n}\\n","header":"Slots","title":"Writing DSL Components"},"/assets/dsl#creating-a-complex-component":{"path":"/assets/dsl#creating-a-complex-component","content":"Creating a Complex Component\\n\\nWhile a majority of Assets can be described simply via the base Action Component, there are certain cases where DSL components need to contain a bit more logic. This section aims to describe further tools that are offered in the @player-tools/dsl package.\\n","header":"Creating a Complex Component","title":"Writing DSL Components"},"/assets/dsl#components-with-specially-handled-properties":{"path":"/assets/dsl#components-with-specially-handled-properties","content":"Components with Specially Handled Properties\\n\\nIn the previous example, we covered how to create a DSL Component for our reference Action Asset. Our actual Action Asset however looks a little bit different.\\n\\nimport React from \'react\';\\n\\nexport const Action = (\\n  props: Omit, \'exp\'> & {\\n    /* An optional expression to execute before transitioning /\\n    exp?: ExpressionTemplateInstance;\\n  }\\n) => {\\n  const { exp, children, ...rest } = props;\\n\\n  return (\\n\\n      {exp?.toValue()}\\n      {children}\\n\\n  );\\n};\\n\\nCrucially, the difference is in how the exp property is handled. As the exp property is an Expression, if we just allowed the Action component to process this property, we would end up with an ExpressionTemplate instance not an Expression instance. While technically they are equivalent, there is no need to wrap the final string in the Expression Template tags (@[]@) since we know the string will be an Expression and it will just lead to additonal procssing at runtime. Therefore, we need to do a few things to properly construct this DSL component.\\n\\nThe first is to modify the type for the commponent. In the above code snippit we are using the Omit type to remove the base exp property from the source type and replacing it with an exp property that expects a ExpressionTemplateInstance which allows an DSL expression to be passed in.\\n\\nThe second is to extract out the exp property from the props and use a property component to manually control how that property will get serialized. This component is exposed by the underlying react-json-reconciler library which also supplies an array, obj and value component to allow full control over more complicated data structures. The @player-tools/dsl package also exposes the toJsonProperties function to process whole non-Asset objects.\\n","header":"Components with Specially Handled Properties","title":"Writing DSL Components"},"/assets/reference":{"path":"/assets/reference","content":"\\n\\n","title":"Reference Assets"},"/assets/reference#reference-assets":{"path":"/assets/reference#reference-assets","content":"Reference Assets\\n\\nTo help users get started with Player, we have created a minimal set of useable assets for React, iOS and Android. These reference assets showcase the design philosophy we encourage when building your own asset sets. While these components are functional we do not recommend shipping them to production as they have not been tested to be production ready.\\n","header":"Reference Assets","title":"Reference Assets"},"/assets/reference#react":{"path":"/assets/reference#react","content":"React\\n\\nFor the React Player, we ship a package (@player-ui/reference-assets-plugin-react) that provides the reference set of assets. Each asset package exposes a Component, type, and optional transform. They also export hooks for easily consuming the transformed component and supplying your own UI for a custom look and feel. These components are all then exposed via a plugin that can be added to Player like so:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { ReferenceAssetsPlugin } from \'@player-ui/reference-assets-plugin-react\';\\n\\nconst reactPlayer = new ReactPlayer({\\n  plugins: [new ReferenceAssetsPlugin()],\\n});\\n","header":"React","title":"Reference Assets"},"/assets/reference#storybook":{"path":"/assets/reference#storybook","content":"Storybook\\n\\nThe reference assets + React player can be viewed in Storybook\\n","header":"Storybook","title":"Reference Assets"},"/assets/reference#ios":{"path":"/assets/reference#ios","content":"iOS\\n\\nAlongside distributing the PlayerUI pod, there is a PlayerUI/ReferenceAssets subspec used as examples of how Player APIs work for building assets. This pod uses the shared TypeScript transform functions that the React and Android players use for their reference assets, ensuring consistent behavior across platforms. These assets can be loaded into Player like so:\\n\\nimport PlayerUI\\n\\nstruct MyApp: View {\\n  @State var result: Result? = nil\\n  @ObservedObject var viewModel: MyViewModel\\n  var body: some View {\\n    SwiftUIPlayer(\\n      flow: $viewModel.flowString,\\n      plugins: [ReferenceAssetsPlugin()],\\n      result: $result\\n    )\\n  }\\n}\\n","header":"iOS","title":"Reference Assets"},"/assets":{"path":"/assets","content":"\\n\\n","title":"Assets"},"/assets#assets":{"path":"/assets#assets","content":"Assets\\n\\nAn asset is a generic term given to a semantic bit of information that we wish to convey to the user. Assets are the backbone that make up the content that Player renders. Though there are many different types of assets, they all follow the same basic principles:\\n\\nAssets are uniquely identified within their view\\nAssets are semantically meaningful in and of themselves, not relying on any other asset to have meaning\\n\\nIn some cases assets will contain other assets, however the contained assets can also stand on their own. If a complex asset requires information that is specific to itself, then that information is expressed as an object, not an asset.\\n","header":"Assets","title":"Assets"},"/assets#building-blocks-of-assets":{"path":"/assets#building-blocks-of-assets","content":"Building Blocks of Assets\\n\\nThere are a few key components that make up an asset:\\n\\nHow it is described in the source content\\nHow it interacts with Player\\nHow it should render\\n\\nAsset Parts\\n\\nWith few exceptions, an asset requires all three of these to be defined to fully function.\\n","header":"Building Blocks of Assets","title":"Assets"},"/assets#json-contract":{"path":"/assets#json-contract","content":"JSON Contract\\n\\nThe schema of an asset describes the contract between the input content (what user\'s will ultimately author) and your asset. These are often described through interfaces extending the base Asset interface, which can take advantage of the language or validator tooling.\\n","header":"JSON Contract","title":"Assets"},"/assets#data-interaction":{"path":"/assets#data-interaction","content":"Data Interaction\\n\\nThe next logical step is the contract between Player (it\'s data-model, validation rules, etc.) and an instance of an asset in a view. These are described through transform functions, which are stateless mapping functions orchestrated during the view reconciliation processing. You can read more about asset transforms here\\n","header":"Data Interaction","title":"Assets"},"/assets#ui-rendering":{"path":"/assets#ui-rendering","content":"UI Rendering\\n\\nThe last step of the puzzle is how the asset is physically displayed to a user. Given the output of the transform, it presents the user with data to display, or an interactive element to capture a response. Unlike the first 2 parts, the rendering is platform dependent and requires an implementation for each platform you\'re using Player with.\\n","header":"UI Rendering","title":"Assets"},"/assets/transforms":{"path":"/assets/transforms","content":"\\n\\n","title":"Transforms"},"/assets/transforms#assets-and-transforms":{"path":"/assets/transforms#assets-and-transforms","content":"Assets and Transforms\\n\\nThis guide will walk through a few of the core concepts of assets, transforms and how they come together with the UI to create an experience.\\n\\nYou can read more about what an asset is here. In short:\\n\\n> An asset is a generic term given to a semantic bit of information that we wish to convey to the user. Assets are the primitive elements that make up the content that players present as user experiences.\\n\\nFor all intents and purposes, views are equivalent to assets for this guide.\\n","header":"Assets and Transforms","title":"Transforms"},"/assets/transforms#assets-and-the-ui":{"path":"/assets/transforms#assets-and-the-ui","content":"Assets and the UI\\n\\nIn general, the pipeline for user-content is something like:\\n\\nSimple Asset Pipeline\\n\\nPlayer will do minimal processing of each asset in the tree, resolving data in strings, applicability and any other generic processing it can. The processed tree is then sent to the rendering layer, where it is turned into a native component on the system Player is running on.\\n\\nFor simple Assets, like text, there\'s no need for any asset specific processing. The output of Player is enough to successfully render and display the content to the user.\\n\\nAsset Without Transform\\n","header":"Assets and the UI","title":"Transforms"},"/content/assets-views":{"path":"/content/assets-views","content":"\\n\\n","title":"Assets & Views"},"/content/assets-views#assets":{"path":"/content/assets-views#assets","content":"Assets\\n\\nAn asset is a generic term given to a semantic bit of information that we wish to convey to the user. Assets are the primitive elements that make up the content Player presents as user experiences. Though there are many different types of assets, they all follow the same basic principles:\\n\\nassets are uniquely identified within their view\\nassets are semantically meaningful in and of themselves, not relying on any other asset to have meaning\\n\\nIn some cases assets will contain other assets, however the contained assets can also stand on their own. If a complex asset requires information that is specific to itself, then that information is expressed as an object, not an asset.\\n\\nEach asset must have 2 properties: an id and type:\\n\\nid - Unique ID for the asset. It must be unique per view.\\ntype - A descriptive name for the asset type. This is used for handling rendering and transforms.\\n\\nNested assets are represented as objects containing an asset property. For example:\\n\\n{\\n  \\"id\\": \\"parent\\",\\n  \\"type\\": \\"parent\\",\\n  \\"label\\": {\\n    \\"asset\\": {\\n      \\"id\\": \\"child-asset\\",\\n      \\"type\\": \\"child\\"\\n    }\\n  }\\n}\\n\\nThe label of the parent contains a nested asset reference. These are slots that can usually contain any asset type.\\n","header":"Assets","title":"Assets & Views"},"/content/assets-views#views":{"path":"/content/assets-views#views","content":"Views\\n\\nViews are assets that exist at the top level of the tree. They typically include the navigation actions, a title, or other top-level information.\\n\\nThe id of the views are used in the navigation section to reference a specific view from the list.\\n","header":"Views","title":"Assets & Views"},"/content/assets-views#cross-field-validation":{"path":"/content/assets-views#cross-field-validation","content":"Cross-field validation\\n\\nThe other special property of a view vs. an asset is the addition of a validation property on the view. These contain validation objects that are used for validations crossing multiple fields, and are ran on user navigation rather than data change.\\n\\nExample:\\n\\n{\\n  ...\\n  \\"views\\": [\\n    {\\n      \\"id\\": \\"view-1\\",\\n      \\"validation\\": [\\n        {\\n          \\"type\\": \\"expression\\",\\n          \\"ref\\": \\"foo.data.thing1\\",\\n          \\"message\\": \\"Both need to equal 100\\",\\n          \\"exp\\": \\"{{foo.data.thing1}} + {{foo.data.thing2}} == 100\\",\\n        }\\n      ]\\n    }\\n  ]\\n}\\n\\nThey follow the same guidelines for normal validation references, with the addition of a ref property that points to the binding that this validation is tied to.\\n","header":"Cross-field validation","title":"Assets & Views"},"/content/assets-views#applicability":{"path":"/content/assets-views#applicability","content":"Applicability\\n\\nAny object in the tree (including assets) may contain an applicability property. This is an expression that may conditionally show or hide an asset (and all of it\'s children) from the view tree. Applicability is dynamically calculated and will automatically update as data changes on the page.\\n","header":"Applicability","title":"Assets & Views"},"/content/assets-views#switches":{"path":"/content/assets-views#switches","content":"Switches\\n\\nSwitches are ways of dynamically changing the structure of the view based on data. There are 2 types of switches: static and dynamic, but their structures are identical. switches can appear anywhere you\'d find a normal asset, and (similar to templates) are removed from the view before it reaches the UI layer.\\n","header":"Switches","title":"Assets & Views"},"/content/assets-views#usage":{"path":"/content/assets-views#usage","content":"Usage\\n\\nThe switch is simply a list of objects with case and asset properties:\\n\\nasset - The asset that will replace the switch if the case is true\\ncase - An expression to evaluate.\\n\\nThe switch will run through each case statement until the first case expression evaluates to true. For the default case, simple use a value of true at the end of the array.\\n","header":"Usage","title":"Assets & Views"},"/content/assets-views#static-v-dynamic-switches":{"path":"/content/assets-views#static-v-dynamic-switches","content":"Static v Dynamic Switches\\n\\nThe only difference between a static and dynamic switch is the timing update behavior after the first rendering of a view.\\n\\nA staticSwitch calculates the applicable case when a view first renders. It will not re-calculate any of the case statements as data in the view is updated. If you transition away from view-node, and revisit it later-on in the flow, the switch will re-compute the appropriate case statement.\\n\\nA dynamicSwitch will always update the applicable case statement whenever data changes. If data is changed while a view is still showing, the switch will be updated to reflect the new case.\\n","header":"Static v Dynamic Switches","title":"Assets & Views"},"/content/assets-views#example":{"path":"/content/assets-views#example","content":"Example\\n\\nAnywhere you can place an asset node, a dynamicSwitch or staticSwitch can be placed instead.\\n\\n{\\n  \\"staticSwitch\\": [\\n    {\\n      \\"case\\": \\"{{name.first}} == \'adam\'\\",\\n      \\"asset\\": {\\n        \\"id\\": \\"name\\",\\n        \\"type\\": \\"text\\",\\n        \\"value\\": \\"Yay\\"\\n      }\\n    },\\n    {\\n      \\"case\\": \\"{{name.first}} == \'notadam\'\\",\\n      \\"asset\\": {\\n        \\"id\\": \\"name\\",\\n        \\"type\\": \\"text\\",\\n        \\"value\\": \\"Nay\\"\\n      }\\n    },\\n    {\\n      \\"case\\": true,\\n      \\"asset\\": {\\n        \\"id\\": \\"name\\",\\n        \\"type\\": \\"text\\",\\n        \\"value\\": \\"\ud83e\udd37\\"\\n      }\\n    }\\n  ]\\n}\\n","header":"Example","title":"Assets & Views"},"/content/assets-views#templates":{"path":"/content/assets-views#templates","content":"Templates\\n\\nTemplates provide a way to dynamically create a list of assets, or any object, based on data from the model. All of the templating semantics are removed by the time it reaches an asset\'s transform or UI layer.\\n","header":"Templates","title":"Assets & Views"},"/content/data-expressions":{"path":"/content/data-expressions","content":"\\n\\n","title":"Data & Expressions"},"/content/data-expressions#data":{"path":"/content/data-expressions#data","content":"Data\\n\\nData is central to a lot of the functionality and features of Player. The easiest way to deal with data is to supply it in the initial payload when starting a flow. This will seed the model with data and allow you to easily reference values\\n","header":"Data","title":"Data & Expressions"},"/content/data-expressions#bindings":{"path":"/content/data-expressions#bindings","content":"Bindings\\n\\nA binding is a representation of a path within the data-model. In simple terms, it\'s a dot (.) separated string showing the path of the properties within the data object.\\n\\nGiven the following data model:\\n\\ndata: {\\n  foo: {\\n    bar: {\\n      baz: \\"hello world!\\"\\n    },\\n    array: [\\n      {\\n        property: \\"another value\\"\\n      }\\n    ]\\n  },\\n}\\n\\nThen the binding foo.bar.baz will reference the value \\"hello world!\\". Assets that write data to the data model would overwrite \\"hello world\\" when setting to that binding. Using brackets instead of the dot-notation is accepted, similar to accessig properties in real Javascript objects. Unlike Javascript, when using the bracket-notation, surrounding quotes are only required if you need a literal [ or ] in your property name.\\n\\nThe following bindings are all equivalent:\\n\\nfoo.bar.baz\\nfoo\'bar\'\\nfoo[bar].baz\\n\\nFor most bindings, it is recommended to use the dot-notation for all properties when possible. Doing so is consistent, simpler, and the most performant.\\n\\nNote that you can also use integers to access into arrays in the data model. foo.bar.array.0.property will reference \\"another value\\".\\n","header":"Bindings","title":"Data & Expressions"},"/content/data-expressions#query-syntax":{"path":"/content/data-expressions#query-syntax","content":"Query Syntax\\n\\nBindings also allow for query access into arrays using a key/value pair to find the first matching item in the array.\\n\\nThe query syntax takes the form array[key=value]. Where key is the property name you want to compare and value is the value you want to match against. The binding resolves to the first item in the array that has a matching property and value.\\n\\ndata: {\\n  model: {\\n    array: [\\n      {\\n        name: \'alpha\',\\n        foo: \'bar\',\\n      },\\n      {\\n        name: \'bravo\',\\n        foo: \'baz\',\\n      },\\n      {\\n        name: \'charlie\',\\n        foo: \'qux\',\\n      },\\n    ];\\n  }\\n}\\n\\nFor the given data, the following bindings are all equivalent and will point to the first element in the array:\\n\\nmodel.array[0]\\nmodel.array[name=\\"alpha\\"]\\nmodel.array[foo=\\"bar\\"]\\n\\nQuotes around the key or the value of the query are only required when needing to use ambiguous literal characters, such as [, ], or =.\\n\\nNote that the query syntax resolves to the object of the matching query, not to any specific property on the object. If you want to access a specific property, add additional path information after the query. E.g., model.array[name=bravo].name.\\n","header":"Query Syntax","title":"Data & Expressions"},"/content/data-expressions#nested-bindings":{"path":"/content/data-expressions#nested-bindings","content":"Nested Bindings\\n\\nNested bindings allow you to construct a binding path that is relative to a 2nd path or based on some dynamic property. This behavior follows similar model lookup rules that can be used elsewhere in Player.\\n\\nThe syntax for a nested binding is a subpath that is wrapped in double curly braces. E.g., normal.path.{{nested.path}}.more.normal.path.\\n\\ndata: {\\n  colors: {\\n    yellow: {\\n      hex: \\"#ffff00\\"\\n      rgb: \\"rgb(255, 255, 0)\\"\\n    },\\n    red: {\\n      hex: \\"#ff0000\\",\\n      rgb: \\"rgb(255, 0, 0)\\"\\n    }\\n  },\\n  favorites: {\\n    color: \\"yellow\\",\\n    food: \\"tacos\\",\\n    nestedPath: \\"colors.yellow\\"\\n  }\\n}\\n\\nWith this data model, colors.{{favorite.color}}.hex will return the hex value for yellow, \\"#ffff00\\". Any syntax for a regular binding is also valid as part of a nested binding, including further nesting.\\n\\nReferences to bindings that contains sub-paths {{favorite.nestedPath}}.hex will expand to colors.yellow.hex.\\n","header":"Nested Bindings","title":"Data & Expressions"},"/content/data-expressions#nested-expressions":{"path":"/content/data-expressions#nested-expressions","content":"Nested Expressions\\n\\nJust like binding segments can contain other bindings, segments can also contain expressions. For this, they use a segment surrounded by `:\\n\\nSuppose there exists a getFavoriteColor() expression that returns yellow. The following path would resolve to colors.yellow.hex.\\n\\ncolors.getFavoriteColor().hex\\n\\nSimilar to the bracket notation: []. Paths can use brackets instead of dots for paths:\\n\\ncolors[getFavoriteColor()].hex\\n","header":"Nested Expressions","title":"Data & Expressions"},"/content/data-expressions#expressions":{"path":"/content/data-expressions#expressions","content":"Expressions\\n\\nExpressions are callable functions that allow for dynamic behavior of Player and it\'s views.\\n\\nThese functions can be used in ACTION nodes in the navigation section, calculated values in a property of an asset, or anywhere else expressions are valid.\\n\\nCheck out the Expression Plugin for registering custom functions.\\n","header":"Expressions","title":"Data & Expressions"},"/content/data-expressions#using-expressions-and-data-in-a-view":{"path":"/content/data-expressions#using-expressions-and-data-in-a-view","content":"Using Expressions and Data in a View\\n\\nExpressions in the view are strings wrapped in: @[ and ]@.\\n\\nFor instance, to call a sum expression you may use:\\n\\n{\\n  \\"value\\": \\"The sum is @[ sum(1, 2, 3) ]@ dollars\\"\\n}\\n\\nPlayer will handle resolving that value into the proper string before handing it to the UI layers to render. ({ \\"value\\": \\"The sum is 6 dollars\\" })\\n\\nIf an expression is the sole property value:\\n\\n{\\n  \\"value\\": \\"@[ sum(1, 2, 3) ]@\\"\\n}\\n\\nThe raw value of the expression will replace that property rather than being wrapped in a string: { \\"value\\": 6 }\\n\\nData is referenced by wrapping the binding in {{ and }}. This can be used in an expression: @[ {{foo.bar}} + {{foo.baz}} ]@ or within a string: { \\"value\\": \\"Hello {{foo.name}}\\" }\\n\\nSimilar to expressions, any property only consisting of a data value lookup, will get replaced by the raw value.\\n","header":"Using Expressions and Data in a View","title":"Data & Expressions"},"/content/data-expressions#using-expressions-for-inline-text-formatting":{"path":"/content/data-expressions#using-expressions-for-inline-text-formatting","content":"Using Expressions for Inline Text Formatting\\n\\nformat expression is used to replace provided value with appropriate format.\\nFor instance, to format a number into currency, you may use:\\n\\n{\\n  \\"value\\": \\"Total amount is: @[ format(\'12122016\', \'currency\') ]@\\"\\n}\\n\\nTo see the list of currently supported format types, check out Common Types Plugin.\\n","header":"Using Expressions for Inline Text Formatting","title":"Data & Expressions"},"/content":{"path":"/content","content":"\\n\\n","title":"Content"},"/content#content":{"path":"/content#content","content":"Content\\n\\nPlayer is driven off of JSON content that describes the user interactions. It mainly consists of a state-machine, some views to drive display, data, and a schema. Player, once started with the JSON content, will play the flow until it reaches a terminal state in the state-machine, and return the outcome, data, and other relevant information about the flow\'s execution.\\n\\nThe structure of the JSON payload is described below.\\n","header":"Content","title":"Content"},"/content#structure":{"path":"/content#structure","content":"Structure\\n\\nThe high level JSON payload for Player to render consists of: id, views, data, schema, navigation\\n\\nid - (required) - A string that identifies the payload.\\n\\ndata - (optional) - A JSON object that contains data you can reference in the navigation or views section.\\n\\nschema - (optional) - A schema that describes the structure of the data model, including default values, validation rules, etc.\\n\\nviews - (optional) - The views section is an array of assets that are meant to display pages to the user. These can be referenced by ID in the navigation section, and can transition between states in the state machine. Assets are typically semantic in nature, as they are used to render content with dissimilar UIs depending on the context of the user.\\n\\nnavigation - (required) - The navigation section describes a finite state machine that is responsible driving the core Player experience. The nodes can either be: VIEW, ACTION, EXTERNAL, or FLOW\\n","header":"Structure","title":"Content"},"/content/navigation":{"path":"/content/navigation","content":"\\n\\n","title":"Navigation"},"/content/navigation#navigation":{"path":"/content/navigation#navigation","content":"Navigation\\n\\nThe navigation section of the content describes the path the user goes through as they progress. In simple terms, this can be thought of as a set of finite state machines, and the user progresses through each state until they hit a DONE node.\\n\\nThe navigation object contains a BEGIN property that contains a reference to a flow to start Player with. Once an end state is reached for that flow, Player will end its processing and return that outcome.\\n","header":"Navigation","title":"Navigation"},"/content/navigation#flows":{"path":"/content/navigation#flows","content":"Flows\\n\\nFlows are a state machine with 1 start state and at least 1 end state. The nodes are processed in order until an end state is reached. The flow that initiated Player (the BEGIN reference) will be executed until its END state is reached.\\n\\nFlows can also contain an onStart or onEnd property which is an expression that will be evaluated before processing of the first start state takes place, or just prior to ending the flow.\\n","header":"Flows","title":"Navigation"},"/content/navigation#navigation-state-types":{"path":"/content/navigation#navigation-state-types","content":"Navigation State Types\\n\\nThere are a few main navigation state types defined. Each has a slightly different interaction with how it progresses to the end.\\n\\nAll state types (except the END node) contain a transitions property. This is an object describing the relationship on how to proceed to the next node. The key is the name of the transition that is performed, the value is the name of the state to transition to. A key of * can be used as a fallback for any transition value given that doesn\'t match a pre-defined one.\\n","header":"Navigation State Types","title":"Navigation"},"/content/navigation#view":{"path":"/content/navigation#view","content":"VIEW\\n\\nThe view node is the simplest and most widely used. It supports transitions and contains a ref property that corresponds with an id of the view in the views array.\\n\\n{\\n  \\"state_type\\": \\"VIEW\\",\\n  \\"ref\\": \\"view-1\\",\\n  \\"transitions\\": {\\n    \\"next\\": \\"VIEW_2\\"\\n  }\\n}\\n","header":"VIEW","title":"Navigation"},"/content/navigation#action":{"path":"/content/navigation#action","content":"ACTION\\n\\nAn action node allows users to evaluate one of more expressions before proceeding to the next node. The value of the expression (the last value is used if the expression is an array), as the transition value to the next node:\\n\\n{\\n  \\"state_type\\": \\"ACTION\\",\\n  \\"exp\\": [\\"{{foo.value}} = 1 + 2\\", \\"{{foo.value}} > 0\\"],\\n  \\"transitions\\": {\\n    \\"true\\": \\"VIEW_1\\",\\n    \\"false\\": \\"VIEW_2\\"\\n  }\\n}\\n","header":"ACTION","title":"Navigation"},"/content/navigation#end":{"path":"/content/navigation#end","content":"END\\n\\nThe end state represents a completion of a flow. It contains an optional outcome property that can describe the circumstance for ending the flow. No transition state exists as this marks the completion of the flow.\\n\\n{\\n  \\"state_type\\": \\"END\\",\\n  \\"outcome\\": \\"Done_FWD\\"\\n}\\n","header":"END","title":"Navigation"},"/content/navigation#external":{"path":"/content/navigation#external","content":"EXTERNAL\\n\\nThe external state represents a state that can\'t be resolved by Player itself -- it defers resolution of the transition value to the application. This is typically used in conjunction with the ExternalActionPlugin in order to wire up the proper handler that can process these values.\\n\\nSimilar to the view node, external states contain a ref to describe the external state type:\\n\\n{\\n  \\"state_type\\": \\"EXTERNAL\\",\\n  \\"ref\\": \\"custom-state\\",\\n  \\"transitions\\": {\\n    \\"next\\": \\"VIEW_2\\"\\n  }\\n}\\n\\nPlayer will remain in this state until the external handler responds with a transition value to move the current state in the state machine.\\n","header":"EXTERNAL","title":"Navigation"},"/content/navigation#flow":{"path":"/content/navigation#flow","content":"FLOW\\n\\nThe flow state executes the referenced flow, and its outcome determines the transition to use.\\n\\n{\\n  \\"state_type\\": \\"FLOW\\",\\n  \\"ref\\": \\"FLOW-2\\",\\n  \\"transitions\\": {\\n    \\"next\\": \\"VIEW_2\\"\\n  }\\n}\\n\\nReaching this state will execute the FLOW2 flow -- and if FLOW2 reaches an END state with an outcome of next, will transition to the VIEW_2 state\\n\\nState types can also contain onStart and onEnd properties for evaluating expressions. Order of operations:\\n\\nonStart - Evaluated at the start of a node\'s lifecycle; useful for updating data before it\'s resolved\\nexp\\nonEnd - Evaluated last, right before transition. If a transition is halted (by validation or otherwise), the expression won\'t be executed.\\n","header":"FLOW","title":"Navigation"},"/content/navigation#examples":{"path":"/content/navigation#examples","content":"Examples\\n\\n","header":"Examples","title":"Navigation"},"/content/navigation#single-flow":{"path":"/content/navigation#single-flow","content":"Single Flow\\n\\n{\\n  \\"BEGIN\\": \\"FLOW_1\\",\\n  \\"FLOW_1\\": {\\n    \\"startState\\": \\"VIEW_1\\",\\n    \\"VIEW_1\\": {\\n      \\"state_type\\": \\"VIEW\\",\\n      \\"ref\\": \\"view-1\\",\\n      \\"transitions\\": {\\n        \\"*\\": \\"END_1\\"\\n      }\\n    },\\n    \\"END_1\\": {\\n      \\"state_type\\": \\"END\\",\\n      \\"outcome\\": \\"Done\\"\\n    }\\n  }\\n}\\n\\nThis is the simplest of flows. The navigation begins with executing FLOW1. FLOW1 begins with the VIEW1 state. VIEW1 shows the view with id view-1, and any transition from that view goes to END_1 which completes Player\'s execution with the Done outcome.\\n\\nSingle Flow Example\\n","header":"Single Flow","title":"Navigation"},"/content/navigation#flow-with-onstart-expression":{"path":"/content/navigation#flow-with-onstart-expression","content":"Flow with onStart expression\\n\\n{\\n  \\"BEGIN\\": \\"FLOW_1\\",\\n  \\"FLOW_1\\": {\\n    \\"startState\\": \\"VIEW_1\\",\\n    \\"VIEW_1\\": {\\n      \\"state_type\\": \\"VIEW\\",\\n      \\"ref\\": \\"{{dynamicRef}}\\",\\n      \\"onStart\\": \\"{{dynamicRef}} = \'view-1\'\\",\\n      \\"transitions\\": {\\n        \\"*\\": \\"END_1\\"\\n      }\\n    },\\n    \\"END_1\\": {\\n      \\"state_type\\": \\"END\\",\\n      \\"outcome\\": \\"Done\\"\\n    }\\n  }\\n}\\n\\nThe view node in this flow utilizes an onStart expression to update the ref property dynamically. The expression is evaluated before the data is resolved, and the node references the updated id.\\n","header":"Flow with onStart expression","title":"Navigation"},"/content/schema":{"path":"/content/schema","content":"\\n\\n","title":"Schema"},"/content/schema#schema":{"path":"/content/schema#schema","content":"Schema\\n\\nThe schema section of the content describes the relationship between the view and the data. It breaks down properties of the model\'s object into data-types, each with their own spot for validation, formatting, or default-values.\\n","header":"Schema","title":"Schema"},"/content/schema#structure":{"path":"/content/schema#structure","content":"Structure\\n\\nThe root of the data object uses the ROOT keyword in the schema:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"myProperty1\\": {\\n      \\"type\\": \\"MyCustomType\\"\\n    }\\n  }\\n}\\n\\nThis describes a myProperty1 key on the data-model which corresponds to a type of MyCustomType. Structural data-types can be added to the schema as a sibling to ROOT and are referenced by name from the previous type.\\n\\nTo add a name property to the myProperty1 example:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"myProperty1\\": {\\n      \\"type\\": \\"MyCustomType\\"\\n    }\\n  },\\n  \\"MyCustomType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"StringType\\"\\n    }\\n  }\\n}\\n\\nNow the path myProperty1.name in the model points to a StringType. There are a number of basic built-in core types, like StringType, that provide a base set of formatting/validation/default value support out of the box. Read more about those below.\\n","header":"Structure","title":"Schema"},"/content/schema#data-types":{"path":"/content/schema#data-types","content":"Data Types\\n\\nA DataType is a collection of the validation rules, formatting, and default values for a given path in the model. See the above structure docs on how to author these in JSON content.\\n\\nAs in the above StringType example, there are a number of pre-existing base types that can be utilized in the schema to describe a data type, and an extension mechanism for supplying additional base-types for use in the authored content. See the types-provider-plugin for an easy way to extend these.\\n\\nFor any given path described by the schema, Player will merge the rules defined by the base type (if one exists), and the rules defined specifically for that path in the authored content. Any custom formatter/default values take precedence over the default ones, and any custom validations are ran before the base ones.\\n\\nCheck out the CommonTypes plugin for a list of easy to consume DataTypes for your application.\\n","header":"Data Types","title":"Schema"},"/content/schema#arrays":{"path":"/content/schema#arrays","content":"Arrays\\n\\nSometimes the data you\'re using represents an array or list of things. To indicate this in the schema add a isArray: true property to the reference of the top level array. For example, if the data you\'re representing looks like:\\n\\n{\\n  \\"pets\\": [\\n    {\\n      \\"name\\": \\"Frodo\\",\\n      \\"type\\": \\"cat\\"\\n    },\\n    {\\n      \\"name\\": \\"Ginger\\",\\n      \\"type\\": \\"dog\\"\\n    }\\n  ]\\n}\\n\\nthe corresponding schema would be:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"pets\\": {\\n      \\"type\\": \\"PetType\\",\\n      \\"isArray\\": true\\n    }\\n  },\\n  \\"PetType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"StringType\\"\\n    },\\n    \\"type\\": {\\n      \\"type\\": \\"StringType\\"\\n    }\\n  }\\n}\\n\\nEach item in the array will be formatted/validated using the same rule-set.\\n","header":"Arrays","title":"Schema"},"/content/schema#validation":{"path":"/content/schema#validation","content":"Validation\\n\\nTo attach a validation to a path in the data-model, add a reference to a validator in the data-type definition for that path under a validation property:\\n\\n{\\n  \\"MyCustomType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"StringType\\",\\n      \\"validation\\": [\\n        {\\n          \\"type\\": \\"length\\",\\n          \\"max\\": 20,\\n          \\"min\\": 5\\n        }\\n      ]\\n    }\\n  }\\n}\\n\\nEach validation reference must include a type property which corresponds to the name of the validator to run. Player includes some validators out-of-the-box, and custom validators can be registered as well. See the Common Types Plugin docs for more details around which validators are supported, and how to add custom ones.\\n\\nAny additional properties on the validation reference are passed as options to the validator. In the example above, a hypothetical length validator can take a min and max as the boundaries for the length of a string.\\n","header":"Validation","title":"Schema"},"/content/schema#formatting":{"path":"/content/schema#formatting","content":"Formatting\\n\\nSimilar to adding validations, formatting is added to a data-type through a reference to a formatter.\\n\\n{\\n  \\"MyCustomType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"NumberType\\",\\n      \\"format\\": {\\n        \\"type\\": \\"commaNumber\\",\\n        \\"decimalPlaces\\": 3\\n      }\\n    }\\n  }\\n}\\n\\nJust like in validations, the type of the formatter corresponds to the name of a formatter to use (commaNumber in this case). This hypothetical commaNumber formatter would be responsible for translating the data stored in the model to/from what\'s displayed to the user. Any additional properties on the format object get passed to the respective formatter function as options. In the above example, the options would include { decimalPlaces: 3 }.\\n\\nCustom formatters can be registered with Player, and thus exposed for use within the authored content.\\n\\nThe transition from the data stored in the model to the user is considered formating where the inverse (what a user sees to the model is deformatting). Not every formatter has a handler for both formatting and deformatting, and it\'s entirely up the formatter to define the requirements for data handling in these scenarios.\\n\\nRead more about formatting here\\n","header":"Formatting","title":"Schema"},"/dsl":{"path":"/dsl","content":"\\n\\n","title":"DSL Content Overview"},"/dsl#tsxjsx-content-authoring-player-dsl":{"path":"/dsl#tsxjsx-content-authoring-player-dsl","content":"TSX/JSX Content Authoring (Player DSL)\\n\\nWhile Player content can be written directly in JSON, it\'s definitely not the preferable authoring format. To take advantage of existing developer tool-chains, Player provides a mechanism for authoring content in (J/T)SX as React components and simple TypeScript objects. The Player CLI can then be used to transpile the React tree into a JSON content.\\n","header":"TSX/JSX Content Authoring (Player DSL)","title":"DSL Content Overview"},"/dsl#dsl-benefits":{"path":"/dsl#dsl-benefits","content":"DSL Benefits\\n\\nAt a high level, the benefits to writing Player content in the DSL can be summarized by three key factors:\\n","header":"DSL Benefits","title":"DSL Content Overview"},"/dsl#easier-maintainability":{"path":"/dsl#easier-maintainability","content":"Easier maintainability\\nSimply put, DSL code more concise than its JSON equivalent. That means there is less code for you to have to maintain. Also, as its easier to read than JSON, when you do need to make updates to it, its much more wieldy to work with.\\n","header":"Easier maintainability","title":"DSL Content Overview"},"/dsl#better-development-experience":{"path":"/dsl#better-development-experience","content":"Better development experience\\nSince the DSL leverages a lot of standard TypeScript language features, most editors will offer quality of life features like typechecking, suggestions, and code generation. All of this is in service of shortening the feedback loop of writing content and ensuring it is what you intended for it.\\n","header":"Better development experience","title":"DSL Content Overview"},"/dsl#easier-to-extend":{"path":"/dsl#easier-to-extend","content":"Easier to extend\\nThe DSL now offers a easily accessible programatic hook into Player content. This allows custom tooling to be created around your DSL integration much easier that before. Common patterns can be extracted into higher level compoennts, functions can be created to generate code, and code generation can be integrated into almost any process where relevant data is present.\\n\\nFor a further explination on the benefits, see the DSL Benefits section in the DSL Views and the DSL Schema\\n","header":"Easier to extend","title":"DSL Content Overview"},"/dsl#writing-dsl-content":{"path":"/dsl#writing-dsl-content","content":"Writing DSL Content\\n\\nIn order to use the DSL to write content, your plugin library should ship a DSL component package. These will define the primitive components to use to build up the tree. Authorship of these components is covered in the Writing DSL Components secton. The Player Reference Assets ship their own DSL Components via the @player-ui/reference-assets-components pacakge.\\n\\nIn the examples below, we will use the Player Reference Assets Components.\\n","header":"Writing DSL Content","title":"DSL Content Overview"},"/dsl#basic-setup":{"path":"/dsl#basic-setup","content":"Basic Setup\\n\\nTo get started, you\'ll need the following dependencies in your package.json:\\n\\n{\\n    \\"dependencies\\": {\\n        \\"@player-tools/dsl\\": \\"0.4.1\\",\\n        \\"@player-tools/cli\\": \\"0.4.1\\",\\n        \\"@player-ui/reference-assets-components\\": \\"0.6.0\\",\\n        \\"@types/react\\": \\"17.0.39\\",\\n        \\"react\\": \\"17.0.2\\"\\n    }\\n}\\n\\nNext, you\'ll need to configure your environment for DSL Compilation and JSON validation. Below is a basic configuration that can be added in your package.json. For a more detailed explination and examples on further customization please refer to the CLI section.\\n\\n{\\n    \\"player\\": {\\n        \\"dsl\\": {\\n        \\"src\\": \\"./src/main/tsx\\",\\n        \\"outDir\\": \\"./out\\"\\n        },\\n        \\"json\\": {\\n        \\"src\\": \\"./out/*.json\\"\\n        },\\n    }\\n}\\n","header":"Basic Setup","title":"DSL Content Overview"},"/dsl#basic-format-and-file-layout":{"path":"/dsl#basic-format-and-file-layout","content":"Basic Format and File Layout\\n\\nBy default, all files that contain a Player Flow should be exported as a .tsx file and the schema should be in a .ts file. For how to change this behavior, please refer to the DSL Plugins section of the docs. Each of these files should contain a default export of their appropriate object. For example a file that exports a flow should look like the following:\\n\\nexport default {\\n    id: \'my-flow\',\\n    views: [....],\\n    navigation: {....}\\n}\\n\\nand a file that exports the schema should look like:\\n\\nconst mySchema = {...}\\n\\nexport default mySchema\\n","header":"Basic Format and File Layout","title":"DSL Content Overview"},"/dsl#navigation":{"path":"/dsl#navigation","content":"Navigation\\n\\nAt this time the navigation section is a basic JS object. The @player-ui/types package provides typescript typings for this.\\n\\nimport { Navigation } from \'@player-ui/types\';\\n\\nconst navigation: Navigation = {\\n  BEGIN: \'Start\',\\n  Start: {\\n    startState: \'VIEW_1\',\\n    VIEW_1: {\\n      state_type: \'VIEW\',\\n      ref: \'view-1\',\\n      transitions: {\\n        \'*\': \'END_Done\',\\n      },\\n    },\\n    END_Done: {\\n      state_type: \'END\',\\n      outcome: \'done\',\\n    },\\n  },\\n};\\n\\nOne convenience feature is the auto injection of the the ref property for a VIEW type state if the corresponding view is a React tree.\\n\\nimport { Navigation } from \'@player-ui/types\';\\n\\nconst view = (\\n\\n    Some value\\n\\n      Some label\\n\\n);\\n\\nconst navigation: Navigation = {\\n  BEGIN: \'Start\',\\n  Start: {\\n    startState: \'VIEW_1\',\\n    VIEW_1: {\\n      state_type: \'VIEW\',\\n      ref: view,\\n      transitions: {\\n        \'*\': \'END_Done\',\\n      },\\n    },\\n    END_Done: {\\n      state_type: \'END\',\\n      outcome: \'done\',\\n    },\\n  },\\n};\\n","header":"Navigation","title":"DSL Content Overview"},"/dsl#bindings-and-expressions":{"path":"/dsl#bindings-and-expressions","content":"Bindings and Expressions\\n\\nBoth binding and expression in the JSX authoring leverages a tagged template, typically abbreviated as b and e respectively. In a similar fashion to using css or graphql in a JS file, this enables syntax-highlighting and validation of bindings and expressions within a JS file.\\n\\nimport { binding as b, expression as e } from \'@player-tools/dsl\';\\n\\nconst myBinding = bfoo.bar;\\nconst myExpression = efoo();\\n\\nThe binding and expression instances can also automatically dereference themselves when used inside of another string:\\n\\nconst stringWithBinding = Some text: ${myBinding}; // \'Some text: {{foo.bar}}\'\\nconst stringWithExp = Some expr: ${myExpression}; // \'Some expr: @[foo()]@\'\\n","header":"Bindings and Expressions","title":"DSL Content Overview"},"/dsl#view":{"path":"/dsl#view","content":"View\\n\\nPlease refer to the Views section for a detailed overview of how to write DSL Views\\n","header":"View","title":"DSL Content Overview"},"/dsl#schema":{"path":"/dsl#schema","content":"Schema\\n\\nPlease refer to the Schema section for a detailed overview of how to write DSL Schemas\\n","header":"Schema","title":"DSL Content Overview"},"/dsl/plugins":{"path":"/dsl/plugins","content":"\\n\\n","title":"DSL Plugins"},"/dsl/plugins#dsl-plugins":{"path":"/dsl/plugins#dsl-plugins","content":"DSl Plugins\\n\\nMuch like the rest of Player, DSL compilation supports plugins that can influce how content gets compiled and generated. DSL Plugins are a subset of CLI Plugins that use either the hooks available on the CLI itself or on the DSL compiler instance created by the CLI. This section will cover the hooks that are available for use and why you might want to tap them.\\n","header":"DSl Plugins","title":"DSL Plugins"},"/dsl/plugins#cli-hooks":{"path":"/dsl/plugins#cli-hooks","content":"CLI Hooks\\n\\nThe createCompilerContext function available to plugins that extend the PlayerCLIPlugin class gives access to the CompilationContext instance. This class manages the context around DSL compilation and exposes two related hooks.\\n","header":"CLI Hooks","title":"DSL Plugins"},"/dsl/plugins#identifycontenttype":{"path":"/dsl/plugins#identifycontenttype","content":"identifyContentType\\n\\nThe identifyContentType hooks\'s purpose is to allow plugins to inject custom behavior around detecting what kind of file is being compiled. By default there are three types of content the CLI is aware of (view, flow, and schema). Its methods for detecting which kind of content is contained within a file is very rudimentary (the logic can be found here). In order to allow desired convention or orchestrate the compilation of custom file types, this hook provides a mechanism for allowing that custom logic to be injected. The result of this hook is used in the next hook\\n","header":"identifyContentType","title":"DSL Plugins"},"/dsl/plugins#compilecontent":{"path":"/dsl/plugins#compilecontent","content":"compileContent\\n\\nThe compileContent hook\'s purpose is to allow the custom compilation logic for any identified file type. As it is an AsyncSeriesBailHook it will take the first result returned from a tap who was able to return a result for the compilation for the given file of the identified type. In the case where no external logic is added, the hook will attempt to compile any of its known content types with the built in compiler instance.\\n","header":"compileContent","title":"DSL Plugins"},"/dsl/plugins#compilation-hooks":{"path":"/dsl/plugins#compilation-hooks","content":"Compilation Hooks\\n\\nThe CLI will initialize an instance of the DSLCompiler and provide a reference to it via the onCreateDSLCompiler function available to plugins that extend the PlayerCLIPlugin class. On the compiler itself, the following hook are available to modify the behavior of how DSL content is compiled.\\n","header":"Compilation Hooks","title":"DSL Plugins"},"/dsl/plugins#preprocessflow":{"path":"/dsl/plugins#preprocessflow","content":"preProcessFlow\\nNote: Only called for view or flow content\\n\\nThis hook allows transformations on the content before it is compiled. This enables the injection of additonal data or resolving any integration specific convention into something that may be understood by the compiler. This hook can also be used to collate information on what is being compiled for use later.\\n","header":"preProcessFlow","title":"DSL Plugins"},"/dsl/plugins#postprocessflow":{"path":"/dsl/plugins#postprocessflow","content":"postProcessFlow\\nNote: Only called for view or flow content\\n\\nThis hook allows transformations on the content after it is compiled. This allows modifications to the compiled content which in some cases may be preferable as manipulating JSON may be easier than a React Tree.\\n","header":"postProcessFlow","title":"DSL Plugins"},"/dsl/plugins#schemagenerator":{"path":"/dsl/plugins#schemagenerator","content":"schemaGenerator\\n\\nThis hook gives access to the internal SchemaGenerator object which is responsible for compiling the schema. On this generator there are the following hooks.\\n","header":"schemaGenerator","title":"DSL Plugins"},"/dsl/plugins#createschemanode":{"path":"/dsl/plugins#createschemanode","content":"createSchemaNode\\n\\nThis hook allows custom logic for processing schema nodes as they are generated. This enables arbitrary properties to be statically or dynamically added based on the authored schema node. One potential usecase of this is to allow integration specific semantic conventions to be defined and injected into the final schema. For example, the presence of a specific Symbol might mean that a property needs to be injected or even that the schema tree from this point on needs to be modified.\\n","header":"createSchemaNode","title":"DSL Plugins"},"/dsl/schema":{"path":"/dsl/schema","content":"\\n\\n","title":"Writing DSL Schemas"},"/dsl/schema#basic-schema":{"path":"/dsl/schema#basic-schema","content":"Basic Schema\\n\\nTo author a schema object you should first start by constructing a standard typescript object where the nested paths correlate to the paths on your desired schema. When compiled to the final Player Schema object, the intermediate types and ROOT elements will automatically be constructed. A basic example would be:\\n\\nexport default {\\n  foo: {\\n    bar: {\\n      baz: {...}\\n      faz: {...}\\n    }\\n  }\\n}\\n\\nwhich correlates to a schema of:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"foo\\": {\\n      \\"type\\": \\"fooType\\"\\n    }\\n  },\\n  \\"fooType\\": {\\n    \\"bar\\": {\\n      \\"type\\": \\"barType\\"\\n    }\\n  },\\n  \\"barType\\": {\\n    \\"baz\\": {...},\\n    \\"faz\\": {...}\\n  }\\n}\\n","header":"Basic Schema","title":"Writing DSL Schemas"},"/dsl/schema#arrays":{"path":"/dsl/schema#arrays","content":"Arrays\\n\\nA single object array can be used to indicate an array type, for example:\\n\\nexport default {\\n  foo: [\\n    {\\n      bar: {...}\\n    }\\n  ]\\n}\\n\\nwill generate the schema:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"foo\\": {\\n      \\"type\\": \\"fooType\\",\\n      \\"isArray\\": true\\n    }\\n  },\\n  \\"fooType\\": {\\n    \\"bar\\": {\\n      \\"type\\": \\"barType\\"\\n    }\\n  },\\n  \\"barType\\": {\\n    \\"baz\\": {...},\\n    \\"faz\\": {...}\\n  }\\n}\\n","header":"Arrays","title":"Writing DSL Schemas"},"/dsl/schema#changing-the-name-of-a-generated-type":{"path":"/dsl/schema#changing-the-name-of-a-generated-type","content":"Changing the Name of a Generated Type\\n\\nTo change the name of the generated type at any point in the tree, import the SchemaTypeName symbol from the @player-tools/dsl and use it as a key on the object whos name you want to change:\\n\\nimport { SchemaTypeName } from \\"@player-tools/dsl\\"\\nexport default {\\n  foo: {\\n    bar: {\\n      [SchemaTypeName]: \\"buzz\\",\\n      baz: {...}\\n      faz: {...}\\n    }\\n  }\\n}\\n\\nwill generate the schema:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"foo\\": {\\n      \\"type\\": \\"fooType\\",\\n      \\"isArray\\": true\\n    }\\n  },\\n  \\"fooType\\": {\\n    \\"buzz\\": {\\n      \\"type\\": \\"buzzType\\"\\n    }\\n  },\\n  \\"buzzType\\": {\\n    \\"baz\\": {\\n      \\"type\\": \\"\\"\\n    },\\n    \\"faz\\": {\\n      \\"type\\": \\"\\"\\n    }\\n  }\\n}\\n","header":"Changing the Name of a Generated Type","title":"Writing DSL Schemas"},"/dsl/schema#defining-data-types":{"path":"/dsl/schema#defining-data-types","content":"Defining Data Types\\n\\nThe leaf nodes of the schema will need some concrete definition of what data exists at that point of the schema. There are two ways to provide this data.\\n","header":"Defining Data Types","title":"Writing DSL Schemas"},"/dsl/schema#data-refs":{"path":"/dsl/schema#data-refs","content":"Data Refs\\n\\nThe @player-ui/common-types-plugin package exposes the types it provides to Player when used and references to those types as well. Using these Language.DataTypeRef values you can indicate what the data type will be at that node and that it will be a type explicitly defined in Player so no additional information needs to be provided (e.g. validations nor formats) as at runtime it will use the type loaded into Player by the plugin.\\n\\nIt is recommended that if your player integration loads additional types, to export similar references to those types to make authorship easier.\\n","header":"Data Refs","title":"Writing DSL Schemas"},"/dsl/schema#local-data-types":{"path":"/dsl/schema#local-data-types","content":"Local Data Types\\n\\nSometimes you need to define specific data types that extend existing types for certain pieces of data in a schema, whether that be for specific validations, formatting or both. In this case, in your DSL project you can define an object of type Schema.DataType and provide that value to a leaf node. That will indicate that this unique type needs to be included in its entirety to Player as it has information not already contained in Player.\\n","header":"Local Data Types","title":"Writing DSL Schemas"},"/dsl/schema#what-that-looks-like":{"path":"/dsl/schema#what-that-looks-like","content":"What that Looks Like\\n\\nUsing our previous example we can fill in the values with some types now to look like this in the ts object:\\n\\nimport { dataTypes } from \'@player-ui/common-types-plugin\';\\nimport type { Schema } from \'@player-ui/types\';\\n\\nconst mycustombooleantype = {\\n  type: \\"BooleanType\\",\\n  validation: [\\n    {\\n      type: \'oneOf\',\\n      message: \'Value has to be true or false\',\\n      options: [true, false],\\n    },\\n  ],\\n} satisfies Schema.DataType\\n\\nconst mySchema = {\\n  foo: {\\n    bar: {\\n      baz: dataTypes.BooleanTypeRef\\n      faz: mycustombooleantype\\n    }\\n  }\\n}\\n\\nexport default mySchema\\n\\nand like this in the final schema:\\n\\n{\\n  \\"ROOT\\":{\\n    \\"foo\\":{\\n      \\"type\\": \\"fooType\\"\\n    }\\n  },\\n  \\"fooType\\":{\\n    \\"bar\\": {\\n      \\"type\\":\\"barType\\"\\n    }\\n  },\\n  \\"barType\\":{\\n    \\"baz\\":{\\n      \\"type\\": \\"BooleanType\\"\\n    },\\n    \\"faz\\":{\\n      \\"type\\": \\"BooleanType\\",\\n      \\"validation\\": [\\n        {\\n          \\"type\\": \\"oneOf\\",\\n          \\"message\\": \\"Value has to be true or false\\",\\n          \\"options\\": [true, false],\\n        },\\n      ],\\n    }\\n  }\\n}\\n","header":"What that Looks Like","title":"Writing DSL Schemas"},"/dsl/schema#using-the-schema-object-in-jsxtsx-content":{"path":"/dsl/schema#using-the-schema-object-in-jsxtsx-content","content":"Using the Schema Object in JSX/TSX Content\\n\\nAs the schema is now a TypeScript obejct, you can now directly reference the schema anywhere in content. The makeBindingsForObject() function takes your schema object and constructs the bindings opaquely within the object. This allows the use of the native path in your authored content and for the actual underlying binding to be used when the content is compiled. Additionally, as the underlying bindings are exposed, can you can use the native object path with functions like .toString(), .toValue(), and toRefString() like you could with regular string template bindings.\\n\\nimport { makeBindingsForObject } from \'@player-tools/dsl\';\\nimport { mySchema } from \'./schema\'\\n\\nconst schema = makeBindingsForObject(mySchema)\\n\\nconst baz = schema.foo.bar.baz\\n\\nconst view = (\\n\\n        The current value is {baz.toString()}\\n\\n)\\n\\nconst navigation = {...}\\n\\nexport default {\\n  id: \\"example\\",\\n  views: [view],\\n  navigation,\\n}\\n","header":"Using the Schema Object in JSX/TSX Content","title":"Writing DSL Schemas"},"/dsl/schema#dsl-benefit-in-schema":{"path":"/dsl/schema#dsl-benefit-in-schema","content":"DSL Benefit in Schema\\n\\n","header":"DSL Benefit in Schema","title":"Writing DSL Schemas"},"/dsl/views":{"path":"/dsl/views","content":"\\n\\n","title":"Writing DSL Views"},"/dsl/views#overview":{"path":"/dsl/views#overview","content":"Overview\\nWriting assets or views is as simple as creating a React element using your base DSL components:\\n\\nimport React from \'react\';\\nimport { Input, Text, Collection } from \'@player-ui/reference-assets-components\';\\n\\nconst view = (\\n\\n    Some value\\n\\n      Some label\\n\\n);\\n\\nWhen compiled, this would produce the following JSON.\\n\\n{\\n  \\"id\\": \\"root\\",\\n  \\"type\\": \\"collection\\",\\n  \\"values\\": [\\n    {\\n      \\"asset\\": {\\n        \\"id\\": \\"root-values-1\\",\\n        \\"type\\": \\"text\\",\\n        \\"value\\": \\"Some value\\"\\n      }\\n    },\\n    {\\n      \\"asset\\": {\\n        \\"id\\": \\"root-values-2\\",\\n        \\"type\\": \\"input\\",\\n        \\"label\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"root-values-2-label\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"Some label\\"\\n          }\\n        }\\n      }\\n    }\\n  ]\\n}\\n\\nNot only is the source DSL content a fraction of the output object\'s size (making it easier to read and maintain) as the base components use the same TypeScript types as the assets themselves, you will receive in editor suggestions and type checks as you author your content.\\n","header":"Overview","title":"Writing DSL Views"},"/dsl/views#view-concepts-in-dsl":{"path":"/dsl/views#view-concepts-in-dsl","content":"View Concepts in DSL\\n\\n","header":"View Concepts in DSL","title":"Writing DSL Views"},"/dsl/views#templates":{"path":"/dsl/views#templates","content":"Templates\\n\\nTemplates are included via the @player-tools/dsl package. This can be used in any asset slot:\\n\\nimport React from \'react\';\\nimport { dataTypes } from \'@player-ui/common-types-plugin\';\\nimport { makeBindingsForObject, Template } from \'@player-tools/dsl\';\\n\\nconst schema = {\\n  foo: [{\\n    bar: dataTypes.StringType,\\n  }],\\n};\\n\\nconst bindings = makeBindingsForObject(schema);\\n\\n      The current item is: {bindings.foo.index.bar}\\n\\nTemplates can be nested within one another, and the auto-id generation will handle adding the index information to any generated id.\\n","header":"Templates","title":"Writing DSL Views"},"/dsl/views#switches":{"path":"/dsl/views#switches","content":"Switches\\n\\nThe @player-tools/dsl module also includes support for static and dynamic switches.\\n\\nUse the isDynamic flag to denote this should be a dynamicSwitch instead of a staticSwitch:\\n\\nimport React from \'react\';\\nimport { Switch } from \'@player-ui/dsl\';\\n\\n        Text 1\\n\\n        Text 1\\n","header":"Switches","title":"Writing DSL Views"},"/dsl/views#dsl-benefits-in-views":{"path":"/dsl/views#dsl-benefits-in-views","content":"DSL Benefits in Views\\n\\n","header":"DSL Benefits in Views","title":"Writing DSL Views"},"/dsl/views#ids":{"path":"/dsl/views#ids","content":"IDs\\n\\nAny asset can accept an id property, however automatic ID creation is supported out of the box by the base Asset component and it\'s generation behavior can be further customized via your component\'s implementation.\\n","header":"IDs","title":"Writing DSL Views"},"/dsl/views#collectiontext-creation":{"path":"/dsl/views#collectiontext-creation","content":"Collection/Text Creation\\n\\nIn the event that an asset object is expected, but a string or number is found, Player will attempt to automatically create a text node, provided the asset-library has a text-asset-factory configured.\\n\\nSimilarly, if a single asset is expected but a list of them is found instead, Player will attempt to create a collection asset provided the library has the proper configuration set.\\n","header":"Collection/Text Creation","title":"Writing DSL Views"},"/guides/designing-semantic-assets":{"path":"/guides/designing-semantic-assets","content":"\\n\\n","title":"Designing Semantic Assets"},"/guides/designing-semantic-assets#designing-semantic-assets":{"path":"/guides/designing-semantic-assets#designing-semantic-assets","content":"Designing Semantic Assets\\n\\nWhile not a hard requirement by Player, the API design for assets plays an important role in it\'s adoption, especially if the intent is to re-use content across platforms. In many cases, Player content is written, and edited many more times than assets are created, and thus it\'s schema plays an important role in it\'s effective adoption.\\n\\nPlayer ships with a set of Reference Assets to get started, but intentionally doesn\'t include anything beyond some basics. We believe it\'s up to each consumer to define their own semantics (if at all), that best suites their applications.\\n","header":"Designing Semantic Assets","title":"Designing Semantic Assets"},"/guides/multi-flow-experiences":{"path":"/guides/multi-flow-experiences","content":"\\n\\n","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#multi-flow-experiences":{"path":"/guides/multi-flow-experiences#multi-flow-experiences","content":"Multi-Flow Experiences\\n\\nOne large use-case for Player involves orchestrating experiences that span multiple screens that may need to communicate with a back-end between stages. This is commonly used for stepped-flows, onboarding workflows, etc, and manifests as using the response from one Player flow to determine the next one. To facilitate this back-and-forth, Player ships with support for creating a flow-manager.\\n","header":"Multi-Flow Experiences","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#flow-manager":{"path":"/guides/multi-flow-experiences#flow-manager","content":"Flow Manager\\n\\nA flow-manager is an interface for asynchronously stepping through a series of flows in a multi-flow experience. Its API mirrors that of the JavaScript iteration protocol; each flow is loaded by calling .next() using the result of the previous flow (if one exists). Implementations are able to leverage this response to retrieve the next flow in the series, or mark the cycle as complete by returning done.\\n\\nFlow Manager\\n\\nThe standardization of this contract allows any client to manage a series of Player flows without needing to repeat the underlying Player-side orchestration.\\n\\nAn abridged version of the API is described below:\\n\\ninterface FlowManager {\\n  /**\\n   An iterator implementation that takes the result of the previous flow and returns a new one or completion marker.\\n   If done: true is returned, the multi-flow experience is completed.\\n   * @param previousValue - The result of the previous flow.\\n   */\\n  next: (prevResponse: CompletedState) => Promise>;\\n\\n  /**\\n   Called when the flow is ended early (the react tree is torn down)\\n   Allows clients the opportunity to save-data before destroying the tree\\n   */\\n  terminate?: (player: Player) => void;\\n}\\n\\nShown above is also an optional terminate callback. This is used when a flow is ended prematurely (user closes a view) as a means of gathering any critical information from the running player before shutting down.\\n","header":"Flow Manager","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#managed-player":{"path":"/guides/multi-flow-experiences#managed-player","content":"Managed Player\\n\\n\\nThe ManagedPlayer component from the @player-ui/react module orchestrates running flows through Player using a provided flow-manager. Any provided configuration/plugins will be passed along to the underlying ReactPlayer instance, and React.Suspense is used while awaiting the next flow-manager response.\\n\\nSimply render the ManagedPlayer with a flow-manager:\\n\\nimport { ManagedPlayer } from \'@player-ui/react\';\\n\\nexport const App = () => {\\n  return\\n}\\n","header":"Managed Player","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#callbacks-and-error-handling":{"path":"/guides/multi-flow-experiences#callbacks-and-error-handling","content":"Callbacks and Error Handling\\n\\nThe ManagedPlayer also includes callbacks for onComplete and onError to handle the completion of a multi-flow experience.\\n\\nThe fallbackComponent is an optional prop that accepts a React component that will be rendered in case of an error. It\'s given access to the thrown Error object, as well as a retry and reset callback:\\n\\nretry -- Retries the last failed request (the last call to next())\\nreset -- Restarts the multi-flow from the begining, calling next() with an empty context.\\n\\nThe ManagedPlayer SwiftUI Component from the PlayerUI/SwiftUI subspec orchestrates running flows through Player using a provided FlowManager. Any provided configuration or plugins are passed along to the underlying SwiftUIPlayer instance.\\n\\nWhen constructing the ManagedPlayer you supply views to be used for error scenarios, as well as what is displayed while the FlowManager is fetching flows.\\n","header":"Callbacks and Error Handling","title":"Multi-Flow Experiences"},"/plugins/asset-provider":{"path":"/plugins/asset-provider","content":"\\n\\n","title":"Asset Provider Plugin"},"/plugins/asset-provider#asset-provider":{"path":"/plugins/asset-provider#asset-provider","content":"Asset Provider\\n\\nThe Asset Provider Plugin enables users to easily register UI components to render their assets. It\'s used internally by the Reference Assets. The matches follow the same rules as asset transforms (more specific matches take priority).\\n","header":"Asset Provider","title":"Asset Provider Plugin"},"/plugins/asset-provider#usage":{"path":"/plugins/asset-provider#usage","content":"Usage\\n\\n","header":"Usage","title":"Asset Provider Plugin"},"/plugins/asset-provider#platform":{"path":"/plugins/asset-provider#platform","content":"Platform\\n\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/asset-provider-plugin-react\\n\\nCreate an instance, and add it to your Player instance.\\nThe API is similar to the JavaScript Map, and takes a list of [match, Component] tuples.\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { AssetProviderPlugin } from \'@player-ui/asset-provider-plugin-react\';\\n\\nconst player = new ReactPlayer({\\n  plugins: [\\n    new AssetProviderPlugin([\\n      [\'custom-asset\', () => Hello World!],\\n      [{ type: \'custom\', key: \'asset\' }, () => Other Custom Asset],\\n    ])\\n  ]\\n})\\n\\n  This will register a match on { type: \'custom-asset\' } and { type: \'custom\', key: \'asset\' } in the view to use your React components.\\n","header":"Platform","title":"Asset Provider Plugin"},"/plugins/asset-transform":{"path":"/plugins/asset-transform","content":"\\n\\n","title":"Asset Transform"},"/plugins/asset-transform#asset-transform-plugin":{"path":"/plugins/asset-transform#asset-transform-plugin","content":"Asset Transform Plugin\\n\\n","header":"Asset Transform Plugin","title":"Asset Transform"},"/plugins/asset-transform#what-are-transforms":{"path":"/plugins/asset-transform#what-are-transforms","content":"What are transforms?\\n\\nTransforms are functions that map the authored JSON representation of an asset into a stateful JavaScript object, including all of the properties required for that asset to interact with the data-model, navigation, and the rest of Player. This allows UI implementations to have consistent treatment and behavior. While the transform plugin is registered in the core layer, it can be wrapped by the native platforms.\\n","header":"What are transforms?","title":"Asset Transform"},"/plugins/asset-transform#partial-matching":{"path":"/plugins/asset-transform#partial-matching","content":"Partial Matching\\n\\nThe transform plugin makes use of the partial-match-registry which ranks matching templates by the number of matching key-value pairs. This allows users to overwrite the implementation of the lookup, if more specific search criteria is provided. This registry/lookup pattern is also utilized in the web-player for the React Component to Asset mapping.\\n","header":"Partial Matching","title":"Asset Transform"},"/plugins/asset-transform#usage":{"path":"/plugins/asset-transform#usage","content":"Usage\\n\\n","header":"Usage","title":"Asset Transform"},"/plugins/asset-transform#transform-arguments":{"path":"/plugins/asset-transform#transform-arguments","content":"Transform Arguments\\n\\nEach transform is a function that is passed 3 arguments: the current asset node, and an options object containing a data-model, expression-evaluator, binding-parser, and a flow transition function, and a store for state management. The transforms should return an immutable representation of the asset, including any means of interacting with the player.\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { AssetTransformPlugin } from \'@player-ui/asset-transform-plugin\';\\n\\n// Add it to Player\\n\\nconst player = new Player({\\n  plugins: [\\n    new AssetTransformPlugin(\\n      new Registry([\\n        // Register a match for any action type with a custom transform.\\n        [\\n          { type: \'action\' },\\n          value => {\\n            return {\\n              ...value,\\n              hello: () => console.log(\'hello world\')\\n            };\\n          }\\n        ]\\n      ])\\n    )\\n  ]\\n});\\n","header":"Transform Arguments","title":"Asset Transform"},"/plugins/asset-transform#state-management":{"path":"/plugins/asset-transform#state-management","content":"State Management\\n\\nOften times node transforms require some state to be stored between updates. Historically this state was put in the data-model under local (to not send it back to the server), but updates became difficult to manage, and namespace collisions under local were up to the transforms to discern.\\n\\nThe third argument to the transform functions expose a store for data, that mirrors the usage of React hooks. This allow transforms to store state information in an automatically scoped store outside of the normal data tree.\\n\\nA simple transform to manage a counter might look like:\\n\\nconst transform = (asset, options, store) => {\\n  const [count, setCount] = store.useState(0);\\n  return {\\n    ...asset,\\n    count,\\n    increment() {\\n      setCount(count + 1);\\n    }\\n  };\\n};\\n","header":"State Management","title":"Asset Transform"},"/plugins/async-node":{"path":"/plugins/async-node","content":"\\n\\n","title":"AsyncNode Plugin"},"/plugins/async-node#async-node-plugin":{"path":"/plugins/async-node#async-node-plugin","content":"Async Node Plugin\\n\\nThe AsyncNode Plugin is used to enable streaming additional content into a flow that has already been loaded and rendered.\\nA common use case for this plugin is conversational UI, as the users input more dialogue, new content must be streamed into Player in order to keep the UI up to date.\\n\\nThe pillar that makes this possible is the concept of an AsyncNode. An AsyncNode is any tree node with the property async: true, it represents a placeholder node that will be replaced by a concrete node in the future.\\n\\nIn the example below, node with the id \\"some-async-node\\" will not be rendered on first render, but will be replaced with a UI asset node at a later time:\\n\\n{\\n  \\"id\\": \\"flow-1\\",\\n    \\"views\\": [\\n      {\\n        \\"id\\": \'action\',\\n        \\"actions\\": [\\n          {\\n            \\"id\\": \\"some-async-node\\",\\n            \\"async\\": true,\\n          },\\n        ],\\n      },\\n    ],\\n  ...\\n}\\n\\nThe AsyncNodePlugin exposes an onAsyncNode hook on all platforms. The onAsyncNode hook will be invoked with the current node when the plugin is available and an AsyncNode is detected during the resolve process. The node used to call the hook with could contain metadata according to content spec.\\n\\nUser should tap into the onAsyncNode hook to examine the node\'s metadata before making a decision on what to replace the async node with. The return could be a single asset node or an array of asset nodes.\\n","header":"Async Node Plugin","title":"AsyncNode Plugin"},"/plugins/async-node#continuous-streaming":{"path":"/plugins/async-node#continuous-streaming","content":"Continuous Streaming\\n\\nIn order to keep streaming in new content, there must be at least 1 or more AsyncNodes in the view tree at all times.\\nThis means there must be a constant renewal of new AsyncNodes after the previous ones are resolved by the user.\\n","header":"Continuous Streaming","title":"AsyncNode Plugin"},"/plugins/async-node#usage":{"path":"/plugins/async-node#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { AsyncNodePlugin } from \'@player-ui/async-node-plugin\';\\n\\nconst asyncNodePlugin = new AsyncNodePlugin();\\n\\n// Configuring async node behaviour\\nasyncNodePlugin.hooks.onAsyncNode.tap(\'handleAsync\', async (node: Node.Node) => {\\n  ...\\n  // Determine what to return to be parsed into a concrete UI asset\\n});\\n\\nconst player = new Player({\\n  plugins: [\\n    asyncNodePlugin\\n  ]\\n})\\n\\nThe react version of the AsyncNodePlugin is identical to using the core plugin. Refer to core usage for handler configuration:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { MetricsPlugin } from \'@player-ui/async-node-plugin\';\\n\\nconst asyncNodePlugin = new AsyncNodePlugin();\\n\\nconst player = new ReactPlayer({\\n  plugins: [\\n    asyncNodePlugin\\n  ]\\n})\\n","header":"Usage","title":"AsyncNode Plugin"},"/plugins/async-node#cocoapods":{"path":"/plugins/async-node#cocoapods","content":"CocoaPods\\n\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/AsyncNodePlugin\'\\n","header":"CocoaPods","title":"AsyncNode Plugin"},"/plugins/auto-scroll-manager":{"path":"/plugins/auto-scroll-manager","content":"\\n\\n","title":"Auto Scroll Manager Plugin"},"/plugins/auto-scroll-manager#auto-scroll-manager-plugin":{"path":"/plugins/auto-scroll-manager#auto-scroll-manager-plugin","content":"Auto Scroll Manager Plugin\\n\\nThe Auto Scroll Plugin helps orchestrate scrolling to components based off of 3 scenarios:\\n\\nOn page load\\nOn validation trigger\\nOn first appearance after page load\\n","header":"Auto Scroll Manager Plugin","title":"Auto Scroll Manager Plugin"},"/plugins/beacon":{"path":"/plugins/beacon","content":"\\n\\n","title":"Beacon Plugin"},"/plugins/beacon#beacon-plugin":{"path":"/plugins/beacon#beacon-plugin","content":"Beacon Plugin\\n\\nThe beacon plugin enables users to send and/or collect beaconing information from assets in a normalized API. It exposes a common API for publishing beacons from an asset library, and will automatically attach itself to the current view, enabling additional meta-data to be added to each event.\\n","header":"Beacon Plugin","title":"Beacon Plugin"},"/plugins/beacon#consuming-beacons":{"path":"/plugins/beacon#consuming-beacons","content":"Consuming Beacons\\n\\n","header":"Consuming Beacons","title":"Beacon Plugin"},"/plugins/beacon#beacon-format":{"path":"/plugins/beacon#beacon-format","content":"Beacon Format\\n\\nBy default, the beacon plugin returns beacons in the following format:\\n\\ninterface DefaultBeacon {\\n  /* The user action taken (\'clicked\', \'visited\') */\\n  action: string;\\n\\n  /* The type of UI element interacted with (\'button\', \'menu\') */\\n  element: string;\\n\\n  /* Any additional data from a metaData.beacon property */\\n  data: any;\\n\\n  /* The id of the asset */\\n  assetId: string;\\n\\n  /* The id of the view */\\n  viewId: string;\\n}\\n","header":"Beacon Format","title":"Beacon Plugin"},"/plugins/beacon#usage":{"path":"/plugins/beacon#usage","content":"Usage\\n\\n\\nAdd the beacon plugin to a player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { BeaconPlugin } from \'@player-ui/beacon-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new BeaconPlugin({\\n\\n      // Any plugins to the beacon-plugin\\n      plugins: [],\\n\\n      // Callback to handle any beacon event\\n      callback: () => {}\\n    }),\\n  ],\\n});\\n\\nBeacons can be published directly by the plugin, but in most cases, a platform specific adapter is recommended.\\n\\nbeaconPlugin.beacon({\\n  action: \'click\',\\n  element: \'button\',\\n  asset: asset // The entire Asset object, for use in the plugin pipeline\\n  // other metadata\\n});\\n\\nJust like with the core variant, to add support for beaconing in the react player, add the plugin to Player:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { BeaconPlugin } from \'@player-ui/beacon-plugin-react\';\\n\\nconst player = new ReactPlayer({\\n  plugins: [\\n    new BeaconPlugin({\\n\\n      // Any plugins to the beacon-plugin\\n      plugins: [],\\n\\n      // Callback to handle any beacon event\\n      callback: () => {}\\n    }),\\n  ],\\n});\\n\\nThis will add additional React Context to the running player for the producers from asset-libraries to leverage.\\n","header":"Usage","title":"Beacon Plugin"},"/plugins/beacon#cocoapods":{"path":"/plugins/beacon#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/BeaconPlugin\'\\n","header":"CocoaPods","title":"Beacon Plugin"},"/plugins/beacon#swift-usage":{"path":"/plugins/beacon#swift-usage","content":"Swift Usage\\n\\nTo receive Beacon events from Player in iOS, add the BeaconPlugin to your plugin array:\\n\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      BeaconPlugin { (beacon: DefaultBeacon) in\\n\\t\\t\\t\\t// Process beacon into the format you need for your analytics platform\\n\\t\\t\\t}\\n    ]\\n  )\\n}\\n\\nIf you are modifying the beacon using core BeaconPlugin plugins:\\n\\nstruct CustomBeacon: Decodable {\\n  public var action: String\\n  public var element: String\\n  public var customElement: Int\\n}\\n\\nclass CustomBeaconPlugin: JSBasePlugin {\\n  convenience init() {\\n    self.init(fileName: \\"custom-beacon\\", pluginName: \\"CustomBeaconPlugin\\")\\n  }\\n  override open func getUrlForFile(fileName: String) -> URL? {\\n        ResourceUtilities.urlForFile(\\n          name: fileName,\\n          ext: \\"js\\",\\n          bundle: Bundle(for: .self),\\n          pathComponent: \\".bundle\\"\\n        )\\n    }\\n}\\n\\n// In some SwiftUI View\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      BeaconPlugin { (beacon: CustomBeacon) in\\n\\t\\t\\t\\t// Process beacon into the format you need for Segment/Trinity and send it on\\n\\t\\t\\t}\\n    ]\\n  )\\n}\\n\\nBeaconing on the JVM platform (including Android) is done with an instance of the BeaconPlugin. By default, the Android Player includes a wrapper of the core beacon plugin. The Android Player can be configured to override the default BeaconPlugin by passing a different BeaconPlugin implementation on instantiation which can contain further configuration.\\n\\nWithout additional configuration, the BeaconPlugin doesn\'t provide much value. Beacons must be explicitly handled in order to forward them to an analytics platform (segment, Trinity, etc.). This is done by calling registerHandler(handler: (String) -> Unit) with a callback.\\n\\nval beaconPlugin = BeaconPlugin()\\nbeaconPlugin.registerHandler { beacon: String ->\\n    // Process beacon and send to analytics platform\\n}\\n\\nThere may be some beacons that are fired automatically by the BeaconPlugin implementation, but in most cases, there are additional beacons that should be fired on some interaction (i.e. user tapping button asset). This is done by calling beacon(action: String, element: String, asset: Asset, data: Any? = null) with the relevant information.\\n\\nval beaconPlugin = BeaconPlugin()\\nbeaconPlugin.beacon(\\n    \\"clicked\\",\\n    \\"button\\",\\n    assetThatIsBeaconing,\\n    someData,\\n)\\n\\nFor convenience, there are several extension methods for utilizing a pre-installed BeaconPlugin from Player. If there isn\'t a BeaconPlugin installed, Player will produce a warning log.\\n\\n// registering handler\\nandroidPlayer.onBeacon { beacon: String ->\\n    // Process beacon and send to analytics platform\\n}\\n\\n// fire beacon\\nandroidPlayer.beacon(\\n    \\"clicked\\",\\n    \\"button\\",\\n    assetThatIsBeaconing,\\n    someData,\\n)\\n\\nThe base RenderableAsset class provides an additional helper to make beaconing less verbose from an asset perspective.\\n\\nHelper in RenderableAsset\\n","header":"Swift Usage","title":"Beacon Plugin"},"/plugins/beacon#beacon-plugins":{"path":"/plugins/beacon#beacon-plugins","content":"Beacon Plugins\\n\\nSimilar to how Player accepts plugins, the beacon-plugin itself accepts a list of plugins. These are able to mutate and augment the beacon payload as it makes its way through the publishing pipeline.\\n\\nThere are 3 hooks that are currently exposed:\\n\\nbuildBeacon - Assembles a given beacon ffor publishing\\ncancelBeacon - Given a current beacon, determine if it should be published or not.\\npublishBeacon - Receive the final becaon. This is a substitute for the callback in the beacon plugin options.\\n","header":"Beacon Plugins","title":"Beacon Plugin"},"/plugins/beacon#publishing-beacons":{"path":"/plugins/beacon#publishing-beacons","content":"Publishing Beacons\\n\\n","header":"Publishing Beacons","title":"Beacon Plugin"},"/plugins/beacon#beacon-expression":{"path":"/plugins/beacon#beacon-expression","content":"beacon expression\\n\\nThe beacon plugin adds support for a beacon expression that can be referenced within content. Each beacon referenced from this expression will be assumed to originate from a view (no local asset information will be attached)\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"my-action\\",\\n    \\"type\\": \\"action\\",\\n    \\"exp\\": \\"beacon(\'my-action\', \'some-data\')\\"\\n  }\\n}\\n","header":"beacon expression","title":"Beacon Plugin"},"/plugins/beacon#assets":{"path":"/plugins/beacon#assets","content":"Assets\\n\\n","header":"Assets","title":"Beacon Plugin"},"/plugins/check-path":{"path":"/plugins/check-path","content":"\\n\\n","title":"Check Path Plugin"},"/plugins/check-path#check-path-plugin":{"path":"/plugins/check-path#check-path-plugin","content":"Check Path Plugin\\n\\nThe Check Path Plugin enables users to query segments of the view tree for contextual rendering or behavior.\\nThis is best suited to be referenced during the UI rendering phase, where one can make decisions about the rendering of an asset based on where it lies in the tree.\\n","header":"Check Path Plugin","title":"Check Path Plugin"},"/plugins/check-path#usage":{"path":"/plugins/check-path#usage","content":"Usage\\n\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/check-path-plugin\\n\\nAdd it to Player:\\n\\nimport CheckPathPlugin from \'@player-ui/check-path-plugin\';\\n\\nconst checkPathPlugin = new CheckPathPlugin();\\nconst player = new Player({ plugins: [checkPathPlugin] });\\n\\n// Start your flow\\nplayer.start(myFlow);\\n\\nThen use the plugin to query the view:\\n\\nconst isCustomThing = checkPathPlugin.hasParentContext(\'my-asset-id\', [\\n  \'input\',\\n  \'myCustomViewType\',\\n]);\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/check-path-plugin-react\\n6474792156\\nAdd it to Player:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { CheckPathPlugin } from \'@player-ui/check-path-plugin-react\';\\n\\nconst rp = new ReactPlayer({\\n  plugins: [new CheckPathPlugin()],\\n});\\n\\nThis will automatically create the underlying core version of the CheckPathPlugin to be made available via React Context for the hooks.\\n","header":"Usage","title":"Check Path Plugin"},"/plugins/check-path#cocoapods":{"path":"/plugins/check-path#cocoapods","content":"CocoaPods\\n\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/SwiftUICheckPathPlugin\'\\n","header":"CocoaPods","title":"Check Path Plugin"},"/plugins/check-path#swift-usage":{"path":"/plugins/check-path#swift-usage","content":"Swift Usage\\n\\nThis plugin takes no parameters, and the configuration comes from content, it can just be added to the plugin array:\\n\\nvar body: some View {\\n    SwiftUIPlayer(\\n        flow: flow,\\n        plugins: [\\n          SwiftUICheckPathPlugin()\\n        ],\\n        result: $resultBinding\\n    )\\n}\\n\\nIn build.gradle\\n\\nimplementation \\"com.intuit.player.plugins:check-path:$PLAYER_VERSION\\"\\n\\nIn Player constructor\\n\\nimport com.intuit.player.plugins.checkpath.CheckPathPlugin\\n\\nval plugins = listOf(CheckPathPlugin())\\nAndroidPlayer(plugins)\\n","header":"Swift Usage","title":"Check Path Plugin"},"/plugins/check-path#api":{"path":"/plugins/check-path#api","content":"API\\n\\n","header":"API","title":"Check Path Plugin"},"/plugins/check-path#query":{"path":"/plugins/check-path#query","content":"Query\\n\\nIn most of the methods, the Query type is referenced.\\nThis can either be a function, string, or an object.\\n\\nstring - an alias for { type: \'\' }\\nobject - uses a partial-object match to query the object\\nfunction - a filter that gets passed an object, and returns a boolean\\n\\nThere are a few different functions exposed by the plugin you can use:\\n","header":"Query","title":"Check Path Plugin"},"/plugins/check-path#getparent":{"path":"/plugins/check-path#getparent","content":"getParent\\n\\nfunction getParent(id: string, query: Query | Query[]): Asset | undefined\\n\\nThe getParent method allows you to query up the tree, and return the first parent that matches the given query, or undefined.\\nIf an array is passed, the tree is parsed matching on each query item from left to right. The parent object that matches the last query item is returned.\\n","header":"getParent","title":"Check Path Plugin"},"/plugins/check-path#getparentprop":{"path":"/plugins/check-path#getparentprop","content":"getParentProp\\n\\nfunction getParentProp(id: string): string | undefined\\n\\nThe getParentProp method returns the property on the parent object that the current object falls under.\\nFor example, an input with a text asset as the label, will return label for the parentProp of the text asset.\\n","header":"getParentProp","title":"Check Path Plugin"},"/plugins/check-path#hasparentcontext":{"path":"/plugins/check-path#hasparentcontext","content":"hasParentContext\\n\\nfunction hasParentContext(id: string, query: Query | Query[]): boolean\\n\\nSimilar to getParent, the hasParentContext method responds with the existence of a parent with the given context.\\n","header":"hasParentContext","title":"Check Path Plugin"},"/plugins/check-path#haschildcontext":{"path":"/plugins/check-path#haschildcontext","content":"hasChildContext\\n\\nfunction hasChildContext(id: string, query: Query | Query[]): boolean\\n\\nThe compliment of hasParentContext, hasChildContext traverses down the tree for any path from the given node that satisfies the context requirements.\\n\\nThe API for the React version of the CheckPathPlugin is similar to the core version, just exposed through React hooks for easy use in custom assets:\\n\\nfunction useGetParent(id: string, query: Query | Query[]): Asset | undefined;\\nfunction useGetParentProp(id: string): string | undefined;\\nfunction useHasParentContext(id: string, query: Query | Query[]): boolean;\\nfunction useHasChildContext(id: string, query: Query | Query[]): boolean;\\n","header":"hasChildContext","title":"Check Path Plugin"},"/plugins/check-path#example":{"path":"/plugins/check-path#example","content":"Example\\n\\nimport { useHasParentContext } from \'@player-ui/check-path-plugin-react\';\\n\\nexport const MyAsset = ({ id }) => {\\n  // If the asset is rendered within a form, render as a select instead of a radio button\\n  const isInForm = useHasParentContext(id, \'form\');\\n  return isInForm ?  : ;\\n}\\n","header":"Example","title":"Check Path Plugin"},"/plugins/common-expressions":{"path":"/plugins/common-expressions","content":"\\n\\n","title":"Common Expressions"},"/plugins/common-expressions#common-expressions-plugin":{"path":"/plugins/common-expressions#common-expressions-plugin","content":"Common Expressions Plugin\\n\\nThis plugin exposes some basic expressions into Player content.\\n\\nIt also serves as a good reference to adding your own custom expressions into Player.\\n","header":"Common Expressions Plugin","title":"Common Expressions"},"/plugins/common-expressions#usage":{"path":"/plugins/common-expressions#usage","content":"Usage\\n\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/common-types-plugin\\n\\nAdd it to Player:\\nimport CommonExpressionsPlugin from \'@player-ui/common-expressions-plugin\';\\n\\nconst commonExpressionsPlugin = new CommonExpressionsPlugin();\\nconst player = new Player({ plugins: [commonExpressionsPlugin] });\\n\\n// Start your flow\\nplayer.start(myFlow);\\n\\nThis will allow any included expressions or custom expressions to be used in the content\\n","header":"Usage","title":"Common Expressions"},"/plugins/common-expressions#cocoapods":{"path":"/plugins/common-expressions#cocoapods","content":"CocoaPods\\n\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/CommonExpressionsPlugin\'\\n","header":"CocoaPods","title":"Common Expressions"},"/plugins/common-expressions#swift-usage":{"path":"/plugins/common-expressions#swift-usage","content":"Swift Usage\\n\\nThis plugin takes no parameters, and the configuration comes from content, it can just be added to the plugin array:\\n\\nvar body: some View {\\n    SwiftUIPlayer(\\n        flow: flow,\\n        plugins: [\\n          CommonExpressionsPlugin()\\n        ],\\n        result: $resultBinding\\n    )\\n}\\n","header":"Swift Usage","title":"Common Expressions"},"/plugins/common-expressions#general":{"path":"/plugins/common-expressions#general","content":"General\\n\\n","header":"General","title":"Common Expressions"},"/plugins/common-expressions#size":{"path":"/plugins/common-expressions#size","content":"size\\nGets the size of a value. This is the number of keys in an object, the length of a string, or the number of items in an array.\\n\\nfunction size(value: string | array | object): number\\n","header":"size","title":"Common Expressions"},"/plugins/common-expressions#length":{"path":"/plugins/common-expressions#length","content":"length\\nAlias for size\\n","header":"length","title":"Common Expressions"},"/plugins/common-expressions#concat":{"path":"/plugins/common-expressions#concat","content":"concat\\nConcatenates arrays together, or strings into 1 value\\n\\nfunction concat(...values: Array): Array\\n","header":"concat","title":"Common Expressions"},"/plugins/common-expressions#strings":{"path":"/plugins/common-expressions#strings","content":"Strings\\n\\n","header":"Strings","title":"Common Expressions"},"/plugins/common-expressions#trim":{"path":"/plugins/common-expressions#trim","content":"trim\\nTrims whitespace from the leading and trailing edges of a string\\n\\nfunction trim(value: string): string\\n","header":"trim","title":"Common Expressions"},"/plugins/common-expressions#uppercase":{"path":"/plugins/common-expressions#uppercase","content":"upperCase\\nTransforms the string to all uppercase.\\n\\nfunction upperCase(value: string): string\\n","header":"upperCase","title":"Common Expressions"},"/plugins/common-expressions#lowercase":{"path":"/plugins/common-expressions#lowercase","content":"lowerCase\\nTransforms the string to all lowercase.\\n\\nfunction lowerCase(value: string): string\\n","header":"lowerCase","title":"Common Expressions"},"/plugins/common-expressions#titlecase":{"path":"/plugins/common-expressions#titlecase","content":"titleCase\\nTransforms the string to title case. Each word is capitalized.\\n\\nfunction titleCase(value: string): string\\n","header":"titleCase","title":"Common Expressions"},"/plugins/common-expressions#sentencecase":{"path":"/plugins/common-expressions#sentencecase","content":"sentenceCase\\nTransforms the string to sentence case. The first word is capitalized.\\n\\nfunction sentenceCase(value: string): string\\n","header":"sentenceCase","title":"Common Expressions"},"/plugins/common-expressions#replace":{"path":"/plugins/common-expressions#replace","content":"replace\\nReplaces all instances of pattern in string with replacement. The pattern can also be a regex.\\n\\nfunction replace(value: string, pattern: string | RegExp, replacement: string): string\\n","header":"replace","title":"Common Expressions"},"/plugins/common-expressions#containsany":{"path":"/plugins/common-expressions#containsany","content":"containsAny\\nChecks if a given string contains any keywords present in the given array.\\n\\nfunction containsAny(value: string, keywords: Array): boolean\\n","header":"containsAny","title":"Common Expressions"},"/plugins/common-expressions#math":{"path":"/plugins/common-expressions#math","content":"Math\\n\\n","header":"Math","title":"Common Expressions"},"/plugins/common-expressions#number":{"path":"/plugins/common-expressions#number","content":"number\\nConverts the given value to a number if possible. Will handle removing currency modifiers and comma delimitated values.\\n\\nfunction number(value: string): number | undefined\\n","header":"number","title":"Common Expressions"},"/plugins/common-expressions#round":{"path":"/plugins/common-expressions#round","content":"round\\nRounds the given number to the nearest integer.\\n\\nfunction round(value: number): number\\n","header":"round","title":"Common Expressions"},"/plugins/common-expressions#floor":{"path":"/plugins/common-expressions#floor","content":"floor\\nRounds the number down the the nearest integer\\n\\nfunction floor(value: number): number\\n","header":"floor","title":"Common Expressions"},"/plugins/common-expressions#ceil":{"path":"/plugins/common-expressions#ceil","content":"ceil\\nRounds the number up the the nearest integer\\n\\nfunction ceil(value: number): number\\n","header":"ceil","title":"Common Expressions"},"/plugins/common-expressions#sum":{"path":"/plugins/common-expressions#sum","content":"sum\\nSums up all arguments\\n\\nfunction sum(...values: Array): number\\n","header":"sum","title":"Common Expressions"},"/plugins/common-expressions#objectsarrays":{"path":"/plugins/common-expressions#objectsarrays","content":"Objects/Arrays\\n\\n","header":"Objects/Arrays","title":"Common Expressions"},"/plugins/common-expressions#findpropertyindex":{"path":"/plugins/common-expressions#findpropertyindex","content":"findPropertyIndex\\nFinds the index of the item in the given array (or array reference). Returns -1 for indexes that aren\'t found\\n\\nfunction findPropertyIndex(binding: Binding | Array, searchProperty: string, searchValue: any): number\\n","header":"findPropertyIndex","title":"Common Expressions"},"/plugins/common-types":{"path":"/plugins/common-types","content":"\\n\\n","title":"Common Types"},"/plugins/common-types#common-types-plugin":{"path":"/plugins/common-types#common-types-plugin","content":"Common Types Plugin\\n\\nThis plugin exposes some basic DataTypes, validations, and formats into Player content.\\n\\nIt also serves as a good reference to adding your own custom types into Player.\\n","header":"Common Types Plugin","title":"Common Types"},"/plugins/common-types#usage":{"path":"/plugins/common-types#usage","content":"Usage\\n\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/common-types-plugin\\n\\nAdd it to Player:\\nimport CommonTypesPlugin from \'@player-ui/common-types-plugin\';\\n\\nconst commonTypesPlugin = new CommonTypesPlugin();\\nconst player = new Player({ plugins: [commonTypesPlugin] });\\n\\n// Start your flow\\nplayer.start(myFlow);\\n\\nThis will allow any DataTypes, formats, validations and custom data types to be used in the content\\n","header":"Usage","title":"Common Types"},"/plugins/common-types#cocoapods":{"path":"/plugins/common-types#cocoapods","content":"CocoaPods\\n\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/CommonTypesPlugin\'\\n","header":"CocoaPods","title":"Common Types"},"/plugins/common-types#swift-usage":{"path":"/plugins/common-types#swift-usage","content":"Swift Usage\\n\\nThis plugin takes no parameters, and the configuration comes from content, it can just be added to the plugin array:\\n\\nvar body: some View {\\n    SwiftUIPlayer(\\n        flow: flow,\\n        plugins: [\\n          CommonTypesPlugin()\\n        ],\\n        result: $resultBinding\\n    )\\n}\\n","header":"Swift Usage","title":"Common Types"},"/plugins/common-types#formats":{"path":"/plugins/common-types#formats","content":"Formats\\n\\n","header":"Formats","title":"Common Types"},"/plugins/common-types#commanumber":{"path":"/plugins/common-types#commanumber","content":"commaNumber\\n\\n\\nformat: Formats a number (or string containing only numbers) into a comma delineated string.\\ndeformat: Converts a comma delineated string into a number\\n\\nOptions:\\n\\n{\\n  precision?: number\\n}\\n","header":"commaNumber","title":"Common Types"},"/plugins/common-types#integer":{"path":"/plugins/common-types#integer","content":"integer\\n\\ndeformat: converts a string containing only integers to an integer\\n","header":"integer","title":"Common Types"},"/plugins/common-types#date":{"path":"/plugins/common-types#date","content":"date\\n\\nformat: Formats a string of numbers into a slash separated date\\n\\nOptions:\\n\\n{\\n  mask?: string\\n}\\n","header":"date","title":"Common Types"},"/plugins/common-types#currency":{"path":"/plugins/common-types#currency","content":"currency\\n\\nformat: Formats a number of string into a currency value\\ndeformat: Converts a currency value into a number\\n\\nOptions:\\n\\n{\\n  precision?: number;\\n  currencySymbol?: string;\\n  useParensForNeg?: boolean;\\n}\\n","header":"currency","title":"Common Types"},"/plugins/common-types#phone":{"path":"/plugins/common-types#phone","content":"phone\\n\\nformat: Formats the value as a phone number\\n\\nOptions:\\n\\n{\\n  mask?: string;\\n}\\n","header":"phone","title":"Common Types"},"/plugins/common-types#validations":{"path":"/plugins/common-types#validations","content":"Validations\\n\\n","header":"Validations","title":"Common Types"},"/plugins/common-types#required":{"path":"/plugins/common-types#required","content":"required\\nAsserts that a value is not null, undefined, or an empty string\\n\\nOptions:\\n{\\n  /* An expression to limit the assertion only if the expression evaluates to truthy */\\n  if?: Expression;\\n\\n  /* An expression to limit the assertion only if the expression evaluates to falsy */\\n  ifNot?: Expression;\\n}\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.required\\nmessage: \\"A value is required\\"\\n","header":"required","title":"Common Types"},"/plugins/common-types#expression":{"path":"/plugins/common-types#expression","content":"expression\\nUses an expression to evaluate the validation assertion\\n\\nOptions:\\n\\n{\\n  /* The expression to evaluate. If truthy, the value/validation passes. If falsy, it does not. */\\n  exp: Expression;\\n}\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.expression\\nmessage: \\"Expression evaluation failed\\"\\n","header":"expression","title":"Common Types"},"/plugins/common-types#readonly":{"path":"/plugins/common-types#readonly","content":"readonly\\nAsserts that the value cannot change\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.readonly\\nmessage: \\"Value cannot be modified\\"\\n","header":"readonly","title":"Common Types"},"/plugins/common-types#string":{"path":"/plugins/common-types#string","content":"string\\nAsserts that the value is a string\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.string\\nmessage: \\"Value must be a string\\"\\nparameters:\\n  type: the type of value being validated\\n","header":"string","title":"Common Types"},"/plugins/computed-properties":{"path":"/plugins/computed-properties","content":"\\n\\n","title":"Computed Properties"},"/plugins/computed-properties#computed-properties-plugin":{"path":"/plugins/computed-properties#computed-properties-plugin","content":"Computed Properties Plugin\\n\\nThis plugin allows users to specify a path in the data-model (binding) as a computed property in the schema.\\nAnytime this binding is read from, the given expression will be evaluated and returned instead of the it being read from the actual model. Writes to the binding will be prevented, and an error will be thrown.\\n","header":"Computed Properties Plugin","title":"Computed Properties"},"/plugins/computed-properties#usage":{"path":"/plugins/computed-properties#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ComputedPropertiesPlugin } from \'@player-ui/computed-properties-plugin\';\\n\\nconst player = new Player({\\n  plugins: [new ComputedPropertiesPlugin()],\\n});\\n","header":"Usage","title":"Computed Properties"},"/plugins/computed-properties#cocoapods":{"path":"/plugins/computed-properties#cocoapods","content":"CocoaPods\\n\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/ComputedPropertiesPlugin\'\\n","header":"CocoaPods","title":"Computed Properties"},"/plugins/computed-properties#swift-usage":{"path":"/plugins/computed-properties#swift-usage","content":"Swift Usage\\n\\nThis plugin takes no parameters, and the configuration comes from content, it can just be added to the plugin array:\\n\\nvar body: some View {\\n    SwiftUIPlayer(\\n        flow: flow,\\n        plugins: [\\n          ComputedPropertiesPlugin()\\n        ],\\n        result: $resultBinding\\n    )\\n}\\n","header":"Swift Usage","title":"Computed Properties"},"/plugins/computed-properties#expression-data-type":{"path":"/plugins/computed-properties#expression-data-type","content":"Expression Data Type\\n\\nThe computed properties plugin introspects the schema, looking for any DataType that uses the Expression:\\n\\n{\\n  \\"type\\": \\"Expression\\",\\n  \\"exp\\": \\"@[ someExpression() ]@\\"\\n}\\n\\nAny data-lookup for that binding path will evaluate the given expression and return that value. Results are not cached, and will be recomputed on every fetch.\\n","header":"Expression Data Type","title":"Computed Properties"},"/plugins/console-logger":{"path":"/plugins/console-logger","content":"\\n\\n","title":"Console Logger"},"/plugins/console-logger#console-logger-plugin":{"path":"/plugins/console-logger#console-logger-plugin","content":"Console Logger Plugin\\n\\nA plugin to easily enable logs to be written to the JS console. Extremely helpful for local Player development and debugging.\\n","header":"Console Logger Plugin","title":"Console Logger"},"/plugins/console-logger#usage":{"path":"/plugins/console-logger#usage","content":"Usage\\n\\n\\nInstall the plugin:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ConsoleLoggerPlugin } from \'@player-ui/console-logger-plugin\';\\n\\nconst consoleLogger = new ConsoleLoggerPlugin();\\n\\nconst player = new Player({\\n  plugins: [consoleLogger]\\n});\\n\\nTo change the severity:\\n\\nconsoleLogger.setSeverity(\'warn\');\\n","header":"Usage","title":"Console Logger"},"/plugins/console-logger#cocoapods":{"path":"/plugins/console-logger#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/PrintLoggerPlugin\'\\n","header":"CocoaPods","title":"Console Logger"},"/plugins/coroutines":{"path":"/plugins/coroutines","content":"\\n\\n","title":"Coroutines"},"/plugins/coroutines#kotlin-coroutines":{"path":"/plugins/coroutines#kotlin-coroutines","content":"Kotlin Coroutines\\n\\nKotlin coroutines is a popular Kotlin library to handle asynchronous programming and concurrency in the JVM. More information on Coroutines can be found here\\nThis module contains several JVM exclusive plugins to aid various tooling needs.\\n","header":"Kotlin Coroutines","title":"Coroutines"},"/plugins/coroutines#updatesplugin":{"path":"/plugins/coroutines#updatesplugin","content":"UpdatesPlugin\\n\\nPlugin using a ReceiveChannel to provide an updated asset whenever the Player View is updated.\\n","header":"UpdatesPlugin","title":"Coroutines"},"/plugins/coroutines#usage":{"path":"/plugins/coroutines#usage","content":"Usage\\n\\n\\nIn build.gradle\\n\\nimplementation \\"com.intuit.player.plugins:coroutines:$PLAYER_VERSION\\"\\n\\nIn Player constructor\\nimport com.intuit.player.plugins.coroutines.UpdatesPlugin\\n\\nval plugins = listOf(UpdatesPlugin())\\nAndroidPlayer(plugins)\\n","header":"Usage","title":"Coroutines"},"/plugins/coroutines#api":{"path":"/plugins/coroutines#api","content":"API\\n\\n\\nThe API for this plugin revolves around the ReceiveChannel for asset updates.\\nPublic API available from sources here:\\n\\nUpdatesPlugin\\n","header":"API","title":"Coroutines"},"/plugins/coroutines#flowscopeplugin":{"path":"/plugins/coroutines#flowscopeplugin","content":"FlowScopePlugin\\n\\nPlugin that provides a CoroutineScope that can be used to perform various async operations with the context of the current flow.\\nAll operations launched using the scope will be cancelled when player changes state.\\n","header":"FlowScopePlugin","title":"Coroutines"},"/plugins/data-change-listener":{"path":"/plugins/data-change-listener","content":"\\n\\n","title":"Data Change Listener"},"/plugins/data-change-listener#data-change-listener-plugin":{"path":"/plugins/data-change-listener#data-change-listener-plugin","content":"Data Change Listener Plugin\\n\\nThis plugin enables users to subscribe to data-change events within a view, and run expressions when the target value changes. Expressions are added to a listeners property of the view, with events prefixed by dataChange and the target binding:\\n\\n{\\n  \\"id\\": \\"example-view\\",\\n  \\"type\\": \\"info\\",\\n  \\"listeners\\": {\\n    \\"dataChange.foo.bar\\": \\"helloWorld()\\",\\n    \\"dataChange.foo.baz\\": [\\"helloWorld()\\", \\"doSomethingElseToo()\\"]\\n  }\\n}\\n","header":"Data Change Listener Plugin","title":"Data Change Listener"},"/plugins/data-change-listener#installation":{"path":"/plugins/data-change-listener#installation","content":"Installation\\n\\n\\nAdd it to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { DataChangePlugin } from \'@player-ui/data-change-plugin\';\\n\\nconst player = new Player({\\n  plugins: [new DataChangePlugin()]\\n});\\n","header":"Installation","title":"Data Change Listener"},"/plugins/data-change-listener#usage":{"path":"/plugins/data-change-listener#usage","content":"Usage\\n\\nThe format of dataChange. will execute the value (any valid expression or collection of expressions), anytime a value within the target binding\'s tree is updated (foo.bar and foo.baz in the example above).\\n\\nRegistrations can be made for any partial binding path, and will be evaluated anytime that path, or any child path, is mutated. The above example registration of dataChange.foo.bar will be triggered by a change to foo.bar, foo.bar.baz, or any other child path. (it will not be triggered by a change to foo.baz).\\n\\nThe subscriptions are tied to the lifecycle of the view they\'re defined in. They will not be called upon initial render of the view, and will expire when the view is no longer the active state (when transitioning to a new state in the flow).\\n","header":"Usage","title":"Data Change Listener"},"/plugins/data-filter":{"path":"/plugins/data-filter","content":"\\n\\n","title":"Data Filter"},"/plugins/data-filter#data-filter-plugin":{"path":"/plugins/data-filter#data-filter-plugin","content":"Data Filter Plugin\\n\\nThe data-filter-plugin enables users to filter out segments of the data-model during serialization.\\n","header":"Data Filter Plugin","title":"Data Filter"},"/plugins/expression":{"path":"/plugins/expression","content":"\\n\\n","title":"Expression"},"/plugins/expression#expression-plugin":{"path":"/plugins/expression#expression-plugin","content":"Expression Plugin\\n\\nThis plugin assists with exposing custom expressions to Player content.\\n","header":"Expression Plugin","title":"Expression"},"/plugins/expression#usage":{"path":"/plugins/expression#usage","content":"Usage\\n\\n\\nDefine handlers for the expressions you wish to add:\\n\\nimport { ExpressionHandler, ExpressionContext } from \'@player-ui/expression-plugin\';\\n\\nconst customExpressionHandler: ExpressionHandler = (ctx: ExpressionContext) => {\\n  return \'Hello World!\'\\n}\\n\\nRegister with Player. Subsequent registrations of an expression with the same name will override previous values.\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ExpressionPlugin } from \'@player-ui/expression-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new ExpressionPlugin([\\n      [\'myCustomFunction\', customExpressionHandler]\\n    ])\\n  ]\\n})\\n\\nAny calls to myCustomFunction() within the flow will utilize the newly registered expression:\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"sample\\",\\n    \\"type\\": \\"text\\",\\n    \\"value\\": \\"@[ myCustomFunction() ]@\\"\\n  }\\n}\\n","header":"Usage","title":"Expression"},"/plugins/expression#cocoapods":{"path":"/plugins/expression#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/ExpressionPlugin\'\\n","header":"CocoaPods","title":"Expression"},"/plugins/expression#swift-usage":{"path":"/plugins/expression#swift-usage","content":"Swift Usage\\n\\nThe ExpressionPlugin lets you register custom expressions to run native code:\\n\\n{\\n  \\"id\\": \\"textAsset\\",\\n  \\"type\\": \\"text\\",\\n  \\"value\\": \\"@[ myExpression() ]@\\"\\n}\\n\\nlet expressionPlugin = ExpressionPlugin(expressions: [\\n  \\"myExpression\\": { _ in\\n  \\t\\treturn \\"Some Value\\"\\n\\t}\\n])\\n","header":"Swift Usage","title":"Expression"},"/plugins/expression#arguments":{"path":"/plugins/expression#arguments","content":"Arguments\\n\\nArguments can be passed to custom expressions, and your handler receives the arguments as an array of Any:\\n\\n{\\n  \\"id\\": \\"textAsset\\",\\n  \\"type\\": \\"text\\",\\n  \\"value\\": \\"@[ myExpression(\'world\') ]@\\"\\n}\\n\\nlet expressionPlugin = ExpressionPlugin(expressions: [\\n  \\"myExpression\\": { (args: [Any]) -> Any? in\\n  \\t\\tguard let string = args.first as? String else { return nil }\\n  \\t\\treturn \\"Hello \\" + string\\n\\t}\\n])\\n\\nThe ExpressionPlugin enables consumers to register custom expressions in native JVM code. Simply supply a map of expression name to handler on instantiation, and the expressions will be available within the content. Handlers receive arguments are as a List and are permitted to return Any?.\\n","header":"Arguments","title":"Expression"},"/plugins/external-action-view-modifier":{"path":"/plugins/external-action-view-modifier","content":"\\n\\n","title":"External Action View Modifier"},"/plugins/external-action-view-modifier#external-action-view-modifier-plugin":{"path":"/plugins/external-action-view-modifier#external-action-view-modifier-plugin","content":"External Action View Modifier Plugin\\n\\nThis plugin is used to handle EXTERNAL states, allowing you to asynchronously tell Player when, and what to transition with once you have finished processing the external state request.\\n","header":"External Action View Modifier Plugin","title":"External Action View Modifier"},"/plugins/external-action-view-modifier#cocoapods":{"path":"/plugins/external-action-view-modifier#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/ExternalActionViewModifierPlugin\'\\n","header":"CocoaPods","title":"External Action View Modifier"},"/plugins/external-action-view-modifier#swift-usage":{"path":"/plugins/external-action-view-modifier#swift-usage","content":"Swift Usage\\n\\nFor an example flow with an external state such as:\\n\\n{\\n  \\"id\\": \\"test-flow\\",\\n  \\"data\\": {\\n    \\"transitionValue\\": \\"Next\\"\\n  },\\n  \\"navigation\\": {\\n    \\"BEGIN\\": \\"FLOW_1\\",\\n    \\"FLOW_1\\": {\\n      \\"startState\\": \\"EXT_1\\",\\n      \\"EXT_1\\": {\\n        \\"state_type\\": \\"EXTERNAL\\",\\n        \\"ref\\": \\"test-1\\",\\n        \\"transitions\\": {\\n          \\"Next\\": \\"END_FWD\\",\\n          \\"Prev\\": \\"END_BCK\\"\\n        },\\n        \\"extraProperty\\": \\"extraValue\\"\\n      },\\n      \\"END_FWD\\": {\\n        \\"state_type\\": \\"END\\",\\n        \\"outcome\\": \\"FWD\\"\\n      },\\n      \\"END_BCK\\": {\\n        \\"state_type\\": \\"END\\",\\n        \\"outcome\\": \\"BCK\\"\\n      }\\n    }\\n  }\\n}\\n\\nThe plugin can be declared to handle this external state by showing some user interface, and letting the user trigger the transition to the next state:\\n\\nlet plugin = ExternalActionViewModifierPlugin { state, options, transition in\\n\\t\\treturn AnyView(\\n      VStack {\\n        Text(\\"External State\\")\\n        Button(action: {transition(\\"Next\\")}) { Text(\\"Continue\\") }\\n      }\\n    )\\n}\\n\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      plugin\\n    ],\\n    result: $resultBinding\\n  )\\n}\\n","header":"Swift Usage","title":"External Action View Modifier"},"/plugins/external-action":{"path":"/plugins/external-action","content":"\\n\\n","title":"External Action"},"/plugins/external-action#external-action-plugin":{"path":"/plugins/external-action#external-action-plugin","content":"External Action Plugin\\n\\nThe External Action Plugin is an easy way to handle External states from the navigation of a Player flow.\\n","header":"External Action Plugin","title":"External Action"},"/plugins/external-action#usage":{"path":"/plugins/external-action#usage","content":"Usage\\n\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/external-action-plugin\\n\\nCreate a handler for external actions:\\n\\nimport { ExternalStateHandler } from \'@player-ui/external-action-plugin\';\\n\\nconst externalActionHandler: ExternalStateHandler = async (state, options) => {\\n  if (state.ref === \'custom\') {\\n    return \'next\';\\n  }\\n}\\n\\nAdd it to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ExternalActionPlugin } from \'@player-ui/external-action-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new ExternalActionPlugin(externalActionHandler)\\n  ]\\n})\\n\\nThis will transition any EXTERNAL state in Player\'s navigation, with a ref property of custom using the next transition.\\n","header":"Usage","title":"External Action"},"/plugins/external-action#cocoapods":{"path":"/plugins/external-action#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/ExternalActionPlugin\'\\n","header":"CocoaPods","title":"External Action"},"/plugins/external-action#swift-usage":{"path":"/plugins/external-action#swift-usage","content":"Swift Usage\\n\\nFor an example flow with an external state such as:\\n\\n{\\n  \\"id\\": \\"test-flow\\",\\n  \\"data\\": {\\n    \\"transitionValue\\": \\"Next\\"\\n  },\\n  \\"navigation\\": {\\n    \\"BEGIN\\": \\"FLOW_1\\",\\n    \\"FLOW_1\\": {\\n      \\"startState\\": \\"EXT_1\\",\\n      \\"EXT_1\\": {\\n        \\"state_type\\": \\"EXTERNAL\\",\\n        \\"ref\\": \\"test-1\\",\\n        \\"transitions\\": {\\n          \\"Next\\": \\"END_FWD\\",\\n          \\"Prev\\": \\"END_BCK\\"\\n        },\\n        \\"extraProperty\\": \\"extraValue\\"\\n      },\\n      \\"END_FWD\\": {\\n        \\"state_type\\": \\"END\\",\\n        \\"outcome\\": \\"FWD\\"\\n      },\\n      \\"END_BCK\\": {\\n        \\"state_type\\": \\"END\\",\\n        \\"outcome\\": \\"BCK\\"\\n      }\\n    }\\n  }\\n}\\n\\nThe plugin can be declared to handle this external state, whether that means integrating an existing platform native experience, or doing headless processing:\\n\\nlet plugin = ExternalActionPlugin { state, options, transition in\\n\\t\\tguard state.ref == \\"test-1\\" else { return transition(\\"Prev\\") }\\n\\t\\t// Options contains the dataModel as well as an evaluate function for expressions\\n\\t\\tlet transitionValue = options.data.get(binding: \\"transitionValue\\") as? String\\n\\t\\toptions.expression.evaluate(\\"{{foo}} = \'bar\'\\")\\n\\n\\t\\tlet extraProperty: String? = state.extraProperty // uses @dynamicMemberLookup\\n\\t\\t// Do some processing\\n\\t\\ttransition(transitionValue ?? \\"Next\\")\\n}\\n\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      plugin\\n    ],\\n    result: $resultBinding\\n  )\\n}\\n\\nThe ExternalActionPlugin adds support for handling EXTERNAL navigation states in the application. The handler, which can be provided during plugin initialization, receives three parameters:\\n\\nstate: NavigationFlowExternalState provides access to the information defined in the EXTERNAL state node\\noptions: ControllerState provides access to the current player controllers\\ntransition: (String) -> Unit is provided to enable the handler to \\"complete\\" the EXTERNAL state and transition using the provided String value\\n","header":"Swift Usage","title":"External Action"},"/plugins":{"path":"/plugins","content":"\\n\\n","title":"Plugins"},"/plugins/markdown":{"path":"/plugins/markdown","content":"\\n\\n","title":"Markdown"},"/plugins/markdown#markdown-plugin":{"path":"/plugins/markdown#markdown-plugin","content":"Markdown Plugin\\n\\nThe markdown-plugin adds support for parsing markdown content to Player Assets. This plugin is asset set agnostic, so it expects a mappers record to inform how to transform markdown content into valid Player Content with support from your asset set.\\n","header":"Markdown Plugin","title":"Markdown"},"/plugins/markdown#usage":{"path":"/plugins/markdown#usage","content":"Usage\\n\\n","header":"Usage","title":"Markdown"},"/plugins/markdown#defining-the-mappers":{"path":"/plugins/markdown#defining-the-mappers","content":"Defining The Mappers\\n\\nimport type { Mappers } from \'@player-ui/markdown-plugin\';\\n\\nexport const mappers: Mappers = {\\n  text: ({ originalAsset, value }) => ({\\n    id: ${originalAsset.id}-text,\\n    type: \'text\',\\n    value,\\n  }),\\n  image: ({ originalAsset, value, src }) => ({\\n    id: ${originalAsset.id}-image,\\n    type: \'image\',\\n    accessibility: value,\\n    metaData: {\\n      ref: src,\\n    },\\n  }),\\n  //...\\n};\\n","header":"Defining The Mappers","title":"Markdown"},"/plugins/meta":{"path":"/plugins/meta","content":"\\n\\n","title":"Meta"},"/plugins/meta#meta-plugin":{"path":"/plugins/meta#meta-plugin","content":"Meta Plugin\\n\\nThe Meta Plugin is an easy way to combine multiple other plugins into 1 group. It is often used when sharing a set of plugins across platforms (each platform registering 1 common set of core plugins).\\n","header":"Meta Plugin","title":"Meta"},"/plugins/metrics":{"path":"/plugins/metrics","content":"\\n\\n","title":"Metrics"},"/plugins/metrics#metrics-plugin":{"path":"/plugins/metrics#metrics-plugin","content":"Metrics Plugin\\n\\nThe Metrics Plugin is used to gather timing information about Player\'s execution of a flow. There are also platform specific integrations to include render and update times.\\n\\nThe diagram below illistrates some of the timing information gathered:\\n\\nMetrics Timing Diagram\\n","header":"Metrics Plugin","title":"Metrics"},"/plugins/metrics#usage":{"path":"/plugins/metrics#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { MetricsPlugin } from \'@player-ui/metrics-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new MetricsPlugin({\\n      onUpdate: (metrics) => {\\n        // Handle the update\\n      }\\n    })\\n  ]\\n})\\n\\nThe onUpdate callback will be invoked for any update to the metrics. There are also callbacks for finer-grained events (onRenderEnd, onInteractive, etc), as well as a hooks based API for even more control.\\n","header":"Usage","title":"Metrics"},"/plugins/metrics#using-a-custom-timer":{"path":"/plugins/metrics#using-a-custom-timer","content":"Using a custom timer\\n\\nBy default, all time is measured in ms using performance.now() with a fallback to the less-accurate Date.now().\\nIf you wish to supply your own timer, simply use the getTime option to set the function to use.\\n","header":"Using a custom timer","title":"Metrics"},"/plugins/metrics#measuring-render-time":{"path":"/plugins/metrics#measuring-render-time","content":"Measuring Render Time\\n\\nFor extensions of this plugin that wish to track the render (and update) times of nodes, add the trackRenderTime flag to options. You must then call metrics.renderEnd() to denote when content is painted on the screen. This is automatically handled for the platform specific versions of this plugin.\\n\\nThe react version of the Metrics Plugin adds support for render and update times to events. The API mirrors that of the core version:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { MetricsPlugin } from \'@player-ui/metrics-plugin-react\';\\n\\nconst player = new ReactPlayer({\\n  plugins: [\\n    new MetricsPlugin({\\n      onUpdate: (metrics) => {\\n        // Handle the update\\n      }\\n    })\\n  ]\\n})\\n\\nThe ios version of the Metrics Plugin will track initial render time for each view in a flow. Due to current SwiftUI limitations, update time can\'t be tracked yet. It can be used in conjunction with a core plugin that utilizes the events, through findPlugin, or standalone.\\n","header":"Measuring Render Time","title":"Metrics"},"/plugins/metrics#cocoapods":{"path":"/plugins/metrics#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/MetricsPlugin\'\\n","header":"CocoaPods","title":"Metrics"},"/plugins/metrics#swift-usage":{"path":"/plugins/metrics#swift-usage","content":"Swift Usage\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      // Tracking render time can be controlled with a parameter\\n      MetricsPlugin(trackRenderTime: true) { timing, nodeMetrics, flowMetrics in\\n        // Handle metrics payload\\n        log(timing.duration ?? -1)\\n      }\\n    ],\\n    result: $resultBinding\\n  )\\n}\\n\\nThe JVM Metrics plugin can track render time for views in a flow.\\n\\nIn build.gradle\\nimplementation \\"com.intuit.player.plugins:metrics:$PLAYER_VERSION\\"\\n\\nIn Player constructor\\nimport com.intuit.player.plugins.expression.ExpressionPlugin\\n\\nval metricsPlugin = MetricsPlugin { timing, renderMetrics, flowMetrics ->\\n  ...\\n}\\nAndroidPlayer(metricsPlugin)\\n","header":"Swift Usage","title":"Metrics"},"/plugins/partial-match-fingerprint":{"path":"/plugins/partial-match-fingerprint","content":"\\n\\n","title":"Partial Match"},"/plugins/partial-match-fingerprint#partial-match-plugin":{"path":"/plugins/partial-match-fingerprint#partial-match-plugin","content":"Partial Match Plugin\\n\\nThis plugin enables users to map matches of assets to any arbitrary value in a partial-match-registry.\\nFor each asset in a resolved view, the matches will be computed.\\n","header":"Partial Match Plugin","title":"Partial Match"},"/plugins/partial-match-fingerprint#usage":{"path":"/plugins/partial-match-fingerprint#usage","content":"Usage\\n\\n\\nCreate a registry and add matches:\\n\\nimport { Registry } from \'@player-ui/partial-match-registry\';\\n\\nconst registry = new Registry([\\n  [{ type: \'action\' }, \'ABC\']\\n])\\n\\nAdd the registy to a plugin:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { PartialMatchFingerprintPlugin } from \'@player-ui/partial-match-fingerprint-plugin\';\\n\\nconst matchPlugin = new PartialMatchFingerprintPlugin(registry);\\n\\nconst player = new Player({\\n  plugins: [matchPlugin]\\n})\\n\\nQuery the plugin for matches:\\n\\nconst value = matchPlugin.get(\'asset-id\') // \'ABC\'\\n\\nThis plugin is used by BaseAssetRegistry to handle matching resolved asset nodes with their native implementation, to decode for rendering. It is unlikely to be needed to be used directly in iOS use cases.\\n","header":"Usage","title":"Partial Match"},"/plugins/partial-match-fingerprint#cocoapods":{"path":"/plugins/partial-match-fingerprint#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI\'\\n","header":"CocoaPods","title":"Partial Match"},"/plugins/pub-sub":{"path":"/plugins/pub-sub","content":"\\n\\n","title":"PubSub"},"/plugins/pub-sub#pubsub-plugin":{"path":"/plugins/pub-sub#pubsub-plugin","content":"PubSub Plugin\\n\\nThe PubSub plugin adds a publish/subscribe interface between the host app and Player\'s content.\\n","header":"PubSub Plugin","title":"PubSub"},"/plugins/pub-sub#usage":{"path":"/plugins/pub-sub#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { PubSubPlugin } from \'@player-ui/pub-sub-plugin\';\\n\\nconst pubsub = new PubSubPlugin();\\n\\nconst token = pubsub.subscribe(\'some-event\', () => {\\n  // Callback\\n});\\n\\nconst player = new Player({\\n  plugins: [pubsub]\\n})\\n\\nTo unsubscribe:\\n\\npubsub.unsubscribe(token);\\n\\nIf your content uses the @[ publish() ]@ expression for actions, you can subscribe to these events by using the PubSubPlugin.\\n","header":"Usage","title":"PubSub"},"/plugins/pub-sub#cocoapods":{"path":"/plugins/pub-sub#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/PubSubPlugin\'\\n","header":"CocoaPods","title":"PubSub"},"/plugins/pub-sub#swift-usage":{"path":"/plugins/pub-sub#swift-usage","content":"Swift Usage\\nlet eventHandler: (String, AnyType?) -> Void = { (eventName, eventData) in\\n  // Handle event\\n}\\nlet plugin = PubSubPlugin([(\\"eventName\\", eventHandler)])\\n\\nIf your content uses a different name for publishing (such as publishEvent) you can customize the expression name that the plugin uses:\\n\\nlet plugin = PubSubPlugin([(\\"eventName\\", eventHandler)], options: PubSubPluginOptions(expressionName: \\"publishEvent\\"))\\n\\nThen, just include it in your plugins to a Player instance:\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      plugin\\n    ],\\n    result: $resultBinding\\n  )\\n}\\n\\nNote: AnyType is a custom enum type to handle the arbitrary types that can be received from these events, as the data is set in your Player Content, ensure that it matches either String, [String], or [String: String].\\n\\nThe PubSubPlugin provides support for handling the publish expressions in Player content at the app level. The PubSubPlugin is included by default in the Android Player, so configuring events subscriptions can be done on Player using the provided extension methods.\\n\\n{\\n  \\"id\\": \\"action\\",\\n  \\"type\\": \\"action\\",\\n  \\"exp\\": \\"@[ publish(\'some-event\', {{foo.bar}}) ]@\\"\\n}\\nval player = AndroidPlayer(context)\\n\\n// extension method for subscribing to some event\\nval token = player.subscribe(\\"some-event\\") { name: String, data: Any? ->\\n    // name of event can be used for logging\\n    // data can be any structure passed by the content, if any\\n    // handle event\\n}\\n\\n// extension method for removing a specific event subscription\\nplayer.unsubscribe(token)\\n","header":"Swift Usage","title":"PubSub"},"/plugins/set-timeout":{"path":"/plugins/set-timeout","content":"\\n\\n","title":"SetTimeout Plugin"},"/plugins/set-timeout#settimeout-plugin":{"path":"/plugins/set-timeout#settimeout-plugin","content":"setTimeout Plugin\\n\\nThe only explicit runtime plugin in the core Android plugin set, the SetTimeoutPlugin is a RuntimePlugin written to provide the global setTimeout method to the runtime.\\n","header":"setTimeout Plugin","title":"SetTimeout Plugin"},"/plugins/shared-constants":{"path":"/plugins/shared-constants","content":"\\n\\n","title":"Shared Constants"},"/plugins/shared-constants#shared-constants-plugin":{"path":"/plugins/shared-constants#shared-constants-plugin","content":"Shared Constants Plugin\\n\\nThe Shared Constants Plugin enables users to define and override commonly used static values. It can be leveraged by other plugins to enable localization.\\n","header":"Shared Constants Plugin","title":"Shared Constants"},"/plugins/shared-constants#usage":{"path":"/plugins/shared-constants#usage","content":"Usage\\n\\n\\nCreate the plugin and add it to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ConstantsPlugin } from \'@player-ui/shared-constants-plugin\';\\n\\nconst constantsPlugin = new ConstantsPlugin({\\n  data: {\\n    prop1: \'A\',\\n    prop2: \'B\'\\n  },\\n  namespace: \'constants\',\\n  dataPath: \'data.constants\'\\n});\\n\\nconst player = new Player({\\n  plugins: [ constantsPlugin ]\\n});\\n\\nYou can then query the plugin to get the value of a particular key:\\n\\nconstantsPlugin.getConstants(\'prop1\') // \'A\'\\n","header":"Usage","title":"Shared Constants"},"/plugins/shared-constants#overriding-values-in-content":{"path":"/plugins/shared-constants#overriding-values-in-content","content":"Overriding Values in Content\\n\\nThe dataPath configuration option enables content to override specific values for a particular flow:\\n\\n{\\n  \\"data\\": {\\n    \\"constants\\": {\\n      \\"prop1\\": \\"B\\"\\n    }\\n  }\\n}\\n\\nusing a similar query for prop1, the value in the content takes precidence and would return B.\\n","header":"Overriding Values in Content","title":"Shared Constants"},"/plugins/shared-constants#fallback-values":{"path":"/plugins/shared-constants#fallback-values","content":"Fallback Values\\n\\nAny query can also specify an optional default value to return:\\n\\nconstantsPlugin.getConstants(\'prop3\', \'default value\') // \'default value\'\\n","header":"Fallback Values","title":"Shared Constants"},"/plugins/shared-constants#examples":{"path":"/plugins/shared-constants#examples","content":"Examples\\n\\n","header":"Examples","title":"Shared Constants"},"/plugins/stage-revert-data":{"path":"/plugins/stage-revert-data","content":"\\n\\n","title":"Stage Revert Data"},"/plugins/stage-revert-data#stage-revert-data-plugin":{"path":"/plugins/stage-revert-data#stage-revert-data-plugin","content":"Stage Revert Data Plugin\\n\\nThis plugin enables users to temporarily stage data changes before committing to the actual data model\\n\\nA stageData property flag inside of the view properties must be added on the desired view configs.\\n\\n{\\n  \\"VIEW_1\\": {\\n    \\"state_type\\": \\"VIEW\\",\\n    \\"ref\\": \\"view-1\\",\\n    \\"attributes\\": {\\n      \\"stageData\\": true,\\n      \\"commitTransitions\\": [\\"VIEW_2\\"]\\n    },\\n    \\"transitions\\": {\\n      \\"next\\": \\"VIEW_2\\",\\n      \\"*\\": \\"ACTION_1\\"\\n    }\\n  }\\n}\\n\\nIt also should include a list of acceptable commitTransitions valid VIEW name for the data to be committed when the transition occurs, A not included commit transition would trigger the staged data to be cleared. An acceptable transition will commit the data into the data model. e.g. as per the previous example transitioning to VIEW_2 will trigger the staged data to get committed in the model, since the next transition property is pointing to it and is listed on the commitTransitions array parameter, otherwise it would get thrown away.\\n","header":"Stage Revert Data Plugin","title":"Stage Revert Data"},"/plugins/stage-revert-data#example":{"path":"/plugins/stage-revert-data#example","content":"Example\\n\\n\\nSimply add the plugin to the config when constructing a player instance.\\n\\nimport StageRevertPlugin from \'@player/stage-revert-data\';\\n\\nconst player = new Player({\\n  plugins: [new StageRevertPlugin()],\\n});\\n","header":"Example","title":"Stage Revert Data"},"/plugins/stage-revert-data#cocoapods":{"path":"/plugins/stage-revert-data#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/StageRevertDataPlugin\'\\n","header":"CocoaPods","title":"Stage Revert Data"},"/plugins/transition":{"path":"/plugins/transition","content":"\\n\\n","title":"Transition Plugin"},"/plugins/transition#transition-plugin":{"path":"/plugins/transition#transition-plugin","content":"Transition Plugin\\n\\nThe TransitionPlugin allows for specifying transitions for when Player loads a flow, and for transition between views in the same flow.\\n","header":"Transition Plugin","title":"Transition Plugin"},"/plugins/transition#cocoapods":{"path":"/plugins/transition#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/TransitionPlugin\'\\n","header":"CocoaPods","title":"Transition Plugin"},"/plugins/transition#swift-usage":{"path":"/plugins/transition#swift-usage","content":"Swift Usage\\nSwiftUIPlayer(flow: flowString, plugins: [TransitionPlugin(popTransition: .pop)], result: $resultBinding)\\n","header":"Swift Usage","title":"Transition Plugin"},"/plugins/transition#customizing-transitions":{"path":"/plugins/transition#customizing-transitions","content":"Customizing Transitions\\n\\nTo specify different transition, just supply a PlayerViewTransition to the plugin initializer:\\n\\nlet customTransition = PlayerViewTransition(\\n  transition: AnyTransition.opacity,\\n  animationCurve: Animation.linear\\n)\\nlet plugin = TransitionPlugin(\\n  stateTransition: customTransition,\\n  pushTransition: customTransition,\\n  popTransition: customTransition\\n)\\n","header":"Customizing Transitions","title":"Transition Plugin"},"/plugins/swiftui-pending-transaction":{"path":"/plugins/swiftui-pending-transaction","content":"\\n\\n","title":"SwiftUIPendingTransactionPlugin"},"/plugins/swiftui-pending-transaction#swiftuipendingtransactionplugin":{"path":"/plugins/swiftui-pending-transaction#swiftuipendingtransactionplugin","content":"SwiftUIPendingTransactionPlugin\\n\\nThe SwiftUIPendingTransactionPlugin allows you to register pending transactions (callbacks) in the userInfo on the decoder. Users can decide when to register, commit and clear transactions based on the use case. Anytime there is a scenario where we want a native transaction to happen while a view update is taking place, we can make use of this plugin. Below is an example used in the sample app where we can see this take place:\\n","header":"SwiftUIPendingTransactionPlugin","title":"SwiftUIPendingTransactionPlugin"},"/plugins/swiftui-pending-transaction#cocoapods":{"path":"/plugins/swiftui-pending-transaction#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/SwiftUIPendingTransactionPlugin\'\\n","header":"CocoaPods","title":"SwiftUIPendingTransactionPlugin"},"/plugins/swiftui-pending-transaction#the-issue":{"path":"/plugins/swiftui-pending-transaction#the-issue","content":"The Issue:\\n\\nWhen you enter text on input and then click on an action to try to navigate (which triggers a view update), the text gets wiped out and only saves you hit enter or click on another input field.\\n","header":"The Issue:","title":"SwiftUIPendingTransactionPlugin"},"/plugins/types-provider":{"path":"/plugins/types-provider","content":"\\n\\n","title":"Types Provider"},"/plugins/types-provider#types-provider-plugin":{"path":"/plugins/types-provider#types-provider-plugin","content":"Types Provider Plugin\\n\\nSimilar to the Expression Plugin, this plugin adds support for easily exposing new DataTypes, formats, and validations to Player\'s content.\\n","header":"Types Provider Plugin","title":"Types Provider"},"/plugins/types-provider#example":{"path":"/plugins/types-provider#example","content":"Example\\n\\n\\nDefine a new validation type:\\n\\nimport { ValidatorFunction } from \'@player-ui/player\';\\n\\nconst customValidator: ValidatorFunction = (context, value) => {\\n  if (value === \'bad-value\') {\\n    return {\\n      message: \\"This is a bad value.\\"\\n    }\\n  }\\n}\\n\\nCreate a new DataType that references it:\\n\\nimport { Schema } from \'@player-ui/player\';\\n\\nconst CustomDataType: Schema.DataType = {\\n  name: \'CustomType\',\\n  validation: [\\n    {\\n      type: \\"custom-validator\\"\\n    }\\n  ]\\n}\\n\\nRegister it with Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { TypesProviderPlugin } from \'@player-ui/types-provider-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new TypesProviderPlugin({\\n      types: [CustomDataType],\\n      validations: [\\n        [\'custom-validator\', customValidator]\\n      ]\\n    })\\n  ]\\n});\\n\\nGiven a data-type reference to CustomType in the content, your new validation will be used:\\n\\n{\\n  \\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"data\\": {\\n        \\"type\\": \\"CustomDataType\\"\\n      }\\n    }\\n  }\\n}\\n\\nThe swift TypesProviderPlugin enables adding custom data types, formatters and validation purely through swift code. While in general, the recommendation would be to share a single JavaScript implementation to multiple platforms, some use cases may need a native integration.\\n","header":"Example","title":"Types Provider"},"/plugins/types-provider#cocoapods":{"path":"/plugins/types-provider#cocoapods","content":"CocoaPods\\nAdd the subspec to your Podfile\\n\\npod \'PlayerUI/TypesProviderPlugin\'\\n","header":"CocoaPods","title":"Types Provider"},"/plugins/types-provider#swift-usage":{"path":"/plugins/types-provider#swift-usage","content":"Swift Usage\\n\\n","header":"Swift Usage","title":"Types Provider"},"/plugins/types-provider#custom-validator":{"path":"/plugins/types-provider#custom-validator","content":"Custom Validator\\n\\nlet validationFunction = { context, value, options in\\n    if value == goodValue {\\n      return nil // Return nil to pass the validation\\n    } else {\\n      return [\\"message\\": \\"This Value is bad!\\"]\\n    }\\n}\\n\\nlet validator = ValidationDeclaration(\\n  type: \\"customValidator\\",\\n  handler: validationFunction\\n)\\n\\nlet plugin = TypesProviderPlugin(types: [], validators: [validator], formats: [])\\n\\nthen in the JSON schema for your type:\'\'\\n\\n\\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"\\": {\\n        \\"validation\\": [\\n            {\\"type\\": \\"customValidator\\"}\\n        ]\\n      }\\n    }\\n  }\\n","header":"Custom Validator","title":"Types Provider"},"/plugins/types-provider#custom-formatter":{"path":"/plugins/types-provider#custom-formatter","content":"Custom Formatter\\n\\nlet formatFunction = {value, options in\\n  if let stringValue = value as? String {\\n    return stringValue.replacingOccurrences(of: \\".\\", with: \\",\\") // Turn all periods into commas\\n  } else {\\n  \\treturn value\\n  }\\n}\\n\\nlet formatter = FormatDeclaration(\\n  name: \\"customFormatter\\",\\n  format: formatFunction,\\n  deformat: nil\\n)\\nlet plugin = TypesProviderPlugin(types: [], validators: [], formats: [formatter])\\n\\nthen in the JSON schema for your type:\\n\\n\\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"\\": {\\n          \\"format\\": {\\n              \\"type\\": \\"customFormatter\\"\\n          }\\n      }\\n    }\\n  }\\n","header":"Custom Formatter","title":"Types Provider"},"/plugins/types-provider#formatting-options":{"path":"/plugins/types-provider#formatting-options","content":"Formatting Options\\n\\nThe second parameter passed to the format/deformat functions is for additional options, it is of type [String: Any] and contains any other keys that were passed alongside the type of the formatter:\\n\\n\\"format\\": {\\n  \\"type\\": \\"customFormatter\\",\\n  \\"character\\": \\"X\\"\\n}\\n\\nlet formatFunction = {value, options in\\n  if let stringValue = value as? String {\\n    let char = options[\\"character\\"] as? String ?? \\",\\"\\n    return stringValue.replacingOccurrences(of: \\".\\", with: char)\\n    // Turn all periods into the specified character\\n  } else {\\n  \\treturn value\\n  }\\n}\\n","header":"Formatting Options","title":"Types Provider"},"/plugins/types-provider#custom-types":{"path":"/plugins/types-provider#custom-types","content":"Custom Types\\n\\nJust as you can define custom formats and validation, you can define a custom type that encapsulates that functionality into a type, to avoid the need to keep specifying options, this is how the common-types are defined, so when you choose a type like DateType the formatting is already set up.\\n\\nlet type = CustomType(\\n  type: \\"CustomType\\",\\n  validation: [\\n    ValidationReference(type: \\"customValidator\\")\\n  ],\\n  format: FormatReference(type: \\"customFormatter\\")\\n)\\n\\n// Construct the plugin\\nlet plugin = TypesProviderPlugin(types: [type], validators: [validator], formats: [formatter])\\n\\nthen in your JSON schema:\\n\\n\\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"foo\\": {\\n        \\"type\\": \\"CustomType\\"\\n      }\\n    }\\n  }\\n","header":"Custom Types","title":"Types Provider"},"/tools/cli":{"path":"/tools/cli","content":"\\n\\n","title":"CLI"},"/tools/cli#cli":{"path":"/tools/cli#cli","content":"CLI\\n\\nThe CLI package is a simple way for users to interact with some of the build/validation tooling. As new capabilities are added to the ecosystem, they may be exposed via this cli to use of use for developers.\\n","header":"CLI","title":"CLI"},"/tools/cli#config":{"path":"/tools/cli#config","content":"Config\\n\\nConfig files are able to customize the behavior of the CLI commands without requiring args. Behavior specific to execution can leverage plugins, which can be composed together using presets. Full configs can also be shared using extensions.\\n\\nTo resolve a full configuration, the extension is taken as the base, the presets are applied in order, then local plugins.\\nThe format is similar to eslint, babel and other .rc/json/js based approaches.\\n\\nConfig files are searched using cosmiconfig, which will look for:\\n\\na player property in package.json\\na .playerrc file in JSON or YAML format\\na .player.json, .playerrc.yaml, .playerrc.yml, .playerrc.js, or .playerrc.cjs file\\na player.config.js or player.config.cjs CommonJS module exporting an object\\n\\nExample:\\n\\nmodule.exports = {\\n  extends: \'@my-scope/base\',\\n  plugins: [\\n    \'plugin-npm-package\',\\n    [\'some-plugin-with-config\', { config: true }],\\n    {\\n      // Plugins can also be defined inline\\n      handler: () => {},\\n    },\\n  ],\\n};\\n\\nOptions defined via the CLI arguments will take precedence over the config files (for things that overlap).\\n","header":"Config","title":"CLI"},"/tools/cli#plugins":{"path":"/tools/cli#plugins","content":"Plugins\\n\\nPlugins are the way to change runtime behavior of the CLI actions. This includes augmenting the behavior of the DSL compiler, language-service, and more.\\n","header":"Plugins","title":"CLI"},"/tools/storybook":{"path":"/tools/storybook","content":"\\n\\n","title":"Player + Storybook Integration"},"/tools/storybook#reference-assets":{"path":"/tools/storybook#reference-assets","content":"Reference Assets\\n\\nThe reference asset set, complete with the storybook-plugin integration below is available here\\n","header":"Reference Assets","title":"Player + Storybook Integration"},"/tools/storybook#storybook-plugin":{"path":"/tools/storybook#storybook-plugin","content":"Storybook Plugin\\n\\nThe @player-ui/storybook package is a storybook addon + wrapper that provides easy-to-use mechanisms for integrating Player flows into storybook.\\n","header":"Storybook Plugin","title":"Player + Storybook Integration"},"/tools/storybook#installation":{"path":"/tools/storybook#installation","content":"Installation\\n\\nThere are a few different parts required to integrate with storybook.\\n\\nStart by installing @player-ui/storybook:\\n\\nyarn add @player-ui/storybook\\n\\nNext, add @player-ui/storybook to the addons section in .storybook/main.js\\n\\nmodule.exports = {\\n  addons: [\\n    \'@player-ui/storybook\'\\n  ]\\n}\\n\\nIn .storybook/preview.js add the PlayerDecorator:\\n\\nimport { PlayerDecorator } from \'@player-ui/storybook\';\\n\\nexport const decorators = [\\n  PlayerDecorator\\n];\\n\\nLastly use the PlayerStory component to render a flow:\\n\\nimport { PlayerStory } from \'@player-ui/storybook\';\\n\\nexport const MyStory = (\\n\\n)\\n\\nThe reactPlayerPlugins story parameter allows you to add any custom plugins (like asset providers) to a story. This can also be set in the .storybook/preview.js file as a global option:\\n\\nimport { ReferenceAssetsPlugin } from \'@player-ui/reference-assets-plugin-react\';\\n\\nexport const parameters = {\\n  reactPlayerPlugins: [\\n    new ReferenceAssetsPlugin()\\n  ],\\n}\\n","header":"Installation","title":"Player + Storybook Integration"},"/tools/storybook#panels":{"path":"/tools/storybook#panels","content":"Panels\\n\\n","header":"Panels","title":"Player + Storybook Integration"},"/tools/storybook#events":{"path":"/tools/storybook#events","content":"Events\\n\\nThe events panel addon shows a timeline of events as the flow is processed. Here you will see logs, render/update metrics, data mutations, and more.\\n\\nEvents Addon Panel\\n","header":"Events","title":"Player + Storybook Integration"},"/tools/storybook#flow":{"path":"/tools/storybook#flow","content":"Flow\\n\\nThe flow panel addon enables users to view and edit the JSON content in the running Player.\\n\\nFlow Addon Panel\\n","header":"Flow","title":"Player + Storybook Integration"},"/xlr/concepts":{"path":"/xlr/concepts","content":"\\n\\n","title":"XLR Concepts"},"/xlr/concepts#xlr-definitions":{"path":"/xlr/concepts#xlr-definitions","content":"XLR Definitions\\n\\nWhen talking about anything its helpful to make sure everyone is on the same page, XLR is no exception. In this section we\'ll explore some concepts related to XLRs, how they work, and how they\'re used.\\n","header":"XLR Definitions","title":"XLR Concepts"},"/xlr/concepts#capability":{"path":"/xlr/concepts#capability","content":"Capability\\n\\nWhen we talk about a Capability, we are essentially talking about what it provides to Player. Most, if not all, capabilities are provided by Plugins. Capabilities are described in the manifest file in the xlr folder of a distribution. The manifest file, provided as both a .json and a .js file for static or dynamic use, contains the mapping of capabilities to a list of the XLRs.\\n","header":"Capability","title":"XLR Concepts"},"/xlr/concepts#xlr-objects":{"path":"/xlr/concepts#xlr-objects","content":"XLR Objects\\n\\nXLRs contain all of the information about a TypeScript type or interface. For an interface it will have the information on what parameters it has, the types of those parameters, and if those parameters are optional. For a type, it will similarly describe the properties/types that compose it. There is no distinction in XLR on whether the XLR came from a type or an interface as everything is just represented by a Node.\\n","header":"XLR Objects","title":"XLR Concepts"},"/xlr/concepts#xlr-nodes":{"path":"/xlr/concepts#xlr-nodes","content":"XLR Nodes\\nXLR nodes are similar to TypeScripts internal AST nodes but a bit simpler. Almost every type/language feature you would use in TypeScript has an equivalent XLR node type. The definitions for these types are available in the @player-tools/xlr package.\\n","header":"XLR Nodes","title":"XLR Concepts"},"/xlr/concepts#named-types":{"path":"/xlr/concepts#named-types","content":"Named Types\\n\\nNamed Types represent a top level interface/type and can be any XLR Node. Named types are generated from interfaces/types that are exported from a source file or plugin. It should be noted that when generating a Named Type, all referenced types are also serialized and included in place in the Named Type and not exported separately. That is unless The type is listed as a Custom Primitive. A reason to do this would be if that type definition changes based on use case or platform. For example, in the Player ecosystem Asset is considered a Custom Primitive because depending on the context, we might need to swap it out with a different type.\\n","header":"Named Types","title":"XLR Concepts"},"/xlr/concepts#xlr-sdk":{"path":"/xlr/concepts#xlr-sdk","content":"XLR SDK\\n\\nThe XLR SDK is used to abstract away the more tedious interactions XLRs like loading them from their package, managing them when they\'re loaded, and validating content against them. The SDK does include an simple object store so that it can be used out of the box, however if your use case requires some different logic it can be extended quite easily. In fact, we do that in the Player LSP.\\n","header":"XLR SDK","title":"XLR Concepts"},"/xlr/intro":{"path":"/xlr/intro","content":"\\n\\n","title":"Into to XLR"},"/xlr/intro#what-is-xlr":{"path":"/xlr/intro#what-is-xlr","content":"What is XLR\\n\\nXLR, short for cross(x) language representation, is a way to export a static and language agnostic description of a TypeScript type or interface packaged along with the original type or interface. XLR started as a fork of core-types to add support for some missing features (generics, supported types, inheritance) that are heavily used in Player but has evolved into a superset of its features with some opinionated functionality to support Player specific conventions. XLR now powers a majority of the Player language features such as content validation, editor suggestions, and in editor documentation.\\n","header":"What is XLR","title":"Into to XLR"},"/xlr/intro#why-do-we-need-it":{"path":"/xlr/intro#why-do-we-need-it","content":"Why Do We Need it\\n\\nXLR was developed to fill in one of the major gaps in the Player ecosystem: Because everything is dynamic, there is no way to statically/programmatically know what plugin provides what capabilities (assets, data types, validations, etc) to Player and what that capability looks like. This becomes a real issue in the tooling around Player when things like content authoring and validation. In both use-cases information on what assets are available for use, what parameters do those assets require, what types are those parameters, etc. is required but cannot be assumed. Historically we have seen this gap bridged by hardcoding the set of capabilities that are available but that has proven to be a never ending cycle of keeping those definitions updated when things change and knowing about the entire set of capabilities, even those that people develop silently. With XLR, a static description of all capabilities provided by a plugin can be compiled at build time, included in the package, and used at any point in the future for a multitude of capabilities.\\n","header":"Why Do We Need it","title":"Into to XLR"},"/xlr/intro#how-do-i-leverage-xlr":{"path":"/xlr/intro#how-do-i-leverage-xlr","content":"How Do I Leverage XLR\\n\\nHow much you use XLR is pretty dependant on your niche in the Player ecosystem.\\n","header":"How Do I Leverage XLR","title":"Into to XLR"},"/xlr/intro#as-a-typescript-plugincapability-author":{"path":"/xlr/intro#as-a-typescript-plugincapability-author","content":"As a TypeScript Plugin/Capability Author\\n\\nIf you are developing Player capabilities for Core/React, all you need to do is have your Plugin fill in the ExtendedPlayerPlugin interface and run the Player CLI during build time and the CLI will take care of compiling and bundling the capabilities. You can see an example of this in the Exporting Plugin Capabilities section.\\n","header":"As a TypeScript Plugin/Capability Author","title":"Into to XLR"},"/xlr/usage":{"path":"/xlr/usage","content":"\\n\\n","title":"Using XLR"},"/xlr/usage#part-1---creating-xlrs":{"path":"/xlr/usage#part-1---creating-xlrs","content":"Part 1 - Creating XLRs\\n\\nXLR creation is done through the Player CLI which can be added to your project like so:\\n\\nyarn install @player-tools/cli\\n","header":"Part 1 - Creating XLRs","title":"Using XLR"},"/xlr/usage#exporting-base-type-definitions":{"path":"/xlr/usage#exporting-base-type-definitions","content":"Exporting Base Type Definitions\\n\\nIf you want to compile all exported interfaces/types to XLRs run the following command as part of your build\\n\\nplayer xlr compile -m types\\n","header":"Exporting Base Type Definitions","title":"Using XLR"},"/xlr/usage#exporting-plugin-capabilities":{"path":"/xlr/usage#exporting-plugin-capabilities","content":"Exporting Plugin Capabilities\\n\\nIf you are writing a Player Plugin, you\'ll first need to have your plugin extend the ExtendedPlayerPlugin interface and fill in the generics with an array of the interfaces/types for each Capability. For example, you can see how its done below in the core reference assets plugin\\n\\nexport class ReferenceAssetsPlugin\\n  implements\\n    PlayerPlugin,\\n    ExtendedPlayerPlugin\\n\\nThen run the following command as part of your build\\n\\nplayer xlr compile -m plugin\\n","header":"Exporting Plugin Capabilities","title":"Using XLR"},"/xlr/usage#part-2---using-xlrs":{"path":"/xlr/usage#part-2---using-xlrs","content":"Part 2 - Using XLRs\\n\\n","header":"Part 2 - Using XLRs","title":"Using XLR"},"/xlr/usage#sdk-initialization":{"path":"/xlr/usage#sdk-initialization","content":"SDK: Initialization\\n\\nTo start using the XLR SDK you\'ll need to install the SDK package\\n\\nyarn install @player-tools/xlr-sdk\\n\\nNext, import the SDK\\n\\nimport { XLRSDK } from \\"@player-tools/xlr-sdk\\"\\n\\nIf you want to implement a custom object store, also import the XLRRegistry interface and have your custom registry implement it.\\n\\nLastly, just initialize an instance of it.\\n\\nimport { XLRSDK } from \\"@player-tools/xlr-sdk\\"\\n\\nconst sdk = new XLRSDK();\\n\\nor if you want to use your custom registry, just pass it in to the initializer.\\n\\nimport { XLRSDK } from \\"@player-tools/xlr-sdk\\"\\nimport { customRegistry } from \\"./customRegistry\\"\\n\\nconst sdk = new XLRSDK(customRegistry);\\n","header":"SDK: Initialization","title":"Using XLR"},"/xlr/usage#sdk-loading-types":{"path":"/xlr/usage#sdk-loading-types","content":"SDK: Loading Types\\n\\nIf you want to load XLR types from disk, you can use the loadDefinitionsFromDisk function and pass it the path to parent folder of the xlr directory.\\n\\nconst sdk = new XLRSDK();\\nsdk.loadDefinitionsFromDisk(\'./common/static_xlrs/core\');\\n\\nIf you want to load XLR types from a module, you can use the loadDefinitionsFromModule function and pass it the module to load from.\\n\\nconst sdk = new XLRSDK();\\nsdk.loadDefinitionsFromModule(require(\\"@player-ui/reference-assets-plugin\\").path);\\n\\nIf you want to filter any of the types that are being loaded, you can supply a Filters object as the second arguments\\nIf you want to apply any transform functions to the modules that you load, you can supply a list of TransformFunction as the third argument\\n","header":"SDK: Loading Types","title":"Using XLR"},"/xlr/usage#sdk-usage":{"path":"/xlr/usage#sdk-usage","content":"SDK: Usage\\n\\nAfter the types are loaded into the SDK there are a couple ways to interact with them.\\n","header":"SDK: Usage","title":"Using XLR"},"/xlr/usage#type-recall":{"path":"/xlr/usage#type-recall","content":"Type Recall\\n\\nTo get a type back you can use the getType function and pass the name of the type you want to retrieve. You can also use the hasType function to check to see if the type exists before you try and access it.\\n\\nconst sdk = new XLRSDK();\\nif(sdk.hasType(\\"InputAsset\\")){\\n  return sdk.getType(\\"InputAsset\\")\\n} else {\\n  throw new Error(\\"Oh no!\\")\\n}\\n","header":"Type Recall","title":"Using XLR"}}')}}]);