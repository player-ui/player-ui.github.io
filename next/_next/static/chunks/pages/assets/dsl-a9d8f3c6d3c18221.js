(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1864],{30876:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"===typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"===typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},90996:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/assets/dsl",function(){return n(58632)}])},43857:function(e,t,n){"use strict";n.d(t,{Z:function(){return j}});var a=n(52322),o=n(2784),i=n(97729),r=n(64033),s=n(30876),l=n(21925),p=n(76808),c=n(55165),m=n(63637),d=n.n(m);function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function h(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}var f=["id"],x=["id"],k="chakra-skip-nav",y={userSelect:"none",border:"0",height:"1px",width:"1px",margin:"-1px",padding:"0",outline:"0",overflow:"hidden",position:"absolute",clip:"rect(0 0 0 0)",_focus:{clip:"auto",width:"auto",height:"auto"}},b=(0,p.Gp)((function(e,t){var n=(0,p.mq)("SkipLink",e),a=(0,p.Lr)(e),i=a.id,r=void 0===i?k:i,s=h(a,f),l=d()({},y,n);return o.createElement(p.m$.a,u({},s,{ref:t,href:"#"+r,__css:l}))}));c.Ts&&(b.displayName="SkipNavLink");var g=(0,p.Gp)((function(e,t){var n=e.id,a=void 0===n?k:n,i=h(e,x);return o.createElement(p.m$.div,u({ref:t,id:a,tabIndex:-1,style:{outline:0}},i))}));c.Ts&&(g.displayName="SkipNavContent");var C=n(46977),w=n(55002),N=function(e){var t;return(0,a.jsxs)(r.xu,{display:{base:"none",xl:"block"},children:["Table Of Contents",(0,a.jsx)(r.GS,{spacing:1,ml:"0",mt:"4",styleType:"none",children:null===(t=e.tableOfContents)||void 0===t?void 0:t.map((function(e){return(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#".concat(e.id),children:e.text})},e.text)}))})]})},v=function(e){var t=o.useContext(C.Il).bannerExpanded,n="72px",i="calc(100vh - 88px - ".concat(t?n:"0px",")"),s="calc(100vh - 88px - 105px - ".concat(t?n:"0px",")");return(0,a.jsxs)(r.xu,{minH:"100vh",children:[(0,a.jsx)(b,{children:"Skip to Main Content"}),(0,a.jsxs)(r.kC,{flexDir:"column",padding:"2",children:[(0,a.jsx)(w._g,{}),(0,a.jsx)(r.iz,{}),(0,a.jsx)(r.kC,{children:(0,a.jsx)(r.xu,{as:"main",w:"100%",mx:"auto",children:(0,a.jsxs)(r.xu,{display:{md:"flex"},children:[(0,a.jsx)(r.xu,{display:{base:"none",md:"block"},overflow:"auto",maxH:i,pr:"8",ml:"4",children:(0,a.jsx)(w.Hy,{})}),(0,a.jsxs)(r.xu,{flex:"1",minW:"0",overflow:"auto",maxH:i,children:[(0,a.jsxs)(r.xu,{minH:s,children:[(0,a.jsx)(g,{}),e.children]}),(0,a.jsx)(r.xu,{pt:"20",children:(0,a.jsx)(w.$_,{})})]}),e.tableOfContents&&(0,a.jsx)(N,{tableOfContents:e.tableOfContents})]})})})]})]})};function j(e){return function(t){return(0,a.jsxs)(v,{children:[(0,a.jsx)(i.default,{children:(0,a.jsxs)("title",{children:["Player - ",e.title]})}),(0,a.jsx)(r.kC,{alignItems:"center",children:(0,a.jsx)(r.W2,{maxW:"container.lg",children:(0,a.jsx)(s.Zo,{components:l.tl,children:t.children})})})]})}}},58632:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return l}});n(2784);var a=n(30876),o=n(43857);function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r={},s=(0,o.Z)({title:"Writing DSL Components",tableOfContents:[{text:"Creating TSX Components",id:"creating-tsx-components",level:1},{text:"Creating a Basic Component",id:"creating-a-basic-component",level:2},{text:"Slots",id:"slots",level:2},{text:"Creating a Complex Component",id:"creating-a-complex-component",level:2},{text:"Components with Specially Handled Properties",id:"components-with-specially-handled-properties",level:3},{text:"View Components",id:"view-components",level:3}]});function l(e){var t=e.components,n=i(e,["components"]);return(0,a.kt)(s,Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",Object.assign({},{id:"creating-tsx-components"}),(0,a.kt)("a",Object.assign({parentName:"h1"},{href:"#creating-tsx-components"}),"Creating TSX Components")),(0,a.kt)("p",null,"In order to take advantage of the auto-completion and validation of TypeScript types, asset libraries can export a component library for content authoring. Creating components isn\u2019t much different than writing a React component for the web. The primative elements uses the ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://github.com/intuit/react-json-reconciler"}),"react-json-reconciler")," to create the JSON content tree, with utilities to make it quick and painless to create new asset-components."),(0,a.kt)("h2",Object.assign({},{id:"creating-a-basic-component"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#creating-a-basic-component"}),"Creating a Basic Component")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Asset")," component from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-tools/dsl")," package is the quickest way to create a new component. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Asset")," component will take all the Asset\u2019s properties and convert them to their equivalent JSON representation when serialized."),(0,a.kt)("p",null,"In the examples below, we\u2019ll be creating a TSX component for the ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," asset in our reference set. "),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," asset has a ",(0,a.kt)("inlineCode",{parentName:"p"},"label")," slot (which is typically used as a ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," asset), a ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," (for flow transitions), and an ",(0,a.kt)("inlineCode",{parentName:"p"},"exp")," for evaluating expressions.\nFor this example we\u2019ll use a resemblance of this type, but in practice types should be imported directly from their asset rather than duplicating them."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-ts"}),"import type { Asset, AssetWrapper, Expression } from '@player-ui/player';\n\nexport interface ActionAsset<AnyTextAsset extends Asset = Asset> extends Asset<'action'> {\n  /** The transition value of the action in the state machine */\n  value?: string;\n\n  /** A text-like asset for the action's label */\n  label?: AssetWrapper<AnyTextAsset>;\n\n  /** An optional expression to execute before transitioning */\n  exp?: Expression;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note: The ",(0,a.kt)("inlineCode",{parentName:"em"},"Asset")," type we\u2019re importing here from the ",(0,a.kt)("inlineCode",{parentName:"em"},"@player-ui/player")," package is different than the ",(0,a.kt)("inlineCode",{parentName:"em"},"Asset")," component from the ",(0,a.kt)("inlineCode",{parentName:"em"},"@player-tools/dsl")," package. The former is the basic TypeScript definition for what an Asset in Player is while the latter is a helper function for allowing DSL components to be created. Fundamentally they share a name to reinforce the abstraction of foundational capabilities to core libraries")),(0,a.kt)("p",null,"To turn this interface into a usable component, create a new React component that ",(0,a.kt)("em",{parentName:"p"},"renders")," an Asset:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"import { Asset, AssetPropsWithChildren } from '@player-tools/dsl';\n\nexport const Action = (props: AssetPropsWithChildren<ActionAsset>) => {\n  return <Asset type=\"action\" {...props} />;\n}\n")),(0,a.kt)("p",null,"This would allow users to import the ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," component, and ",(0,a.kt)("em",{parentName:"p"},"render")," it to JSON:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'const myView = <Action value="next" />\n')),(0,a.kt)("p",null,"which when compiled would look like "),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n    "id": "root",\n    "type": "action",\n    "value": "next"\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"AssetPropsWithChildren")," type is a utility type to help convert the ",(0,a.kt)("inlineCode",{parentName:"p"},"Asset")," type (which has a required ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," properties) to a type more suited for components. It changes the ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," to be optional, and adds a ",(0,a.kt)("inlineCode",{parentName:"p"},"applicability")," property automatically."),(0,a.kt)("h2",Object.assign({},{id:"slots"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#slots"}),"Slots")),(0,a.kt)("p",null,"Continuing the example fo the ",(0,a.kt)("inlineCode",{parentName:"p"},"ActionAsset"),", we need a way for users to users to specify the nested ",(0,a.kt)("inlineCode",{parentName:"p"},"label")," property, which itself is another asset. This can be accomplished using the ",(0,a.kt)("inlineCode",{parentName:"p"},"createSlot")," utility function. The ",(0,a.kt)("inlineCode",{parentName:"p"},"createSlot")," function also accept components to enable automatically creating ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"collection")," assets when they aren\u2019t specified where needed. If these components aren\u2019t passed into the slot when used, the resulting content may be invalid. Let\u2019s add a ",(0,a.kt)("inlineCode",{parentName:"p"},"Label")," slot to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," component to allow it to be easily authored. Lets assume we already have a ",(0,a.kt)("inlineCode",{parentName:"p"},"Text")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Collection")," component. "),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"import React from 'react';\nimport { Asset, AssetPropsWithChildren, createSlot } from '@player-tools/dsl';\n\nexport const Action = (props: AssetPropsWithChildren<ActionAsset>) => {\n  return <Asset type=\"action\" {...props} />;\n}\n\nAction.Label = createSlot({\n  name: 'label',\n  wrapInAsset: true,\n  TextComp: SomeTextComponent\n  CollectionComp: SomeCollectionComponent\n})\n")),(0,a.kt)("p",null,"This adds component (",(0,a.kt)("inlineCode",{parentName:"p"},"Action.Label"),") that will automatically place any nested children under the ",(0,a.kt)("inlineCode",{parentName:"p"},"label")," property of the parent asset:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'const myView = (\n  <Action value="next">\n    <Action.Label>\n      <Text value="Continue" />\n    </Action.Label>\n  </Action>\n);\n')),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"import React from 'react';\n\nconst myView = (\n  <Action value=\"next\">\n    <Action.Label>Continue</Action.Label>\n  </Action>\n);\n")),(0,a.kt)("p",null,"which when compiled would look like (note the auto injection of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Text")," asset and corresponding Asset Wrapper):"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n    "id": "root",\n    "type": "action",\n    "value": "next",\n    "label": {\n        "asset": {\n            "id": "root-label-text",\n            "type": "text",\n            "value": "Continue"\n        }\n    }\n}\n')),(0,a.kt)("p",null,"And if we wanted to have the ",(0,a.kt)("inlineCode",{parentName:"p"},"label")," property to have to text assets we could write the following DSL"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'const myView = (\n  <Action value="next">\n    <Action.Label>\n        <Text>Some</Text>\n        <Text>Text</Text>\n    </Action.Label>\n  </Action>\n);\n')),(0,a.kt)("p",null,"which when compiled would look like the following (note the automatic insertion of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Collection")," Asset):"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n    "id": "root",\n    "type": "action",\n    "value": "next",\n    "label": {\n        "asset": {\n            "id": "root-collection",\n            "type": "text",\n            "values": [\n                {\n                    "asset": {\n                        "id": "root-collection-1-text",\n                        "type": "text",\n                        "value": "Some"\n                    }\n                },{\n                    "asset": {\n                        "id": "root-collection-2-text",\n                        "type": "text",\n                        "value": "Text"\n                    }\n                }\n            ]\n        }\n    }\n}\n')),(0,a.kt)("h2",Object.assign({},{id:"creating-a-complex-component"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#creating-a-complex-component"}),"Creating a Complex Component")),(0,a.kt)("p",null,"While a majority of Assets can be described simply via the base ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," Component, there are certain cases where DSL components need to contain a bit more logic. This section aims to describe further tools that are offered in the ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-tools/dsl")," package."),(0,a.kt)("h3",Object.assign({},{id:"components-with-specially-handled-properties"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#components-with-specially-handled-properties"}),"Components with Specially Handled Properties")),(0,a.kt)("p",null,"In the previous example, we covered how to create a DSL Component for our reference ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," Asset. Our actual Action Asset however looks a little bit different. "),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"import React from 'react';\n\nexport const Action = (\n  props: Omit<AssetPropsWithChildren<ActionAsset>, 'exp'> & {\n    /** An optional expression to execute before transitioning */\n    exp?: ExpressionTemplateInstance;\n  }\n) => {\n  const { exp, children, ...rest } = props;\n\n  return (\n    <Asset type=\"action\" {...rest}>\n      <property name=\"exp\">{exp?.toValue()}</property>\n      {children}\n    </Asset>\n  );\n};\n")),(0,a.kt)("p",null,"Crucially, the difference is in how the ",(0,a.kt)("inlineCode",{parentName:"p"},"exp")," property is handled. As the ",(0,a.kt)("inlineCode",{parentName:"p"},"exp")," property is an ",(0,a.kt)("inlineCode",{parentName:"p"},"Expression"),", if we just allowed the ",(0,a.kt)("inlineCode",{parentName:"p"},"Action")," component to process this property, we would end up with an ",(0,a.kt)("inlineCode",{parentName:"p"},"ExpressionTemplate")," instance ",(0,a.kt)("em",{parentName:"p"},"not")," an ",(0,a.kt)("inlineCode",{parentName:"p"},"Expression")," instance. While technically they are equivalent, there is no need to wrap the final string in the Expression Template tags (",(0,a.kt)("inlineCode",{parentName:"p"},"@[]@"),") since we know the string will be an ",(0,a.kt)("inlineCode",{parentName:"p"},"Expression")," and it will just lead to additonal procssing at runtime. Therefore, we need to do a few things to properly construct this DSL component."),(0,a.kt)("p",null,"The first is to modify the type for the commponent. In the above code snippit we are using the ",(0,a.kt)("inlineCode",{parentName:"p"},"Omit")," type to remove the base ",(0,a.kt)("inlineCode",{parentName:"p"},"exp")," property from the source type and replacing it with an ",(0,a.kt)("inlineCode",{parentName:"p"},"exp")," property that expects a ",(0,a.kt)("inlineCode",{parentName:"p"},"ExpressionTemplateInstance")," which allows an DSL expression to be passed in. "),(0,a.kt)("p",null,"The second is to extract out the ",(0,a.kt)("inlineCode",{parentName:"p"},"exp")," property from the props and use a ",(0,a.kt)("inlineCode",{parentName:"p"},"property")," component to manually control how that property will get serialized. This component is exposed by the underlying ",(0,a.kt)("inlineCode",{parentName:"p"},"react-json-reconciler")," library which also supplies an ",(0,a.kt)("inlineCode",{parentName:"p"},"array"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"obj")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," component to allow full control over more complicated data structures. The ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-tools/dsl")," package also exposes the ",(0,a.kt)("inlineCode",{parentName:"p"},"toJsonProperties")," function to process whole non-Asset objects."),(0,a.kt)("h3",Object.assign({},{id:"view-components"}),(0,a.kt)("a",Object.assign({parentName:"h3"},{href:"#view-components"}),"View Components")),(0,a.kt)("p",null,"For Assets that are intended to be Views, a ",(0,a.kt)("inlineCode",{parentName:"p"},"View")," component is exported from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-tools/dsl")," package. Its usage is exactly the same as the ",(0,a.kt)("inlineCode",{parentName:"p"},"Asset")," component, however it correctly handles the serialization of any Crossfield Validations that exist on the View."),(0,a.kt)("hr",null),(0,a.kt)("p",null,(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://github.dev/playerui/player/blob/main//home/circleci/.cache/bazel/_bazel_circleci/e8362d362e14c7d23506d1dfa3aea8b8/sandbox/processwrapper-sandbox/1485/execroot/player/docs/site/pages/assets/dsl.mdx"}),"Help to improve this page")))}l.isMDXComponent=!0}},function(e){e.O(0,[6525,7882,3832,9774,2888,179],(function(){return t=90996,e(e.s=t);var t}));var t=e.O();_N_E=t}]);