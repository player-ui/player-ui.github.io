(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8081],{30876:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,f=u["".concat(l,".").concat(d)]||u[d]||h[d]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"===typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},95288:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/dsl/schema",function(){return n(57051)}])},43857:function(e,t,n){"use strict";n.d(t,{Z:function(){return w}});var a=n(52322),r=n(2784),i=n(97729),o=n(64033),s=n(30876),l=n(21925),c=n(76808),p=n(55165),h=n(63637),u=n.n(h);function d(){return(d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function f(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}var m=["id"],y=["id"],b="chakra-skip-nav",g={userSelect:"none",border:"0",height:"1px",width:"1px",margin:"-1px",padding:"0",outline:"0",overflow:"hidden",position:"absolute",clip:"rect(0 0 0 0)",_focus:{clip:"auto",width:"auto",height:"auto"}},k=(0,c.Gp)((function(e,t){var n=(0,c.mq)("SkipLink",e),a=(0,c.Lr)(e),i=a.id,o=void 0===i?b:i,s=f(a,m),l=u()({},g,n);return r.createElement(c.m$.a,d({},s,{ref:t,href:"#"+o,__css:l}))}));p.Ts&&(k.displayName="SkipNavLink");var j=(0,c.Gp)((function(e,t){var n=e.id,a=void 0===n?b:n,i=f(e,y);return r.createElement(c.m$.div,d({ref:t,id:a,tabIndex:-1,style:{outline:0}},i))}));p.Ts&&(j.displayName="SkipNavContent");var x=n(46977),O=n(55002),v=function(e){var t;return(0,a.jsxs)(o.xu,{display:{base:"none",xl:"block"},children:["Table Of Contents",(0,a.jsx)(o.GS,{spacing:1,ml:"0",mt:"4",styleType:"none",children:null===(t=e.tableOfContents)||void 0===t?void 0:t.map((function(e){return(0,a.jsx)("li",{children:(0,a.jsx)("a",{href:"#".concat(e.id),children:e.text})},e.text)}))})]})},T=function(e){var t=r.useContext(x.Il).bannerExpanded,n="72px",i="calc(100vh - 88px - ".concat(t?n:"0px",")"),s="calc(100vh - 88px - 105px - ".concat(t?n:"0px",")");return(0,a.jsxs)(o.xu,{minH:"100vh",children:[(0,a.jsx)(k,{children:"Skip to Main Content"}),(0,a.jsxs)(o.kC,{flexDir:"column",padding:"2",children:[(0,a.jsx)(O._g,{}),(0,a.jsx)(o.iz,{}),(0,a.jsx)(o.kC,{children:(0,a.jsx)(o.xu,{as:"main",w:"100%",mx:"auto",children:(0,a.jsxs)(o.xu,{display:{md:"flex"},children:[(0,a.jsx)(o.xu,{display:{base:"none",md:"block"},overflow:"auto",maxH:i,pr:"8",ml:"4",children:(0,a.jsx)(O.Hy,{})}),(0,a.jsxs)(o.xu,{flex:"1",minW:"0",overflow:"auto",maxH:i,children:[(0,a.jsxs)(o.xu,{minH:s,children:[(0,a.jsx)(j,{}),e.children]}),(0,a.jsx)(o.xu,{pt:"20",children:(0,a.jsx)(O.$_,{})})]}),e.tableOfContents&&(0,a.jsx)(v,{tableOfContents:e.tableOfContents})]})})})]})]})};function w(e){return function(t){return(0,a.jsxs)(T,{children:[(0,a.jsx)(i.default,{children:(0,a.jsxs)("title",{children:["Player - ",e.title]})}),(0,a.jsx)(o.kC,{alignItems:"center",children:(0,a.jsx)(o.W2,{maxW:"container.lg",children:(0,a.jsx)(s.Zo,{components:l.tl,children:t.children})})})]})}}},57051:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return l}});n(2784);var a=n(30876),r=n(43857);function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o={},s=(0,r.Z)({title:"Writing DSL Schemas",tableOfContents:[{text:"Basic Schema",id:"basic-schema",level:1},{text:"Arrays",id:"arrays",level:2},{text:"Changing the Name of a Generated Type",id:"changing-the-name-of-a-generated-type",level:2},{text:"Defining Data Types",id:"defining-data-types",level:1},{text:"Data Refs",id:"data-refs",level:2},{text:"Local Data Types",id:"local-data-types",level:5},{text:"What that Looks Like",id:"what-that-looks-like",level:5},{text:"Using the Schema Object in JSX/TSX Content",id:"using-the-schema-object-in-jsxtsx-content",level:1},{text:"DSL Benefit in Schema",id:"dsl-benefit-in-schema",level:1},{text:"Format",id:"format",level:2},{text:"Ease of Use",id:"ease-of-use",level:2}]});function l(e){var t=e.components,n=i(e,["components"]);return(0,a.kt)(s,Object.assign({},o,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",Object.assign({},{id:"basic-schema"}),(0,a.kt)("a",Object.assign({parentName:"h1"},{href:"#basic-schema"}),"Basic Schema")),(0,a.kt)("p",null,"To author a schema object you should first start by constructing a standard typescript object where the nested paths correlate to the paths on your desired schema. When compiled to the final Player ",(0,a.kt)("inlineCode",{parentName:"p"},"Schema")," object, the intermediate types and ROOT elements will automatically be constructed. A basic example would be:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-typescript"}),"export default {\n  foo: {\n    bar: {\n      baz: {...}\n      faz: {...}\n    }\n  }\n}\n")),(0,a.kt)("p",null,"which correlates to a schema of:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n  "ROOT": {\n    "foo": {\n      "type": "fooType"\n    }\n  },\n  "fooType": {\n    "bar": {\n      "type": "barType"\n    }\n  },\n  "barType": {\n    "baz": {...},\n    "faz": {...}\n  }\n}\n')),(0,a.kt)("h2",Object.assign({},{id:"arrays"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#arrays"}),"Arrays")),(0,a.kt)("p",null,"A single object array can be used to indicate an array type, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-typescript"}),"export default {\n  foo: [\n    {\n      bar: {...}\n    }\n  ]\n}\n")),(0,a.kt)("p",null,"will generate the schema:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n  "ROOT": {\n    "foo": {\n      "type": "fooType",\n      "isArray": true\n    }\n  },\n  "fooType": {\n    "bar": {\n      "type": "barType"\n    }\n  },\n  "barType": {\n    "baz": {...},\n    "faz": {...}\n  }\n}\n')),(0,a.kt)("h2",Object.assign({},{id:"changing-the-name-of-a-generated-type"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#changing-the-name-of-a-generated-type"}),"Changing the Name of a Generated Type")),(0,a.kt)("p",null,"To change the name of the generated type at any point in the tree, import the ",(0,a.kt)("inlineCode",{parentName:"p"},"SchemaTypeName")," symbol from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-tools/dsl")," and use it as a key on the object whos name you want to change:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-typescript"}),'import { SchemaTypeName } from "@player-tools/dsl"\nexport default {\n  foo: {\n    bar: {\n      [SchemaTypeName]: "buzz",\n      baz: {...}\n      faz: {...}\n    }\n  }\n}\n')),(0,a.kt)("p",null,"will generate the schema: "),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n  "ROOT": {\n    "foo": {\n      "type": "fooType",\n      "isArray": true\n    }\n  },\n  "fooType": {\n    "buzz": {\n      "type": "buzzType"\n    }\n  },\n  "buzzType": {\n    "baz": {\n      "type": ""\n    },\n    "faz": {\n      "type": ""\n    }\n  }\n}\n')),(0,a.kt)("h1",Object.assign({},{id:"defining-data-types"}),(0,a.kt)("a",Object.assign({parentName:"h1"},{href:"#defining-data-types"}),"Defining Data Types")),(0,a.kt)("p",null,"The leaf nodes of the schema will need some concrete definition of what data exists at that point of the schema. There are two ways to provide this data."),(0,a.kt)("h2",Object.assign({},{id:"data-refs"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#data-refs"}),"Data Refs")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@player-ui/common-types-plugin")," package exposes the types it provides to Player when used and ",(0,a.kt)("em",{parentName:"p"},"references")," to those types as well. Using these ",(0,a.kt)("inlineCode",{parentName:"p"},"Language.DataTypeRef")," values you can indicate what the data type will be at that node and that it will be a type explicitly defined in Player so no additional information needs to be provided (e.g. validations nor formats) as at runtime it will use the type loaded into Player by the plugin. "),(0,a.kt)("p",null,"It is recommended that if your player integration loads additional types, to export similar references to those types to make authorship easier. "),(0,a.kt)("h5",Object.assign({},{id:"local-data-types"}),(0,a.kt)("a",Object.assign({parentName:"h5"},{href:"#local-data-types"}),"Local Data Types")),(0,a.kt)("p",null,"Sometimes you need to define specific data types that extend existing types for certain pieces of data in a schema, whether that be for specific validations, formatting or both. In this case, in your DSL project you can define an object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Schema.DataType")," and provide that value to a leaf node. That will indicate that this unique type needs to be included in its entirety to Player as it has information not already contained in Player."),(0,a.kt)("h5",Object.assign({},{id:"what-that-looks-like"}),(0,a.kt)("a",Object.assign({parentName:"h5"},{href:"#what-that-looks-like"}),"What that Looks Like")),(0,a.kt)("p",null,"Using our previous example we can fill in the values with some types now to look like this in the ts object:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-typescript"}),"import { dataTypes } from '@player-ui/common-types-plugin';\nimport type { Schema } from '@player-ui/types';\n\nconst mycustombooleantype = {\n  type: \"BooleanType\",\n  validation: [\n    {\n      type: 'oneOf',\n      message: 'Value has to be true or false',\n      options: [true, false],\n    },\n  ],\n} satisfies Schema.DataType\n\nconst mySchema = {\n  foo: {\n    bar: {\n      baz: dataTypes.BooleanTypeRef\n      faz: mycustombooleantype\n    }\n  }\n}\n\nexport default mySchema\n")),(0,a.kt)("p",null,"and like this in the final schema:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n  "ROOT":{\n    "foo":{\n      "type": "fooType"\n    }\n  },\n  "fooType":{\n    "bar": {\n      "type":"barType"\n    }\n  },\n  "barType":{\n    "baz":{\n      "type": "BooleanType"\n    },\n    "faz":{\n      "type": "BooleanType",\n      "validation": [\n        {\n          "type": "oneOf",\n          "message": "Value has to be true or false",\n          "options": [true, false],\n        },\n      ],\n    }\n  }\n}\n')),(0,a.kt)("h1",Object.assign({},{id:"using-the-schema-object-in-jsxtsx-content"}),(0,a.kt)("a",Object.assign({parentName:"h1"},{href:"#using-the-schema-object-in-jsxtsx-content"}),"Using the Schema Object in JSX/TSX Content")),(0,a.kt)("p",null,"As the schema is now a TypeScript obejct, you can now directly reference the schema anywhere in content. The ",(0,a.kt)("inlineCode",{parentName:"p"},"makeBindingsForObject()")," function takes your schema object and constructs the bindings opaquely within the object. This allows the use of the native path in your authored content and for the actual underlying binding to be used when the content is compiled. Additionally, as the underlying bindings are exposed, can you can use the native object path with functions like ",(0,a.kt)("inlineCode",{parentName:"p"},".toString()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},".toValue()"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"toRefString()")," like you could with regular string template bindings."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"import { makeBindingsForObject } from '@player-tools/dsl';\nimport { mySchema } from './schema'\n\nconst schema = makeBindingsForObject(mySchema)\n\nconst baz = schema.foo.bar.baz\n\nconst view = (\n  <Input binding={baz}>\n    <Input.Label>\n      <Text>\n        The current value is {baz.toString()}\n      </Text>\n    </Input.Label>\n  </Input>\n)\n\nconst navigation = {...}\n\nexport default {\n  id: \"example\",\n  views: [view],\n  navigation,\n}\n")),(0,a.kt)("h1",Object.assign({},{id:"dsl-benefit-in-schema"}),(0,a.kt)("a",Object.assign({parentName:"h1"},{href:"#dsl-benefit-in-schema"}),"DSL Benefit in Schema")),(0,a.kt)("h2",Object.assign({},{id:"format"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#format"}),"Format")),(0,a.kt)("h2",Object.assign({},{id:"ease-of-use"}),(0,a.kt)("a",Object.assign({parentName:"h2"},{href:"#ease-of-use"}),"Ease of Use")),(0,a.kt)("hr",null),(0,a.kt)("p",null,(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://github.dev/player-ui/player/blob/main/docs/site/pages/dsl/schema.mdx"}),"Help to improve this page")))}l.isMDXComponent=!0}},function(e){e.O(0,[6525,7882,3832,9774,2888,179],(function(){return t=95288,e(e.s=t);var t}));var t=e.O();_N_E=t}]);