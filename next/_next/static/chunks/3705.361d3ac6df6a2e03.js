"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3705],{33705:function(e){e.exports=JSON.parse('{"/./about":{"path":"/./about","content":"\\n\\nPlayer Logo\\nPlayer Logo\\n","title":"About"},"/./about#what-is-player":{"path":"/./about#what-is-player","content":"What Is Player?\\n\\nWhat is Player? Simply put, Player is a framework that enables users to natively render experiences across multiple platforms via a declarative content payload. At Intuit engineers use Player to accelerate the development of new experiences as Player allows them offload data/state management and fit seamlessly with other applications all with minimal configuration.\\n","header":"What Is Player?","title":"About"},"/./about#why-did-we-build-it":{"path":"/./about#why-did-we-build-it","content":"Why Did We Build It?\\nPlayer is the second iteration of this kind of framework. The first iteration that was developed for internal use and worked well but had its limitations. With limited extensibility, limited platform support, and no type support the framework stated to rapidly show its age as we tried to move into newer spaces. It was then determined that we needed to take our learnings from the past few years and rearchitect it from the ground up. And that\'s how we got Player.\\n","header":"Why Did We Build It?","title":"About"},"/./faqs":{"path":"/./faqs","content":"\\n\\n","title":"FAQs"},"/./faqs#frequently-asked-questions":{"path":"/./faqs#frequently-asked-questions","content":"Frequently Asked Questions\\n\\n","header":"Frequently Asked Questions","title":"FAQs"},"/./faqs#how-much-do-i-need-to-know-about-player-to-use-it":{"path":"/./faqs#how-much-do-i-need-to-know-about-player-to-use-it","content":"How much do I need to know about Player to use it?\\nWhile it definitely helps to understand how it works under the hood, as long as you understand the how Assets & Views, Data & Expressions, and Navigation works you should be ready to author Player content.\\n\\nIf you are an engineer integrating Player into your experience you should probably be familiar with what Plugins are available and how to write your own to support the folks who will be authoring the content. The more advanced your use case is you can explore topics as they become applicable.\\n","header":"How much do I need to know about Player to use it?","title":"FAQs"},"/./faqs#how-is-player-versioned":{"path":"/./faqs#how-is-player-versioned","content":"How is Player versioned?\\nPlayer follows semantic versioning. We will also publish changelogs for every release.\\n\\nA Major release will denote a breaking change such that it would not, without changes to your implementation or content, work as a drop in replacement. We try and avoid these and will typically batch many breaking changes into a major release to make updating more of a \\"all in one go\\" effort. Additionally we will typically announce these releases and make a RC available for users to test and proactively start updates. A migration guide will also be published with an advisory on the changes and what the recommended migration path is.\\n\\nA Minor release will denote the addition of new functionality that is backward compatible with the previous release. When a new minor version is published we highly encourage users to update promptly.\\n\\nA Patch release will denote a bugfix or a minor non-functional change.\\n","header":"How is Player versioned?","title":"FAQs"},"/./faqs#i-am-having-issues-using-player-how-can-i-get-help":{"path":"/./faqs#i-am-having-issues-using-player-how-can-i-get-help","content":"I am having issues using Player, how can I get help?\\nHead over to our issues page on Github and feel free to open a ticket with the bug report template and we\'ll do our best to get back to you. The more detail you include the easier it will be for us to help troubleshoot.\\n","header":"I am having issues using Player, how can I get help?","title":"FAQs"},"/./getting-started":{"path":"/./getting-started","content":"\\n\\n","title":"Getting Started"},"/./getting-started#getting-started":{"path":"/./getting-started#getting-started","content":"Getting Started\\n\\nGetting started with Player is simple. Below we have guides per platform on how to integrate Player into your platform of choice.\\n","header":"Getting Started","title":"Getting Started"},"/./getting-started#react":{"path":"/./getting-started#react","content":"React\\n\\n","header":"React","title":"Getting Started"},"/./getting-started#install-dependencies":{"path":"/./getting-started#install-dependencies","content":"Install Dependencies\\n\\nThe first dependency you\'ll need to pull in in the React Player itself. You can do this by running\\n\\nyarn add @player-ui/react\\n\\nor\\n\\nnpm install @player-ui/react\\n","header":"Install Dependencies","title":"Getting Started"},"/./getting-started#configuration":{"path":"/./getting-started#configuration","content":"Configuration\\n\\nNext, in your code you\'ll need to initialize Player. This is where you would also initialize any plugins you want to use with Player and create the configuration for Player itself. Below is a minimal example of this.\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { ReferenceAssetsPlugin } from \'@player-ui/reference-assets-plugin-react\';\\n\\n// create a new web-player instance\\n\\nconst reactPlayer = new ReactPlayer({\\n  plugins: [new ReferenceAssetsPlugin()],\\n});\\n","header":"Configuration","title":"Getting Started"},"/./getting-started#render-content":{"path":"/./getting-started#render-content","content":"Render Content\\n\\nNow that you have a Player instance created. You\'ll need to start it with some content.\\n\\nconst content = {/* your content here */}\\nreactPlayer.start(content);\\n\\nWith Player running your content, you\'ll need to actually render out what is processes. To do this, you can use the React Player\'s component API to inster it into your React tree.\\n\\nconst MyApp = () => {\\n  return ;\\n};\\n\\nCongrats! You\'ve got Player up and running. If you need additional functionality you can add more plugins to extend Player\'s functionality. Head over to the Plugins section to take a look at the Plugins we\'ve developed or take a look at the Architecture section to see how you can write your own.\\n","header":"Render Content","title":"Getting Started"},"/./getting-started#ios-swift":{"path":"/./getting-started#ios-swift","content":"iOS (Swift)\\n\\n","header":"iOS (Swift)","title":"Getting Started"},"/./other":{"path":"/./other","content":"\\n\\n"},"/./writing-plugins":{"path":"/./writing-plugins","content":"\\n\\n","title":"Player Team"},"/./team":{"path":"/./team","content":"\\n\\n","title":"Player Team"},"/./team#the-player-team":{"path":"/./team#the-player-team","content":"The Player Team\\n\\n","header":"The Player Team","title":"Player Team"},"/./team#who-we-are":{"path":"/./team#who-we-are","content":"Who We Are\\nThe Player Team is comprised of a group of engineers at Intuit who are passionate about dynamic experiences. Our multidisciplinary background and our multi-platform experience has allowed our team to create and support the Player framework internally for the past few years. You may have seen some of the other open-source projects from out team including auto, design-systems-cli, hooks, proof, and more. We are excited to share our work with the open source community and see how Player grows in the years to come.\\n","header":"Who We Are","title":"Player Team"},"/assets/custom":{"path":"/assets/custom","content":"\\n\\n","title":"Custom Assets"},"/assets/custom#custom-assets":{"path":"/assets/custom#custom-assets","content":"Custom Assets\\n\\nOne of the conscious design decisions we made when building Player was to abstract away the actual asset implementation and open it up for users to bring their own when using Player. This way you can seamlessly integrate Player into your existing experiences and reuse UI assets you may have already built. Below we\'ve outlined the way to build custom assets on the various platforms Player supports.\\n","header":"Custom Assets","title":"Custom Assets"},"/assets/custom#react":{"path":"/assets/custom#react","content":"React\\n\\n","header":"React","title":"Custom Assets"},"/assets/custom#create-your-asset":{"path":"/assets/custom#create-your-asset","content":"Create Your Asset\\n\\nFirst and foremost you need to create a component to handle rendering of your asset. Without any form of transforms, the props to the component will be those from the incoming player content. It\'s recommended that you attach the id, and any other html properties to the root of the asset\'s tree:\\n\\nconst CustomAssetComp = (props) => {\\n  return (\\n\\n      {props.text}\\n\\n  );\\n};\\n\\nAssuming your authored JSON has a string property named text, this will render that.\\n","header":"Create Your Asset","title":"Custom Assets"},"/assets/custom#register-it-using-a-plugin":{"path":"/assets/custom#register-it-using-a-plugin","content":"Register it Using a Plugin\\n\\nNow that we have a React component to render our asset, let\'s create a plugin to register with Player:\\n\\nimport WebAssetProvider from \'@player-ui/asset-provider-plugin-react\';\\n\\nclass CustomAssetPlugin implements ReactPlayerPlugin{\\n  applyReact(reactPlayer) {\\n    new WebAssetProvider([[\'custom\', CustomAssetComp]]).applyReact(reactPlayer);\\n  }\\n}\\n\\nTypically you register assets by type, but the registry acts by finding the most specific partial object match. This allows you to register more specific implementations for assets of the same type.\\n","header":"Register it Using a Plugin","title":"Custom Assets"},"/assets/custom#rendering-nested-assets":{"path":"/assets/custom#rendering-nested-assets","content":"Rendering Nested Assets\\n\\nOften times, assets contain a reference or slot to another asset. For this to function properly, the custom asset needs to defer to the React Player to render the sub-asset. Say for instance we change our custom asset to now support a header property that takes another asset.\\n\\nUse the ReactAsset Component from the @player-ui/react package with the nested asset as props to dynamically determine the rendering implementation to use:\\n\\nimport { ReactAsset } from \'@player-ui/react\';\\n\\nconst CustomAssetComp = (props) => {\\n  return (\\n\\n      {props.header && }\\n      {props.text}\\n\\n  );\\n};\\n\\nThis would automatically find the appropriate handler for the props.header asset and use that to render.\\n","header":"Rendering Nested Assets","title":"Custom Assets"},"/assets/custom#ios":{"path":"/assets/custom#ios","content":"iOS\\n\\nSwiftUI Player assets are made of 3 parts:\\n\\nData: Decodable AssetData\\nView: A SwiftUI View\\nAsset: SwiftUIAsset implementation to tie the two together\\n","header":"iOS","title":"Custom Assets"},"/assets/custom#data":{"path":"/assets/custom#data","content":"Data\\n\\nSwiftUI Player relies on assets decoding data that conforms to AssetData, this is necessary, because id and type are needed to determine what registered Swift type to decode to. You can include any decodable types in this struct as needed to match the structure of the asset that is returned from the core player.\\n\\nBeyond this, there are a few wrapper types that handle some player specific features:\\n","header":"Data","title":"Custom Assets"},"/assets/custom#modelreference":{"path":"/assets/custom#modelreference","content":"ModelReference\\n\\nModelReference is a wrapper that gets the raw JSValue from Player for a specific node in your asset data. This wrapper exists because if a reference to the data model is used in content, such as:\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"someId\\",\\n    \\"type\\": \\"text\\",\\n    \\"value\\": \\"{{count}}\\"\\n  }\\n}\\n\\nWhile count will not necessarily be a string, in the underlying JavaScript layer, if the entire string value is just a reference to the data model, it is replaced with the exact value from the data model. This means that if count is a number in the data model, when you receive it in the swift layer it will be an Int. So ModelReference gives you a quick helper to get it as a string:\\n\\nstruct TextData: AssetData {\\n  var id: String\\n  var type: String\\n  var value: ModelReference\\n}\\n...\\ntextData.value.stringValue\\n\\nYou can also access someModelReference.rawValue if you need to access the underlying JSValue for some other casting.\\n","header":"ModelReference","title":"Custom Assets"},"/assets/custom#wrappedfunction":{"path":"/assets/custom#wrappedfunction","content":"WrappedFunction\\n\\nJavaScript plugins loaded into the core player, when you have a plugin that extends JSBasePlugin, can transform the resolved asset before it reaches the Swift layer. In many situations, this results in functions being added to an asset to ensure that the same functionality is used on all platforms, and reduce code duplication. WrappedFunction gives you a light wrapper to help decode and call those functions. It takes generic parameter that defines the return type of the function:\\n\\nstruct ActionData: AssetData {\\n  var id: String\\n  var type: String\\n  var run: WrappedFunction\\n}\\n\\n// You can pass any number of arguments to the function\\n// so it\'s important to know what the transform added function\\n// expects\\n\\ndata.run()\\ndata.run(\\"arg1\\", 2)\\n","header":"WrappedFunction","title":"Custom Assets"},"/assets/custom#wrappedasset":{"path":"/assets/custom#wrappedasset","content":"WrappedAsset\\n\\nLast but not least, WrappedAsset represents another asset being defined as a part of this asset. This will be a very common pattern as Player content is intended to be semantic and dynamic. Therefore we need to know that there is an asset in our data, but not what it is, as the implementation is not guaranteed.\\n\\nstruct ActionData: AssetData {\\n  var id: String\\n  var type: String\\n  var label: WrappedAsset\\n  var run: WrappedFunction\\n}\\n\\nRendering these nested assets will be described below.\\n","header":"WrappedAsset","title":"Custom Assets"},"/assets/custom#view":{"path":"/assets/custom#view","content":"View\\n\\nThe view for a SwiftUI Asset is a regular SwiftUI View. Any standard SwiftUI components and concepts will work as normal. The only differentiating factor when it comes to Player assets, is the WrappedAsset and rendering it. WrappedAsset contains a SwiftUIAsset?, so in the event it was not decodable, it will be nil, otherwise, you can access it\'s view property to get a type-erased AnyView and render it in your view:\\n\\nstruct ActionView: View {\\n  var body: some View {\\n    Button(action: {}, label: {\\n      if let label = decodedAssetData.label.asset {\\n        label.view\\n      }\\n    })\\n  }\\n}\\n","header":"View","title":"Custom Assets"},"/assets/custom#asset":{"path":"/assets/custom#asset","content":"Asset\\n\\nThe SwiftUIAsset is the glue between the View and the Data. Player will handle decoding data, and updating the data in an ObservableObject viewModel that contains the Data you tell it to decode.\\n","header":"Asset","title":"Custom Assets"},"/assets/custom#uncontrolledasset":{"path":"/assets/custom#uncontrolledasset","content":"UncontrolledAsset\\n\\nThe UncontrolledAsset is uncontrolled because you do not specify a viewModel type, and receive an implicit AssetViewModel.\\n\\nclass ActionAsset: UncontrolledAsset {\\n    // Populated for you, but copied here for reference\\n    @ObservedObject var model: AssetViewModel\\n}\\n","header":"UncontrolledAsset","title":"Custom Assets"},"/assets/custom#controlledasset":{"path":"/assets/custom#controlledasset","content":"ControlledAsset\\n\\nThe ControlledAsset lets you define the viewModel type, as long as it subclasses AssetViewModel, this way you still receive updated data and user info whenever Player changes state, but you can add other functionality to the viewModel.\\n\\nclass ActionViewModel: AssetViewModel {\\n    public required init(_ data: ActionData, userInfo: [CodingUserInfoKey: Any]) {\\n      super.init(data, userInfo: userInfo)\\n    }\\n}\\nclass ActionAsset: ControlledAsset {\\n    // Populated for you, but copied here for reference\\n    @ObservedObject var model: ActionViewModel\\n}\\n","header":"ControlledAsset","title":"Custom Assets"},"/assets/custom#linking-the-view":{"path":"/assets/custom#linking-the-view","content":"Linking the View\\n\\nIn either situation, your asset implementation needs only to override the view property and return the type erased view you want to use.\\n\\nclass ActionAsset: UncontrolledAsset {\\n\\t\\tpublic override var view: AnyView { ActionView(model: model) }\\n}\\n","header":"Linking the View","title":"Custom Assets"},"/assets/custom#additional-topics":{"path":"/assets/custom#additional-topics","content":"Additional Topics\\n\\n","header":"Additional Topics","title":"Custom Assets"},"/assets/custom#interacting-with-the-data-model-without-a-transform":{"path":"/assets/custom#interacting-with-the-data-model-without-a-transform","content":"Interacting with the Data Model without a transform\\n\\nIf data needs to be set or retrieved without the use of a transform, the InProgressState is available in an environment object, where the DataController can be accessed, as well as other utilities:\\n\\nstruct SomeView: View {\\n  @Environment(\\\\.inProgressState) var state: InProgressState?\\n  var body: some View {\\n    Button(action: {\\n      state?.controllers?.data.set([\\"count\\": 5])\\n    }, label: {...})\\n  }\\n}\\n\\nIf your experience will be used on multiple platforms, it is not advised to use this method, a transform will ensure the same logic is followed on all 3 platforms and is strongly encouraged.\\n","header":"Interacting with the Data Model without a transform","title":"Custom Assets"},"/assets/custom#registering-your-asset":{"path":"/assets/custom#registering-your-asset","content":"Registering your Asset\\n\\nWhen registering your asset with an AssetRegistry, it can either be registered as a new type, if it is an entirely new construct, or registered as a variant of an existing asset type, to only be rendered under certain conditions.\\n\\n// Convenience function for just registering for type\\nplayer.assetRegistry.register(\\"example\\", asset: ExampleAsset.self)\\n\\nplayer.assetRegistry.register([\\"type\\": \\"example\\", \\"metaData\\": [\\"role\\": \\"someRole\\"]], for: ExampleAsset.self)\\n\\nIn the latter case, it is recommended to extend the original asset, so as to avoid boilerplate for data and construction, and just override the render function. If your variant will have additional data decoded that the original asset does not have, you will need to create the whole asset.\\n","header":"Registering your Asset","title":"Custom Assets"},"/assets/custom#why-would-i-register-my-asset-as-a-variant":{"path":"/assets/custom#why-would-i-register-my-asset-as-a-variant","content":"Why Would I Register my Asset as a Variant?\\n\\nTransform backed assets have functions that are attached to them, through shared JavaScript plugins. This simplifies setting data from the asset, by giving simple functions like run in the reference ActionAsset for example. Swift only asset types will not have any convenience functions.\\n\\nRegistering as a variant allows you to maintain usage of the transform backed asset as well as your new asset, so both can be used by the same SwiftUIPlayer instance, including in the same flow. This also maintains the semantics of Player content, an action asset is always an action type of interaction, but with metaData, it can be displayed differently.\\n","header":"Why Would I Register my Asset as a Variant?","title":"Custom Assets"},"/assets/custom#android":{"path":"/assets/custom#android","content":"Android\\n\\nIn order to render an asset a renderer for that type must be registered in the Android Player. If a renderer is found, then Player will delegate rendering when that type is encountered, otherwise Player will skip that node. Creating and registering such a renderer requires the following:\\n\\nExtending DecodableAsset\\n    Implementing initView and hydrate\\n    Define data structure\\n    Nested assets\\n    Styling\\nRegistering assets\\n","header":"Android","title":"Custom Assets"},"/assets/custom#extending-decodableasset":{"path":"/assets/custom#extending-decodableasset","content":"Extending DecodableAsset\\n\\n\\nDecodableAsset is a subclass of RenderableAsset that contains data decoding capabilities built on Kotlinx Serialization. This is the recommended approach for creating an asset and will be consolidated with RenderableAsset in future versions of the Android Player. On top of the requirements for subclassing RenderableAsset, subclassing DecodableAsset requires passing a KSerializer for the data class that represents the data for that asset.\\n\\nRenderableAsset is the base structure used by Player to convert parsed content into Android Views. Each implementation is instantiated with an AssetContext and is required to implement two methods, initView and hydrate. The separation of logic between these two methods allow for views to be cached and optimize the render process. However, both of these methods are only used internally via the render method. render is the main entry point for getting the Android view representation of that asset. It automatically handles the caching and hydration optimizations, only rebuilding and rehydrating when a dependency has changed. The caller would be responsible for handling that view (i.e. injecting it into a ViewGroup).\\n\\nThe RenderableAsset instance is not guaranteed, meaning that state maintained within a RenderableAsset may not persist between initView and hydrate calls. If state is required, that can be accomplished by creating a custom View.\\n\\nSome asset implementations may encounter a situation where the cached view is no longer the corresponding representation of the asset. Under this circumstance, the asset can request a full re-render by calling invalidateView from any point in the hydration context.\\n","header":"Extending DecodableAsset","title":"Custom Assets"},"/assets/custom#implementing-initview":{"path":"/assets/custom#implementing-initview","content":"Implementing initView\\n\\nfun initView(): View\\n\\nThe only goal of initView is to build an Android View. This can be done through inflation, programmatic building, or some framework, as long as the View that is returned represents the corresponding asset. Top-level view creation and any one-time configuration operations should be done in this step. It is best practice to ensure that any access of the asset model is not done in this phase, as initView is not guaranteed to be called if the data changes.\\n","header":"Implementing initView","title":"Custom Assets"},"/assets/custom#implementing-hydrate":{"path":"/assets/custom#implementing-hydrate","content":"Implementing hydrate\\n\\nfun View.hydrate()\\n\\nHydration is the process responsible for populating the view with the data from the asset model. Any dependencies on the data model should be handled in this step. This includes accessing data, transform functions, or even nested assets. Any views created in hydrate will not be automatically cached, but will persist on the UI unless explicitly removed. It is necessary to be vigilant when constructing and removing these views.\\n","header":"Implementing hydrate","title":"Custom Assets"},"/assets/custom#accessing-data":{"path":"/assets/custom#accessing-data","content":"Accessing Data\\n\\nIn most cases, there is some additional data that is used to make the rendering more meaningful. For instance, the intent of the previous text asset example was to render a View that displayed the string contained in value. Access to such data will be provided through a data member on the DecodableAsset. This data member is a type specified when defining the subclass.\\n\\nclass TextAsset(assetContext: AssetContext) : DecodableAsset(Data.serializer()) {\\n\\n    @Serializable\\n    data class Data(\\n       val value: String\\n    )\\n\\n}\\n\\nWith this defined, the data can be accessed as an instance of TextAsset.Data. It\'s important to note that if value isn\'t defined in the content, this will cause a crash because there isn\'t a default value provided. If you have optional fields, make sure the data class is structured appropriately:\\n\\n@Serializable\\ndata class Data(\\n   val value: String? = null\\n)\\n\\nAs a fallback, data can still be accessed via the Asset instance attached to the AssetContext. The Asset instance is a link into the underlying asset node, which provides a set of getter methods to retrieve data.\\n\\n// type specific getters should throw an error if the type doesn\'t conform\\n// although, in some cases, the getter may just return null\\nval stringToRender: String = asset.getString(\\"value\\")\\n","header":"Accessing Data","title":"Custom Assets"},"/assets/custom#nested-assets":{"path":"/assets/custom#nested-assets","content":"Nested assets\\n\\n// ...\\n{\\n    \\"id\\": \\"some-card\\",\\n    \\"type\\": \\"card\\",\\n    \\"title\\": {\\n        \\"asset\\": {\\n            \\"id\\": \\"some-text\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"This is a text asset\\"\\n        }\\n    }\\n}\\n// ...\\n\\nCompound assets can be defined such that the asset model contains child assets. These child assets must be wrapped in an asset object. In the example above, there is an card asset that delegates to a text asset to render a title. The child asset can be directly described as a RenderableAsset in the data class.\\n\\n@Serializable\\ndata class Data(\\n   val title: RenderableAsset? = null\\n)\\n\\nA helper is provided to reduce overhead with rendering an asset into a layout. into will show or hide the target ViewGroup based on whether the View is null.\\n\\n// title_container is a view extension referencing a FrameLayout in an XML layout\\ndata.title.render() into title_container\\n","header":"Nested assets","title":"Custom Assets"},"/assets/custom#styling":{"path":"/assets/custom#styling","content":"Styling\\n\\nStyling can be done completely independently, but the API is designed such that render can accept any number of style resources. This allows parent assets to declare any styles that they\'d like the child asset to use. These styles are automatically overlaid onto the current Android Context.\\n\\nIn the above card asset example, the card may want to set some text styles to make any text that\'s rendered look like a title (i.e. bold, larger, etc).\\n\\n// from the card render\\n// assuming that R.style.Text_Title defines these text styles\\nval title: View = data.title.render(R.style.Text_Title)\\n// the above is shorthand for:\\nval title: View = data.title.withStyles(R.style.Text_Title).render()\\n\\n// from the text render\\n// create TextView with the styled context\\nfun initView() = TextView(context)\\n\\n// ensure that the provided view is a TextView and set the text accordingly\\n// otherwise, invalidate the view\\nfun View.hydrate() {\\n    when (this) {\\n        is TextView -> text = data.value\\n        else -> invalidateView()\\n    }\\n}\\n","header":"Styling","title":"Custom Assets"},"/assets/custom#registering-assets":{"path":"/assets/custom#registering-assets","content":"Registering assets\\n\\nRegistering assets is done in the AndroidPlayerPlugin. Each plugin only needs to implement an apply method which gives the plugin the opportunity to supplement core player functionality. The AndroidPlayer instance contains an asset registry where assets should be register. A helper method has been created to make registration as simple as providing the type and a factory. The factory method must take an AssetContext, and is recommended to just be the constructor of your asset.\\n\\n// registering \\"some-asset\\" with SomeAsset constructor\\nandroidPlayer.registerAsset(\\"some-asset\\", ::SomeAsset)\\n","header":"Registering assets","title":"Custom Assets"},"/assets":{"path":"/assets","content":"\\n\\n","title":"Assets"},"/assets#assets":{"path":"/assets#assets","content":"Assets\\n\\nAn asset is a generic term given to a semantic bit of information that we wish to convey to the user. Assets are the backbone that make up the content that Player renders. Though there are many different types of assets, they all follow the same basic principles:\\n\\nAssets are uniquely identified within their view\\nAssets are semantically meaningful in and of themselves, not relying on any other asset to have meaning\\n\\nIn some cases assets will contain other assets, however the contained assets can also stand on their own. If a complex asset requires information that is specific to itself, then that information is expressed as an object, not an asset.\\n","header":"Assets","title":"Assets"},"/assets#building-blocks-of-assets":{"path":"/assets#building-blocks-of-assets","content":"Building Blocks of Assets\\n\\nThere are a few key components that make up an asset:\\n\\nHow it is described in the source content\\nHow it interacts with Player\\nHow it should render\\n\\nAsset Parts\\n\\nWith few exceptions, an asset requires all three of these to be defined to fully function.\\n","header":"Building Blocks of Assets","title":"Assets"},"/assets#json-contract":{"path":"/assets#json-contract","content":"JSON Contract\\n\\nThe schema of an asset describes the contract between the input content (what user\'s will ultimately author) and your asset. These are often described through interfaces extending the base Asset interface, which can take advantage of the language or validator tooling.\\n","header":"JSON Contract","title":"Assets"},"/assets#data-interaction":{"path":"/assets#data-interaction","content":"Data Interaction\\n\\nThe next logical step is the contract between Player (it\'s data-model, validation rules, etc.) and an instance of an asset in a view. These are described through transform functions, which are stateless mapping functions orchestrated during the view reconciliation processing. You can read more about asset transforms here\\n","header":"Data Interaction","title":"Assets"},"/assets#ui-rendering":{"path":"/assets#ui-rendering","content":"UI Rendering\\n\\nThe last step of the puzzle is how the asset is physically displayed to a user. Given the output of the transform, it presents the user with data to display, or an interactive element to capture a response. Unlike the first 2 parts, the rendering is platform dependent and requires an implementation for each platform you\'re using Player with.\\n","header":"UI Rendering","title":"Assets"},"/assets/reference":{"path":"/assets/reference","content":"\\n\\n","title":"Reference Assets"},"/assets/reference#reference-assets":{"path":"/assets/reference#reference-assets","content":"Reference Assets\\n\\nTo help users get started with Player, we have created a minimal set of useable assets for React, iOS and Android. These reference assets showcase the design philosophy we encourage when building your own asset sets. While these components are functional we do not recommend shipping them to production as they have not been tested to be production ready.\\n","header":"Reference Assets","title":"Reference Assets"},"/assets/reference#react":{"path":"/assets/reference#react","content":"React\\n\\nFor the React Player, we ship a package (@player-ui/reference-assets-plugin-react) that provides the reference set of assets. Each asset package exposes a Component, type, and optional transform. They also export hooks for easily consuming the transformed component and supplying your own UI for a custom look and feel. These components are all then exposed via a plugin that can be added to Player like so:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { ReferenceAssetsPlugin } from \'@player-ui/reference-assets-plugin-react\';\\n\\nconst reactPlayer = new ReactPlayer({\\n  plugins: [new ReferenceAssetsPlugin()],\\n});\\n","header":"React","title":"Reference Assets"},"/assets/reference#storybook":{"path":"/assets/reference#storybook","content":"Storybook\\n\\nThe reference assets + React player can be viewed in Storybook\\n","header":"Storybook","title":"Reference Assets"},"/assets/reference#ios":{"path":"/assets/reference#ios","content":"iOS\\n\\nAlongside distributing the PlayerUI pod, there is a PlayerUI/ReferenceAssets subspec used as examples of how Player APIs work for building assets. This pod uses the shared TypeScript transform functions that the React and Android players use for their reference assets, ensuring consistent behavior across platforms. These assets can be loaded into Player like so:\\n\\nimport PlayerUI\\n\\nstruct MyApp: View {\\n  @State var result: Result? = nil\\n  @ObservedObject var viewModel: MyViewModel\\n  var body: some View {\\n    SwiftUIPlayer(\\n      flow: $viewModel.flowString,\\n      plugins: [ReferenceAssetsPlugin()],\\n      result: $result\\n    )\\n  }\\n}\\n","header":"iOS","title":"Reference Assets"},"/assets/transforms":{"path":"/assets/transforms","content":"\\n\\n","title":"Transforms"},"/assets/transforms#assets-and-transforms":{"path":"/assets/transforms#assets-and-transforms","content":"Assets and Transforms\\n\\nThis guide will walk through a few of the core concepts of assets, transforms and how they come together with the UI to create an experience.\\n\\nYou can read more about what an asset is here. In short:\\n\\n> An asset is a generic term given to a semantic bit of information that we wish to convey to the user. Assets are the primitive elements that make up the content that players present as user experiences.\\n\\nFor all intents and purposes, views are equivalent to assets for this guide.\\n","header":"Assets and Transforms","title":"Transforms"},"/assets/transforms#assets-and-the-ui":{"path":"/assets/transforms#assets-and-the-ui","content":"Assets and the UI\\n\\nIn general, the pipeline for user-content is something like:\\n\\nSimple Asset Pipeline\\n\\nPlayer will do minimal processing of each asset in the tree, resolving data in strings, applicability and any other generic processing it can. The processed tree is then sent to the rendering layer, where it is turned into a native component on the system Player is running on.\\n\\nFor simple Assets, like text, there\'s no need for any asset specific processing. The output of Player is enough to successfully render and display the content to the user.\\n\\nAsset Without Transform\\n","header":"Assets and the UI","title":"Transforms"},"/content/assets-views":{"path":"/content/assets-views","content":"\\n\\n","title":"Assets & Views"},"/content/assets-views#assets":{"path":"/content/assets-views#assets","content":"Assets\\n\\nAn asset is a generic term given to a semantic bit of information that we wish to convey to the user. Assets are the primitive elements that make up the content Player presents as user experiences. Though there are many different types of assets, they all follow the same basic principles:\\n\\nassets are uniquely identified within their view\\nassets are semantically meaningful in and of themselves, not relying on any other asset to have meaning\\n\\nIn some cases assets will contain other assets, however the contained assets can also stand on their own. If a complex asset requires information that is specific to itself, then that information is expressed as an object, not an asset.\\n\\nEach asset must have 2 properties: an id and type:\\n\\nid - Unique ID for the asset. It must be unique per view.\\ntype - A descriptive name for the asset type. This is used for handling rendering and transforms.\\n\\nNested assets are represented as objects containing an asset property. For example:\\n\\n{\\n  \\"id\\": \\"parent\\",\\n  \\"type\\": \\"parent\\",\\n  \\"label\\": {\\n    \\"asset\\": {\\n      \\"id\\": \\"child-asset\\",\\n      \\"type\\": \\"child\\"\\n    }\\n  }\\n}\\n\\nThe label of the parent contains a nested asset reference. These are slots that can usually contain any asset type.\\n","header":"Assets","title":"Assets & Views"},"/content/assets-views#applicability":{"path":"/content/assets-views#applicability","content":"Applicability\\n\\nAny object in the tree (including assets) may contain an applicability property. This is an expression that may conditionally show or hide an asset (and all of it\'s children) from the view tree. Applicability is dynamically calculated and will automatically update as data changes on the page.\\n","header":"Applicability","title":"Assets & Views"},"/content/assets-views#views":{"path":"/content/assets-views#views","content":"Views\\n\\nViews are assets that exist at the top level of the tree. They typically include the navigation actions, a title, or other top-level information.\\n\\nThe id of the views are used in the navigation section to reference a specific view from the list.\\n","header":"Views","title":"Assets & Views"},"/content/data-expressions":{"path":"/content/data-expressions","content":"\\n\\n","title":"Data & Expressions"},"/content/data-expressions#data":{"path":"/content/data-expressions#data","content":"Data\\n\\nData is central to a lot of the functionality and features of Player. The easiest way to deal with data is to supply it in the initial payload when starting a flow. This will seed the model with data and allow you to easily reference values\\n","header":"Data","title":"Data & Expressions"},"/content/data-expressions#bindings":{"path":"/content/data-expressions#bindings","content":"Bindings\\n\\nA binding is a representation of a path within the data-model. In simple terms, it\'s a dot (.) separated string showing the path of the properties within the data object.\\n\\nGiven the following data model:\\n\\ndata: {\\n  foo: {\\n    bar: {\\n      baz: \\"hello world!\\"\\n    },\\n    array: [\\n      {\\n        property: \\"another value\\"\\n      }\\n    ]\\n  },\\n}\\n\\nThen the binding foo.bar.baz will reference the value \\"hello world!\\". Assets that write data to the data model would overwrite \\"hello world\\" when setting to that binding. Using brackets instead of the dot-notation is accepted, similar to accessig properties in real Javascript objects. Unlike Javascript, when using the bracket-notation, surrounding quotes are only required if you need a literal [ or ] in your property name.\\n\\nThe following bindings are all equivalent:\\n\\nfoo.bar.baz\\nfoo\'bar\'\\nfoo[bar].baz\\n\\nFor most bindings, it is recommended to use the dot-notation for all properties when possible. Doing so is consistent, simpler, and the most performant.\\n\\nNote that you can also use integers to access into arrays in the data model. foo.bar.array.0.property will reference \\"another value\\".\\n","header":"Bindings","title":"Data & Expressions"},"/content/data-expressions#query-syntax":{"path":"/content/data-expressions#query-syntax","content":"Query Syntax\\n\\nBindings also allow for query access into arrays using a key/value pair to find the first matching item in the array.\\n\\nThe query syntax takes the form array[key=value]. Where key is the property name you want to compare and value is the value you want to match against. The binding resolves to the first item in the array that has a matching property and value.\\n\\ndata: {\\n  model: {\\n    array: [\\n      {\\n        name: \'alpha\',\\n        foo: \'bar\',\\n      },\\n      {\\n        name: \'bravo\',\\n        foo: \'baz\',\\n      },\\n      {\\n        name: \'charlie\',\\n        foo: \'qux\',\\n      },\\n    ];\\n  }\\n}\\n\\nFor the given data, the following bindings are all equivalent and will point to the first element in the array:\\n\\nmodel.array[0]\\nmodel.array[name=\\"alpha\\"]\\nmodel.array[foo=\\"bar\\"]\\n\\nQuotes around the key or the value of the query are only required when needing to use ambiguous literal characters, such as [, ], or =.\\n\\nNote that the query syntax resolves to the object of the matching query, not to any specific property on the object. If you want to access a specific property, add additional path information after the query. E.g., model.array[name=bravo].name.\\n","header":"Query Syntax","title":"Data & Expressions"},"/content/data-expressions#nested-bindings":{"path":"/content/data-expressions#nested-bindings","content":"Nested Bindings\\n\\nNested bindings allow you to construct a binding path that is relative to a 2nd path or based on some dynamic property. This behavior follows similar model lookup rules that can be used elsewhere in Player.\\n\\nThe syntax for a nested binding is a subpath that is wrapped in double curly braces. E.g., normal.path.{{nested.path}}.more.normal.path.\\n\\ndata: {\\n  colors: {\\n    yellow: {\\n      hex: \\"#ffff00\\"\\n      rgb: \\"rgb(255, 255, 0)\\"\\n    },\\n    red: {\\n      hex: \\"#ff0000\\",\\n      rgb: \\"rgb(255, 0, 0)\\"\\n    }\\n  },\\n  favorites: {\\n    color: \\"yellow\\",\\n    food: \\"tacos\\",\\n    nestedPath: \\"colors.yellow\\"\\n  }\\n}\\n\\nWith this data model, colors.{{favorite.color}}.hex will return the hex value for yellow, \\"#ffff00\\". Any syntax for a regular binding is also valid as part of a nested binding, including further nesting.\\n\\nReferences to bindings that contains sub-paths {{favorite.nestedPath}}.hex will expand to colors.yellow.hex.\\n","header":"Nested Bindings","title":"Data & Expressions"},"/content/data-expressions#nested-expressions":{"path":"/content/data-expressions#nested-expressions","content":"Nested Expressions\\n\\nJust like binding segments can contain other bindings, segments can also contain expressions. For this, they use a segment surrounded by `:\\n\\nSuppose there exists a getFavoriteColor() expression that returns yellow. The following path would resolve to colors.yellow.hex.\\n\\ncolors.getFavoriteColor().hex\\n\\nSimilar to the bracket notation: []. Paths can use brackets instead of dots for paths:\\n\\ncolors[getFavoriteColor()].hex\\n","header":"Nested Expressions","title":"Data & Expressions"},"/content/data-expressions#expressions":{"path":"/content/data-expressions#expressions","content":"Expressions\\n\\nExpressions are callable functions that allow for dynamic behavior of Player and it\'s views.\\n\\nThese functions can be used in ACTION nodes in the navigation section, calculated values in a property of an asset, or anywhere else expressions are valid.\\n\\nCheck out the Expression Plugin for registering custom functions.\\n","header":"Expressions","title":"Data & Expressions"},"/content/data-expressions#using-expressions-and-data-in-a-view":{"path":"/content/data-expressions#using-expressions-and-data-in-a-view","content":"Using Expressions and Data in a View\\n\\nExpressions in the view are strings wrapped in: @[ and ]@.\\n\\nFor instance, to call a sum expression you may use:\\n\\n{\\n  \\"value\\": \\"The sum is @[ sum(1, 2, 3) ]@ dollars\\"\\n}\\n\\nPlayer will handle resolving that value into the proper string before handing it to the UI layers to render. ({ \\"value\\": \\"The sum is 6 dollars\\" })\\n\\nIf an expression is the sole property value:\\n\\n{\\n  \\"value\\": \\"@[ sum(1, 2, 3) ]@\\"\\n}\\n\\nThe raw value of the expression will replace that property rather than being wrapped in a string: { \\"value\\": 6 }\\n\\nData is referenced by wrapping the binding in {{ and }}. This can be used in an expression: @[ {{foo.bar}} + {{foo.baz}} ]@ or within a string: { \\"value\\": \\"Hello {{foo.name}}\\" }\\n\\nSimilar to expressions, any property only consisting of a data value lookup, will get replaced by the raw value.\\n","header":"Using Expressions and Data in a View","title":"Data & Expressions"},"/content/data-expressions#using-expressions-for-inline-text-formatting":{"path":"/content/data-expressions#using-expressions-for-inline-text-formatting","content":"Using Expressions for Inline Text Formatting\\n\\nformat expression is used to replace provided value with appropriate format.\\nFor instance, to format a number into currency, you may use:\\n\\n{\\n  \\"value\\": \\"Total amount is: @[ format(\'12122016\', \'currency\') ]@\\"\\n}\\n\\nTo see the list of currently supported format types, check out Common Types Plugin.\\n","header":"Using Expressions for Inline Text Formatting","title":"Data & Expressions"},"/content/dsl":{"path":"/content/dsl","content":"\\n\\n","title":"TSX DSL"},"/content/dsl#tsxjsx-content-authoring":{"path":"/content/dsl#tsxjsx-content-authoring","content":"TSX/JSX Content Authoring\\n\\nWhile Player content can be written directly in JSON, it\'s not always the preferable authoring format. To take advantage of existing developer tool-chains, Player provides a mechanism for authoring content in (J/T)SX as React components. This is paired with a cli to transpile the React tree into a JSON content.\\n\\nOne thing to note is that the paths in the input folder should match the expected paths in your config file. E.g if the pages option is set to topics, the source TSX/JSX files should be under a topics directory in your input directory. Similarly if the schema option is set to topicschema.json the ts file containing the schema object should be in the root directory and named topicschema.ts.\\n","header":"TSX/JSX Content Authoring","title":"TSX DSL"},"/content/dsl#writing-jsx-content":{"path":"/content/dsl#writing-jsx-content","content":"Writing JSX Content\\n\\nIn order to use the JSX-variant to write content, your asset library should ship a JSX component package to leverage. These will define the primitive components to use to build up the tree.\\n\\nIn the examples below, we will assume one exists.\\n","header":"Writing JSX Content","title":"TSX DSL"},"/content/dsl#bindings-and-expressions":{"path":"/content/dsl#bindings-and-expressions","content":"Bindings and Expressions\\n\\nBoth binding and expression in the JSX authoring leverages a tagged template, typically abbreviated as b and e respectively. In a similar fashion to using css or graphql in a JS file, this enables syntax-highlighting and validation of bindings and expressions within a JS file.\\n\\nTo create a binding, or expression:\\n\\nimport { binding as b, expression as e } from \'@player-tools/dsl\';\\n\\nconst myBinding = bfoo.bar;\\nconst myExpression = efoo();\\n\\nThe binding and expression instances can also automatically dereference themselves when used inside of another string:\\n\\nconst stringWithBinding = Some text: ${myBinding}; // \'Some text: {{foo.bar}}\'\\nconst stringWithExp = Some expr: ${myExpression}; // \'Some expr: @[foo()]@\'\\n","header":"Bindings and Expressions","title":"TSX DSL"},"/content/dsl#assetsviews":{"path":"/content/dsl#assetsviews","content":"Assets/Views\\n\\nWriting assets or views is as simple as creating a React element:\\n\\nimport { Input, Text, Collection } from \'my-assets\';\\n\\nconst view = (\\n\\n    Some value\\n\\n      Some label\\n\\n);\\n\\nthis would generate something similar to:\\n\\n{\\n  \\"id\\": \\"root\\",\\n  \\"type\\": \\"collection\\",\\n  \\"values\\": [\\n    {\\n      \\"asset\\": {\\n        \\"id\\": \\"root-values-1\\",\\n        \\"type\\": \\"text\\",\\n        \\"value\\": \\"Some value\\"\\n      }\\n    },\\n    {\\n      \\"asset\\": {\\n        \\"id\\": \\"root-values-2\\",\\n        \\"type\\": \\"input\\",\\n        \\"label\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"root-values-2-label\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"Some label\\"\\n          }\\n        }\\n      }\\n    }\\n  ]\\n}\\n","header":"Assets/Views","title":"TSX DSL"},"/content/dsl#ids":{"path":"/content/dsl#ids","content":"IDs\\n\\nAny asset can accept an id property (just like the JSON version), however ids will automatically be generated for assets missing them.\\n","header":"IDs","title":"TSX DSL"},"/content/dsl#collectiontext-creation":{"path":"/content/dsl#collectiontext-creation","content":"Collection/Text Creation\\n\\nIn the event that an asset object is expected, but a string or number is found, Player will attempt to automatically create a text node, provided the asset-library has a text-asset-factory configured.\\n\\nSimilarly, if a single asset is expected but a list of them is found instead, Player will attempt to create a collection asset provided the library has the proper configuration set.\\n","header":"Collection/Text Creation","title":"TSX DSL"},"/content/dsl#templates":{"path":"/content/dsl#templates","content":"Templates\\n\\nTemplates are included via the @player-tools/dsl package. This can be used in any asset slot:\\n\\n      Template Value\\n\\n    Value 1\\n\\nTemplates can be nested within one another, and the auto-id generation will handle adding the index information to any generated id.\\n","header":"Templates","title":"TSX DSL"},"/content/dsl#switches":{"path":"/content/dsl#switches","content":"Switches\\n\\nThe @player-tools/dsl module also includes support for static and dynamic switches.\\n\\nUse the isDynamic flag to denote this should be a dynamicSwitch instead of a staticSwitch:\\n\\n        Text 1\\n\\n        Text 1\\n","header":"Switches","title":"TSX DSL"},"/content/dsl#navigation":{"path":"/content/dsl#navigation","content":"Navigation\\n\\nAt this time the navigation section is a basic JS object. The @player-ui/types package provides typescript typings for these.\\n\\nimport { Navigation, Schema } from \'@player-ui/types\';\\n\\nconst navigation: Navigation = {\\n  BEGIN: \'Start\',\\n  Start: {\\n    startState: \'VIEW_1\',\\n    VIEW_1: {\\n      state_type: \'VIEW\',\\n      ref: \'view-1\',\\n      transitions: {\\n        \'*\': \'END_Done\',\\n      },\\n    },\\n    END_Done: {\\n      state_type: \'END\',\\n      outcome: \'done\',\\n    },\\n  },\\n};\\n","header":"Navigation","title":"TSX DSL"},"/content/dsl#schema":{"path":"/content/dsl#schema","content":"Schema\\n\\nTo author a schema object you should first start by constructing a standard typescript object where the nested paths correlate to the paths on your desired schema. At the final conversion to a Player Schema object during the serialization phase the intermediate types and ROOT elements will automatically be constructed. A basic example would be:\\n\\nconst mySchema = {\\n  foo: {\\n    bar: {\\n      baz: //somevalue\\n      faz: //somevalue\\n    }\\n  }\\n}\\n\\nwhich correlates to a schema of:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"foo\\": {\\n      \\"type\\": \\"fooType\\"\\n    }\\n  },\\n  \\"fooType\\": {\\n    \\"bar\\": {\\n      \\"type\\": \\"barType\\"\\n    }\\n  },\\n  \\"barType\\": {\\n    \\"baz\\": {\\n      \\"type\\": \\"\\"\\n    },\\n    \\"faz\\": {\\n      \\"type\\": \\"\\"\\n    }\\n  }\\n}\\n","header":"Schema","title":"TSX DSL"},"/content/dsl#arrays":{"path":"/content/dsl#arrays","content":"Arrays\\n\\nA single object array can be used to indicate an array type, for example:\\n\\nconst mySchema = {\\n  foo: [\\n    {\\n      bar: //some type\\n    }\\n  ]\\n}\\n\\nwill generate the schema:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"foo\\": {\\n      \\"type\\": \\"fooType\\",\\n      \\"isArray\\": true\\n    }\\n  },\\n  \\"fooType\\": {\\n    \\"bar\\": {\\n      \\"type\\": \\"barType\\"\\n    }\\n  },\\n  \\"barType\\": {\\n    \\"baz\\": {\\n      \\"type\\": \\"\\"\\n    },\\n    \\"faz\\": {\\n      \\"type\\": \\"\\"\\n    }\\n  }\\n}\\n","header":"Arrays","title":"TSX DSL"},"/content/dsl#changing-the-name-of-a-generated-type":{"path":"/content/dsl#changing-the-name-of-a-generated-type","content":"Changing the Name of a Generated Type\\n\\nTo change the name of the generated type at any point in the tree, import the SchemaTypeName symbol from the @player-tools/dsl and use it as a key to change the name like so:\\n\\nconst mySchema = {\\n  foo: {\\n    bar: {\\n      [SchemaTypeName]: \\"buzz\\",\\n      baz: //somevalue\\n      faz: //somevalue\\n    }\\n  }\\n}\\n","header":"Changing the Name of a Generated Type","title":"TSX DSL"},"/content/dsl#defining-data-types":{"path":"/content/dsl#defining-data-types","content":"Defining Data Types\\n\\nThe leaf nodes of the data structure will need some concrete definition of what data exists at that point of the schema. There are two ways to provide this data.\\n","header":"Defining Data Types","title":"TSX DSL"},"/content/dsl#data-refs":{"path":"/content/dsl#data-refs","content":"Data Refs\\n\\nThe common-types-plugin package exposes the types it provides to Player when used and references to those types as well. Using these Language.DataTypeRef values you can indicate what the data type will be at that node and that it will be a type explicitly defined in the Player so no additional information needs to be provided (e.g. validations nor formats)\\n\\nVarious plugins in the @cg-player scope also expose similar DataTypeRef objects that include common tax types. For convenience the @cg-player/components package reexports all the data references for one convenient import. It is important to note that there will be an issue if you use a DataTypeRef from a plugin but run the content in a Player that doesn\'t have that plugin loaded.\\n","header":"Data Refs","title":"TSX DSL"},"/content/dsl#local-data-types":{"path":"/content/dsl#local-data-types","content":"Local Data Types\\n\\nSometimes you need to define specific data types that extend existing types for certain pieces of data in a schema, whether that be for specific validations, formatting or both. In this case, in your DSL project you can define an object of type Schema.DataType and provide that value to a leaf node. That will indicate that this unique type needs to be included in its entirety to Player as it has information not already contained in Player.\\n","header":"Local Data Types","title":"TSX DSL"},"/content/dsl#what-that-looks-like":{"path":"/content/dsl#what-that-looks-like","content":"What that Looks Like\\n\\nUsing our previous example we can fill in the values with some types now to look like this in the ts object:\\n\\nimport { Schema, BooleanTypeRef } from \'@player-ui/types\'\\n\\nconst mycustombooleantype: Schema.DataType = {\\n  type: \\"BooleanType\\",\\n  validation: [\\n    {\\n      type: \'oneOf\',\\n      message: \'Value has to be true or false\',\\n      options: [true, false],\\n    },\\n  ],\\n}\\n\\nconst mySchema = {\\n  foo: {\\n    bar: {\\n      baz: BooleanTypeRef\\n      faz: mycustombooleantype\\n    }\\n  }\\n}\\n\\nexport default mySchema\\n\\nand like this in the final schema:\\n\\n{\\n  \\"ROOT\\":{\\n    \\"foo\\":{\\n      \\"type\\": \\"fooType\\"\\n    }\\n  },\\n  \\"fooType\\":{\\n    \\"bar\\": {\\n      \\"type\\":\\"barType\\"\\n    }\\n  },\\n  \\"barType\\":{\\n    \\"baz\\":{\\n      \\"type\\": \\"BooleanType\\"\\n    },\\n    \\"faz\\":{\\n      \\"type\\": \\"BooleanType\\",\\n      \\"validation\\": [\\n        {\\n          \\"type\\": \\"oneOf\\",\\n          \\"message\\": \\"Value has to be true or false\\",\\n          \\"options\\": [true, false],\\n        },\\n      ],\\n    }\\n  }\\n}\\n\\nIt should be noted that unless the schema object is a default export the schema.json will not be created in the output folder.\\n","header":"What that Looks Like","title":"TSX DSL"},"/content/dsl#using-the-schema-object-in-jsxtsx-content":{"path":"/content/dsl#using-the-schema-object-in-jsxtsx-content","content":"Using the Schema Object in JSX/TSX Content\\n\\nThere is one important function that enables us to use our schema object in content.makeBindingsForObject() takes your schema object and constructs the bindings opaquely so that you can use the native object path with functions like .toString(), .toValue(), and toRefString() like you could with regular string template bindings.\\n\\nUsing these functions we can use the schema directly in content:\\n\\nconst schema = makeBindings(mySchema)\\n\\nconst baz = schema.foo.bar.baz\\n\\nconst view = (\\n\\n        The current value is {baz.toString()}\\n\\n)\\n\\nconst validations = [\\n  {\\n    type: \\"requiredIf\\",\\n    ref: baz.toRefString(),\\n    message: \\"This is required\\",\\n  },\\n];\\n\\nconst navigation = {...}\\n\\nexport default {\\n  id: \\"example-topic\\",\\n  topic: \\"exampletopic\\",\\n  views: [view],\\n  navigation,\\n};\\n","header":"Using the Schema Object in JSX/TSX Content","title":"TSX DSL"},"/content":{"path":"/content","content":"\\n\\n","title":"Content"},"/content#content":{"path":"/content#content","content":"Content\\n\\nPlayer is driven off of JSON content that describes the user interactions. It mainly consists of a state-machine, some views to drive display, data, and a schema. Player, once started with the JSON content, will play the flow until it reaches a terminal state in the state-machine, and return the outcome, data, and other relevant information about the flow\'s execution.\\n\\nThe structure of the JSON payload is described below.\\n","header":"Content","title":"Content"},"/content#structure":{"path":"/content#structure","content":"Structure\\n\\nThe high level JSON payload for Player to render consists of: id, views, data, schema, navigation\\n\\nid - (required) - A string that identifies the payload.\\n\\ndata - (optional) - A JSON object that contains data you can reference in the navigation or views section.\\n\\nschema - (optional) - A schema that describes the structure of the data model, including default values, validation rules, etc.\\n\\nviews - (optional) - The views section is an array of assets that are meant to display pages to the user. These can be referenced by ID in the navigation section, and can transition between states in the state machine. Assets are typically semantic in nature, as they are used to render content with dissimilar UIs depending on the context of the user.\\n\\nnavigation - (required) - The navigation section describes a finite state machine that is responsible driving the core Player experience. The nodes can either be: VIEW, ACTION, EXTERNAL, or FLOW\\n","header":"Structure","title":"Content"},"/content/navigation":{"path":"/content/navigation","content":"\\n\\n","title":"Navigation"},"/content/navigation#navigation":{"path":"/content/navigation#navigation","content":"Navigation\\n\\nThe navigation section of the content describes the path the user goes through as they progress. In simple terms, this can be thought of as a set of finite state machines, and the user progresses through each state until they hit a DONE node.\\n\\nThe navigation object contains a BEGIN property that contains a reference to a flow to start Player with. Once an end state is reached for that flow, Player will end its processing and return that outcome.\\n","header":"Navigation","title":"Navigation"},"/content/navigation#flows":{"path":"/content/navigation#flows","content":"Flows\\n\\nFlows are a state machine with 1 start state and at least 1 end state. The nodes are processed in order until an end state is reached. The flow that initiated Player (the BEGIN reference) will be executed until its END state is reached.\\n\\nFlows can also contain an onStart or onEnd property which is an expression that will be evaluated before processing of the first start state takes place, or just prior to ending the flow.\\n","header":"Flows","title":"Navigation"},"/content/navigation#navigation-state-types":{"path":"/content/navigation#navigation-state-types","content":"Navigation State Types\\n\\nThere are a few main navigation state types defined. Each has a slightly different interaction with how it progresses to the end.\\n\\nAll state types (except the END node) contain a transitions property. This is an object describing the relationship on how to proceed to the next node. The key is the name of the transition that is performed, the value is the name of the state to transition to. A key of * can be used as a fallback for any transition value given that doesn\'t match a pre-defined one.\\n","header":"Navigation State Types","title":"Navigation"},"/content/navigation#view":{"path":"/content/navigation#view","content":"VIEW\\n\\nThe view node is the simplest and most widely used. It supports transitions and contains a ref property that corresponds with an id of the view in the views array.\\n\\n{\\n  \\"state_type\\": \\"VIEW\\",\\n  \\"ref\\": \\"view-1\\",\\n  \\"transitions\\": {\\n    \\"next\\": \\"VIEW_2\\"\\n  }\\n}\\n","header":"VIEW","title":"Navigation"},"/content/navigation#action":{"path":"/content/navigation#action","content":"ACTION\\n\\nAn action node allows users to evaluate one of more expressions before proceeding to the next node. The value of the expression (the last value is used if the expression is an array), as the transition value to the next node:\\n\\n{\\n  \\"state_type\\": \\"ACTION\\",\\n  \\"exp\\": [\\"{{foo.value}} = 1 + 2\\", \\"{{foo.value}} > 0\\"],\\n  \\"transitions\\": {\\n    \\"true\\": \\"VIEW_1\\",\\n    \\"false\\": \\"VIEW_2\\"\\n  }\\n}\\n","header":"ACTION","title":"Navigation"},"/content/navigation#end":{"path":"/content/navigation#end","content":"END\\n\\nThe end state represents a completion of a flow. It contains an optional outcome property that can describe the circumstance for ending the flow. No transition state exists as this marks the completion of the flow.\\n\\n{\\n  \\"state_type\\": \\"END\\",\\n  \\"outcome\\": \\"Done_FWD\\"\\n}\\n","header":"END","title":"Navigation"},"/content/navigation#external":{"path":"/content/navigation#external","content":"EXTERNAL\\n\\nThe external state represents a state that can\'t be resolved by Player itself -- it defers resolution of the transition value to the application. This is typically used in conjunction with the ExternalActionPlugin in order to wire up the proper handler that can process these values.\\n\\nSimilar to the view node, external states contain a ref to describe the external state type:\\n\\n{\\n  \\"state_type\\": \\"EXTERNAL\\",\\n  \\"ref\\": \\"custom-state\\",\\n  \\"transitions\\": {\\n    \\"next\\": \\"VIEW_2\\"\\n  }\\n}\\n\\nPlayer will remain in this state until the external handler responds with a transition value to move the current state in the state machine.\\n","header":"EXTERNAL","title":"Navigation"},"/content/navigation#flow":{"path":"/content/navigation#flow","content":"FLOW\\n\\nThe flow state executes the referenced flow, and its outcome determines the transition to use.\\n\\n{\\n  \\"state_type\\": \\"FLOW\\",\\n  \\"ref\\": \\"FLOW-2\\",\\n  \\"transitions\\": {\\n    \\"next\\": \\"VIEW_2\\"\\n  }\\n}\\n\\nReaching this state will execute the FLOW2 flow -- and if FLOW2 reaches an END state with an outcome of next, will transition to the VIEW_2 state\\n\\nState types can also contain onStart and onEnd properties for evaluating expressions. Order of operations:\\n\\nonStart - Evaluated at the start of a node\'s lifecycle; useful for updating data before it\'s resolved\\nexp\\nonEnd - Evaluated last, right before transition. If a transition is halted (by validation or otherwise), the expression won\'t be executed.\\n","header":"FLOW","title":"Navigation"},"/content/navigation#examples":{"path":"/content/navigation#examples","content":"Examples\\n\\n","header":"Examples","title":"Navigation"},"/content/navigation#single-flow":{"path":"/content/navigation#single-flow","content":"Single Flow\\n\\n{\\n  \\"BEGIN\\": \\"FLOW_1\\",\\n  \\"FLOW_1\\": {\\n    \\"startState\\": \\"VIEW_1\\",\\n    \\"VIEW_1\\": {\\n      \\"state_type\\": \\"VIEW\\",\\n      \\"ref\\": \\"view-1\\",\\n      \\"transitions\\": {\\n        \\"*\\": \\"END_1\\"\\n      }\\n    },\\n    \\"END_1\\": {\\n      \\"state_type\\": \\"END\\",\\n      \\"outcome\\": \\"Done\\"\\n    }\\n  }\\n}\\n\\nThis is the simplest of flows. The navigation begins with executing FLOW1. FLOW1 begins with the VIEW1 state. VIEW1 shows the view with id view-1, and any transition from that view goes to END_1 which completes Player\'s execution with the Done outcome.\\n\\nSingle Flow Example\\n","header":"Single Flow","title":"Navigation"},"/content/navigation#flow-with-onstart-expression":{"path":"/content/navigation#flow-with-onstart-expression","content":"Flow with onStart expression\\n\\n{\\n  \\"BEGIN\\": \\"FLOW_1\\",\\n  \\"FLOW_1\\": {\\n    \\"startState\\": \\"VIEW_1\\",\\n    \\"VIEW_1\\": {\\n      \\"state_type\\": \\"VIEW\\",\\n      \\"ref\\": \\"{{dynamicRef}}\\",\\n      \\"onStart\\": \\"{{dynamicRef}} = \'view-1\'\\",\\n      \\"transitions\\": {\\n        \\"*\\": \\"END_1\\"\\n      }\\n    },\\n    \\"END_1\\": {\\n      \\"state_type\\": \\"END\\",\\n      \\"outcome\\": \\"Done\\"\\n    }\\n  }\\n}\\n\\nThe view node in this flow utilizes an onStart expression to update the ref property dynamically. The expression is evaluated before the data is resolved, and the node references the updated id.\\n","header":"Flow with onStart expression","title":"Navigation"},"/content/schema":{"path":"/content/schema","content":"\\n\\n","title":"Schema"},"/content/schema#schema":{"path":"/content/schema#schema","content":"Schema\\n\\nThe schema section of the content describes the relationship between the view and the data. It breaks down properties of the model\'s object into data-types, each with their own spot for validation, formatting, or default-values.\\n","header":"Schema","title":"Schema"},"/content/schema#structure":{"path":"/content/schema#structure","content":"Structure\\n\\nThe root of the data object uses the ROOT keyword in the schema:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"myProperty1\\": {\\n      \\"type\\": \\"MyCustomType\\"\\n    }\\n  }\\n}\\n\\nThis describes a myProperty1 key on the data-model which corresponds to a type of MyCustomType. Structural data-types can be added to the schema as a sibling to ROOT and are referenced by name from the previous type.\\n\\nTo add a name property to the myProperty1 example:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"myProperty1\\": {\\n      \\"type\\": \\"MyCustomType\\"\\n    }\\n  },\\n  \\"MyCustomType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"StringType\\"\\n    }\\n  }\\n}\\n\\nNow the path myProperty1.name in the model points to a StringType. There are a number of basic built-in core types, like StringType, that provide a base set of formatting/validation/default value support out of the box. Read more about those below.\\n","header":"Structure","title":"Schema"},"/content/schema#data-types":{"path":"/content/schema#data-types","content":"Data Types\\n\\nA DataType is a collection of the validation rules, formatting, and default values for a given path in the model. See the above structure docs on how to author these in JSON content.\\n\\nAs in the above StringType example, there are a number of pre-existing base types that can be utilized in the schema to describe a data type, and an extension mechanism for supplying additional base-types for use in the authored content. See the types-provider-plugin for an easy way to extend these.\\n\\nFor any given path described by the schema, Player will merge the rules defined by the base type (if one exists), and the rules defined specifically for that path in the authored content. Any custom formatter/default values take precedence over the default ones, and any custom validations are ran before the base ones.\\n\\nCheck out the CommonTypes plugin for a list of easy to consume DataTypes for your application.\\n","header":"Data Types","title":"Schema"},"/content/schema#arrays":{"path":"/content/schema#arrays","content":"Arrays\\n\\nSometimes the data you\'re using represents an array or list of things. To indicate this in the schema add a isArray: true property to the reference of the top level array. For example, if the data you\'re representing looks like:\\n\\n{\\n  \\"pets\\": [\\n    {\\n      \\"name\\": \\"Frodo\\",\\n      \\"type\\": \\"cat\\"\\n    },\\n    {\\n      \\"name\\": \\"Ginger\\",\\n      \\"type\\": \\"dog\\"\\n    }\\n  ]\\n}\\n\\nthe corresponding schema would be:\\n\\n{\\n  \\"ROOT\\": {\\n    \\"pets\\": {\\n      \\"type\\": \\"PetType\\",\\n      \\"isArray\\": true\\n    }\\n  },\\n  \\"PetType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"StringType\\"\\n    },\\n    \\"type\\": {\\n      \\"type\\": \\"StringType\\"\\n    }\\n  }\\n}\\n\\nEach item in the array will be formatted/validated using the same rule-set.\\n","header":"Arrays","title":"Schema"},"/content/schema#validation":{"path":"/content/schema#validation","content":"Validation\\n\\nTo attach a validation to a path in the data-model, add a reference to a validator in the data-type definition for that path under a validation property:\\n\\n{\\n  \\"MyCustomType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"StringType\\",\\n      \\"validation\\": [\\n        {\\n          \\"type\\": \\"length\\",\\n          \\"max\\": 20,\\n          \\"min\\": 5\\n        }\\n      ]\\n    }\\n  }\\n}\\n\\nEach validation reference must include a type property which corresponds to the name of the validator to run. Player includes some validators out-of-the-box, and custom validators can be registered as well. See here for more details around which validators are supported, and how to add custom ones.\\n\\nAny additional properties on the validation reference are passed as options to the validator. In the example above, a hypothetical length validator can take a min and max as the boundaries for the length of a string.\\n","header":"Validation","title":"Schema"},"/content/schema#formatting":{"path":"/content/schema#formatting","content":"Formatting\\n\\nSimilar to adding validations, formatting is added to a data-type through a reference to a formatter.\\n\\n{\\n  \\"MyCustomType\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"NumberType\\",\\n      \\"format\\": {\\n        \\"type\\": \\"commaNumber\\",\\n        \\"decimalPlaces\\": 3\\n      }\\n    }\\n  }\\n}\\n\\nJust like in validations, the type of the formatter corresponds to the name of a formatter to use (commaNumber in this case). This hypothetical commaNumber formatter would be responsible for translating the data stored in the model to/from what\'s displayed to the user. Any additional properties on the format object get passed to the respective formatter function as options. In the above example, the options would include { decimalPlaces: 3 }.\\n\\nCustom formatters can be registered with Player, and thus exposed for use within the authored content.\\n\\nThe transition from the data stored in the model to the user is considered formating where the inverse (what a user sees to the model is deformatting). Not every formatter has a handler for both formatting and deformatting, and it\'s entirely up the formatter to define the requirements for data handling in these scenarios.\\n\\nRead more about formatting here\\n","header":"Formatting","title":"Schema"},"/content/switches":{"path":"/content/switches","content":"\\n\\n","title":"Switches"},"/content/switches#switches":{"path":"/content/switches#switches","content":"Switches\\n\\nSwitches are ways of dynamically changing the structure of the view based on data. There are 2 types of switches: static and dynamic, but their structures are identical. switches can appear anywhere you\'d find a normal asset, and (similar to templates) are removed from the view before it reaches the UI layer.\\n","header":"Switches","title":"Switches"},"/content/switches#schema":{"path":"/content/switches#schema","content":"Schema\\n\\nThe switch is simply a list of objects with case and asset properties:\\n\\nasset - The asset that will replace the switch if the case is true\\ncase - An expression to evaluate.\\n\\nThe switch will run through each case statement until the first case expression evaluates to true. For the default case, simple use a value of true at the end of the array.\\n","header":"Schema","title":"Switches"},"/content/switches#static-vs-dynamic":{"path":"/content/switches#static-vs-dynamic","content":"Static vs Dynamic\\n\\nThe only difference between a static and dynamic switch is the timing update behavior after the first rendering of a view.\\n\\nA staticSwitch calculates the applicable case when a view first renders. It will not re-calculate any of the case statements as data in the view is updated. If you transition away from view-node, and revisit it later-on in the flow, the switch will re-compute the appropriate case statement.\\n\\nA dynamicSwitch will always update the applicable case statement whenever data changes. If data is changed while a view is still showing, the switch will be updated to reflect the new case.\\n","header":"Static vs Dynamic","title":"Switches"},"/content/templates":{"path":"/content/templates","content":"\\n\\n","title":"Templates"},"/content/templates#templates":{"path":"/content/templates#templates","content":"Templates\\n\\nTemplates provide a way to dynamically create a list of assets, or any object, based on data from the model. All of the templating semantics are removed by the time it reaches an asset\'s transform or UI layer.\\n","header":"Templates","title":"Templates"},"/content/templates#usage":{"path":"/content/templates#usage","content":"Usage\\n\\nWithin any asset, specify a template property as an array of:\\n\\ndata - A binding that points to an array in the model\\noutput - A property to put the mapped objects\\nvalue - The template to use for each object/item in the data array.\\ndynamic - (optional, false by default) A boolean that specifies whether template should be recomputed when data changes\\n\\nWithin a template, the index string can be used to substitute the array-index of the item being mapped.\\n","header":"Usage","title":"Templates"},"/content/templates#example":{"path":"/content/templates#example","content":"Example\\n\\nAuthored\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"top-level\\",\\n    \\"type\\": \\"collection\\",\\n    \\"template\\": [\\n      {\\n        \\"data\\": \\"list.of.names\\",\\n        \\"output\\": \\"values\\",\\n        \\"value\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"value-index\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"{{list.of.names.index}}\\"\\n          }\\n        }\\n      }\\n    ]\\n  }\\n}\\n\\nOutput\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"top-level\\",\\n    \\"type\\": \\"collection\\",\\n    \\"values\\": [\\n      {\\n        \\"asset\\": {\\n          \\"id\\": \\"value-0\\",\\n          \\"type\\": \\"text\\",\\n          \\"value\\": \\"Adam\\"\\n        }\\n      },\\n      {\\n        \\"asset\\": {\\n          \\"id\\": \\"value-1\\",\\n          \\"type\\": \\"text\\",\\n          \\"value\\": \\"Margie\\"\\n        }\\n      }\\n    ]\\n  }\\n}\\n","header":"Example","title":"Templates"},"/content/templates#multiple-templates":{"path":"/content/templates#multiple-templates","content":"Multiple templates\\n\\nThere\'s a few ways to leverage multiple templates within a single asset. Templates can be nested or multiple used on a single node. These can also be combined to build out super complicated nested expansion.\\n","header":"Multiple templates","title":"Templates"},"/content/templates#nested-templates":{"path":"/content/templates#nested-templates","content":"Nested Templates\\n\\nTemplates can contain other templates. When referencing a nested template, append the template depth to the index string to reference the correct data-item.\\n\\nFor example, if 1 template contains another, use index to reference the outer-loop, and index1 to reference the inner loop.\\n","header":"Nested Templates","title":"Templates"},"/content/templates#multiple-templates---single-output":{"path":"/content/templates#multiple-templates---single-output","content":"Multiple Templates - Single Output\\n\\nTemplates will, by default, create an array, if needed, for the output property of each template. If that array already exits (either by manually writing it in the JSON, or from a previous template run), each item will be appended to the end of the existing array.\\n\\nThis can be leveraged by combining multiple template directives that use the same output property, or by having an output use an existing array:\\n\\nExample\\n\\nBoth templates in the example below output to the values array on the parent object. Since no values array exists, the first template will create said array, and the second will append to that.\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"top-level\\",\\n    \\"type\\": \\"collection\\",\\n    \\"template\\": [\\n      {\\n        \\"data\\": \\"list.of.names\\",\\n        \\"output\\": \\"values\\",\\n        \\"value\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"name-index\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"{{list.of.names.index}}\\"\\n          }\\n        }\\n      },\\n      {\\n        \\"data\\": \\"list.of.other-names\\",\\n        \\"output\\": \\"values\\",\\n        \\"value\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"other-name-index\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"{{list.of.names.index}}\\"\\n          }\\n        }\\n      }\\n    ]\\n  }\\n}\\n\\nExample\\n\\nThe template below will append it\'s values to the pre-existing values array.\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"top-level\\",\\n    \\"type\\": \\"collection\\",\\n    \\"values\\": [\\n      {\\n        \\"asset\\": {\\n          \\"id\\": \\"existing-name\\",\\n          \\"type\\": \\"text\\",\\n          \\"value\\": \\"Something hard-coded\\"\\n        }\\n      }\\n    ],\\n    \\"template\\": [\\n      {\\n        \\"data\\": \\"list.of.names\\",\\n        \\"output\\": \\"values\\",\\n        \\"value\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"name-index\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"{{list.of.names.index}}\\"\\n          }\\n        }\\n      }\\n    ]\\n  }\\n}\\n","header":"Multiple Templates - Single Output","title":"Templates"},"/guides/designing-semantic-assets":{"path":"/guides/designing-semantic-assets","content":"\\n\\n","title":"Designing Semantic Assets"},"/guides/designing-semantic-assets#designing-semantic-assets":{"path":"/guides/designing-semantic-assets#designing-semantic-assets","content":"Designing Semantic Assets\\n\\nWhile not a hard requirement by Player, the API design for assets plays an important role in it\'s adoption, especially if the intent is to re-use content across platforms. In many cases, Player content is written, and edited many more times than assets are created, and thus it\'s schema plays an important role in it\'s effective adoption.\\n\\nPlayer ships with a set of Reference Assets to get started, but intentionally doesn\'t include anything beyond some basics. We believe it\'s up to each consumer to define their own semantics (if at all), that best suites their applications.\\n","header":"Designing Semantic Assets","title":"Designing Semantic Assets"},"/guides/multi-flow-experiences":{"path":"/guides/multi-flow-experiences","content":"\\n\\n","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#multi-flow-experiences":{"path":"/guides/multi-flow-experiences#multi-flow-experiences","content":"Multi-Flow Experiences\\n\\nOne large use-case for Player involves orchestrating experiences that span multiple screens that may need to communicate with a back-end between stages. This is commonly used for stepped-flows, onboarding workflows, etc, and manifests as using the response from one Player flow to determine the next one. To facilitate this back-and-forth, Player ships with support for creating a flow-manager.\\n","header":"Multi-Flow Experiences","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#flow-manager":{"path":"/guides/multi-flow-experiences#flow-manager","content":"Flow Manager\\n\\nA flow-manager is an interface for asynchronously stepping through a series of flows in a multi-flow experience. Its API mirrors that of the JavaScript iteration protocol; each flow is loaded by calling .next() using the result of the previous flow (if one exists). Implementations are able to leverage this response to retrieve the next flow in the series, or mark the cycle as complete by returning done.\\n\\nFlow Manager\\n\\nThe standardization of this contract allows any client to manage a series of Player flows without needing to repeat the underlying Player-side orchestration.\\n\\nAn abridged version of the API is described below:\\n\\ninterface FlowManager {\\n  /**\\n   An iterator implementation that takes the result of the previous flow and returns a new one or completion marker.\\n   If done: true is returned, the multi-flow experience is completed.\\n   * @param previousValue - The result of the previous flow.\\n   */\\n  next: (prevResponse: CompletedState) => Promise>;\\n\\n  /**\\n   Called when the flow is ended early (the react tree is torn down)\\n   Allows clients the opportunity to save-data before destroying the tree\\n   */\\n  terminate?: (player: Player) => void;\\n}\\n\\nShown above is also an optional terminate callback. This is used when a flow is ended prematurely (user closes a view) as a means of gathering any critical information from the running player before shutting down.\\n","header":"Flow Manager","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#managed-player":{"path":"/guides/multi-flow-experiences#managed-player","content":"Managed Player\\n\\n\\nThe ManagedPlayer component from the @player-ui/react module orchestrates running flows through Player using a provided flow-manager. Any provided configuration/plugins will be passed along to the underlying ReactPlayer instance, and React.Suspense is used while awaiting the next flow-manager response.\\n\\nSimply render the ManagedPlayer with a flow-manager:\\n\\nimport { ManagedPlayer } from \'@player-ui/react\';\\n\\nexport const App = () => {\\n  return\\n}\\n","header":"Managed Player","title":"Multi-Flow Experiences"},"/guides/multi-flow-experiences#callbacks-and-error-handling":{"path":"/guides/multi-flow-experiences#callbacks-and-error-handling","content":"Callbacks and Error Handling\\n\\nThe ManagedPlayer also includes callbacks for onComplete and onError to handle the completion of a multi-flow experience.\\n\\nThe fallbackComponent is an optional prop that accepts a React component that will be rendered in case of an error. It\'s given access to the thrown Error object, as well as a retry and reset callback:\\n\\nretry -- Retries the last failed request (the last call to next())\\nreset -- Restarts the multi-flow from the begining, calling next() with an empty context.\\n\\nThe ManagedPlayer SwiftUI Component from the PlayerUI/SwiftUI subspec orchestrates running flows through Player using a provided FlowManager. Any provided configuration or plugins are passed along to the underlying SwiftUIPlayer instance.\\n\\nWhen constructing the ManagedPlayer you supply views to be used for error scenarios, as well as what is displayed while the FlowManager is fetching flows.\\n","header":"Callbacks and Error Handling","title":"Multi-Flow Experiences"},"/plugins/asset-provider":{"path":"/plugins/asset-provider","content":"\\n\\n","title":"Asset Provider Plugin"},"/plugins/asset-provider#asset-provider":{"path":"/plugins/asset-provider#asset-provider","content":"Asset Provider\\n\\nThe Asset Provider Plugin enables users to easily register UI components to render their assets. It\'s used internally by the Reference Assets. The matches follow the same rules as asset transforms (more specific matches take priority).\\n","header":"Asset Provider","title":"Asset Provider Plugin"},"/plugins/asset-transform":{"path":"/plugins/asset-transform","content":"\\n\\n","title":"Asset Transform"},"/plugins/asset-transform#asset-transform-plugin":{"path":"/plugins/asset-transform#asset-transform-plugin","content":"Asset Transform Plugin\\n\\n","header":"Asset Transform Plugin","title":"Asset Transform"},"/plugins/asset-transform#what-are-transforms":{"path":"/plugins/asset-transform#what-are-transforms","content":"What are transforms?\\n\\nTransforms are functions that map the authored JSON representation of an asset into a stateful JavaScript object, including all of the properties required for that asset to interact with the data-model, navigation, and the rest of Player. This allows UI implementations to have consistent treatment and behavior. While the transform plugin is registered in the core layer, it can be wrapped by the native platforms.\\n","header":"What are transforms?","title":"Asset Transform"},"/plugins/asset-transform#partial-matching":{"path":"/plugins/asset-transform#partial-matching","content":"Partial Matching\\n\\nThe transform plugin makes use of the partial-match-registry which ranks matching templates by the number of matching key-value pairs. This allows users to overwrite the implementation of the lookup, if more specific search criteria is provided. This registry/lookup pattern is also utilized in the web-player for the React Component to Asset mapping.\\n","header":"Partial Matching","title":"Asset Transform"},"/plugins/asset-transform#usage":{"path":"/plugins/asset-transform#usage","content":"Usage\\n\\n","header":"Usage","title":"Asset Transform"},"/plugins/asset-transform#transform-arguments":{"path":"/plugins/asset-transform#transform-arguments","content":"Transform Arguments\\n\\nEach transform is a function that is passed 3 arguments: the current asset node, and an options object containing a data-model, expression-evaluator, binding-parser, and a flow transition function, and a store for state management. The transforms should return an immutable representation of the asset, including any means of interacting with the player.\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { AssetTransformPlugin } from \'@player-ui/asset-transform-plugin\';\\n\\n// Add it to Player\\n\\nconst player = new Player({\\n  plugins: [\\n    new AssetTransformPlugin(\\n      new Registry([\\n        // Register a match for any action type with a custom transform.\\n        [\\n          { type: \'action\' },\\n          value => {\\n            return {\\n              ...value,\\n              hello: () => console.log(\'hello world\')\\n            };\\n          }\\n        ]\\n      ])\\n    )\\n  ]\\n});\\n","header":"Transform Arguments","title":"Asset Transform"},"/plugins/asset-transform#state-management":{"path":"/plugins/asset-transform#state-management","content":"State Management\\n\\nOften times node transforms require some state to be stored between updates. Historically this state was put in the data-model under local (to not send it back to the server), but updates became difficult to manage, and namespace collisions under local were up to the transforms to discern.\\n\\nThe third argument to the transform functions expose a store for data, that mirrors the usage of React hooks. This allow transforms to store state information in an automatically scoped store outside of the normal data tree.\\n\\nA simple transform to manage a counter might look like:\\n\\nconst transform = (asset, options, store) => {\\n  const [count, setCount] = store.useState(0);\\n  return {\\n    ...asset,\\n    count,\\n    increment() {\\n      setCount(count + 1);\\n    }\\n  };\\n};\\n","header":"State Management","title":"Asset Transform"},"/plugins/auto-scroll-manager":{"path":"/plugins/auto-scroll-manager","content":"\\n\\n","title":"Auto Scroll Manager Plugin"},"/plugins/auto-scroll-manager#auto-scroll-manager-plugin":{"path":"/plugins/auto-scroll-manager#auto-scroll-manager-plugin","content":"Auto Scroll Manager Plugin\\n\\nThe Auto Scroll Plugin helps orchestrate scrolling to components based off of 3 scenarios:\\n\\nOn page load\\nOn validation trigger\\nOn first appearance after page load\\n","header":"Auto Scroll Manager Plugin","title":"Auto Scroll Manager Plugin"},"/plugins/beacon":{"path":"/plugins/beacon","content":"\\n\\n","title":"Beacon Plugin"},"/plugins/beacon#beacon-plugin":{"path":"/plugins/beacon#beacon-plugin","content":"Beacon Plugin\\n\\nThe beacon plugin enables users to send and/or collect beaconing information from assets in a normalized API. It exposes a common API for publishing beacons from an asset library, and will automatically attach itself to the current view, enabling additional meta-data to be added to each event.\\n","header":"Beacon Plugin","title":"Beacon Plugin"},"/plugins/beacon#consuming-beacons":{"path":"/plugins/beacon#consuming-beacons","content":"Consuming Beacons\\n\\n","header":"Consuming Beacons","title":"Beacon Plugin"},"/plugins/beacon#beacon-format":{"path":"/plugins/beacon#beacon-format","content":"Beacon Format\\n\\nBy default, the beacon plugin returns beacons in the following format:\\n\\ninterface DefaultBeacon {\\n  /* The user action taken (\'clicked\', \'visited\') */\\n  action: string;\\n\\n  /* The type of UI element interacted with (\'button\', \'menu\') */\\n  element: string;\\n\\n  /* Any additional data from a metaData.beacon property */\\n  data: any;\\n\\n  /* The id of the asset */\\n  assetId: string;\\n\\n  /* The id of the view */\\n  viewId: string;\\n}\\n\\nAdd the beacon plugin to a player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { BeaconPlugin } from \'@player-ui/beacon-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new BeaconPlugin({\\n\\n      // Any plugins to the beacon-plugin\\n      plugins: [],\\n\\n      // Callback to handle any beacon event\\n      callback: () => {}\\n    }),\\n  ],\\n});\\n\\nBeacons can be published directly by the plugin, but in most cases, a platform specific adapter is recommended.\\n\\nbeaconPlugin.beacon({\\n  action: \'click\',\\n  element: \'button\',\\n  asset: asset // The entire Asset object, for use in the plugin pipeline\\n  // other metadata\\n});\\n\\nJust like with the core variant, to add support for beaconing in the react player, add the plugin to Player:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { BeaconPlugin } from \'@player-ui/beacon-plugin-react\';\\n\\nconst player = new ReactPlayer({\\n  plugins: [\\n    new BeaconPlugin({\\n\\n      // Any plugins to the beacon-plugin\\n      plugins: [],\\n\\n      // Callback to handle any beacon event\\n      callback: () => {}\\n    }),\\n  ],\\n});\\n\\nThis will add additional React Context to the running player for the producers from asset-libraries to leverage.\\n\\nTo receive Beacon events from Player in iOS, add the BeaconPlugin to your plugin array:\\n\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      BeaconPlugin { (beacon: DefaultBeacon) in\\n\\t\\t\\t\\t// Process beacon into the format you need for Segment/Trinity and send it on\\n\\t\\t\\t}\\n    ]\\n  )\\n}\\n\\nIf you are modifying the beacon using core BeaconPlugin plugins:\\n\\nstruct CustomBeacon: Decodable {\\n  public var action: String\\n  public var element: String\\n  public var customElement: Int\\n}\\n\\nclass CustomBeaconPlugin: JSBasePlugin {\\n  convenience init() {\\n    self.init(fileName: \\"custom-beacon\\", pluginName: \\"CustomBeaconPlugin\\")\\n  }\\n  override open func getUrlForFile(fileName: String) -> URL? {\\n        ResourceUtilities.urlForFile(\\n          name: fileName,\\n          ext: \\"js\\",\\n          bundle: Bundle(for: .self),\\n          pathComponent: \\".bundle\\"\\n        )\\n    }\\n}\\n\\n// In some SwiftUI View\\nvar body: some View {\\n  SwiftUIPlayer(\\n    flow: flow,\\n    plugins: [\\n      BeaconPlugin { (beacon: CustomBeacon) in\\n\\t\\t\\t\\t// Process beacon into the format you need for Segment/Trinity and send it on\\n\\t\\t\\t}\\n    ]\\n  )\\n}\\n\\nBeaconing on the JVM platform (including Android) is done with an instance of the BeaconPlugin. By default, the Android Player includes a wrapper of the core beacon plugin. The Android Player can be configured to override the default BeaconPlugin by passing a different BeaconPlugin implementation on instantiation which can contain further configuration.\\n\\nWithout additional configuration, the BeaconPlugin doesn\'t provide much value. Beacons must be explicitly handled in order to forward them to an analytics platform (segment, Trinity, etc.). This is done by calling registerHandler(handler: (String) -> Unit) with a callback.\\n\\nval beaconPlugin = BeaconPlugin()\\nbeaconPlugin.registerHandler { beacon: String ->\\n    // Process beacon and send to analytics platform\\n}\\n\\nThere may be some beacons that are fired automatically by the BeaconPlugin implementation, but in most cases, there are additional beacons that should be fired on some interaction (i.e. user tapping button asset). This is done by calling beacon(action: String, element: String, asset: Asset, data: Any? = null) with the relevant information.\\n\\nval beaconPlugin = BeaconPlugin()\\nbeaconPlugin.beacon(\\n    \\"clicked\\",\\n    \\"button\\",\\n    assetThatIsBeaconing,\\n    someData,\\n)\\n\\nFor convenience, there are several extension methods for utilizing a pre-installed BeaconPlugin from Player. If there isn\'t a BeaconPlugin installed, Player will produce a warning log.\\n\\n// registering handler\\nplayer.onBeacon { beacon: String ->\\n    // Process beacon and send to analytics platform\\n}\\n\\n// fire beacon\\nplayer.beacon(\\n    \\"clicked\\",\\n    \\"button\\",\\n    assetThatIsBeaconing,\\n    someData,\\n)\\n\\nThe base RenderableAsset class provides an additional helper to make beaconing less verbose from an asset perspective.\\n\\n// within RenderableAsset implementation\\nbeacon(BeaconAction.clicked, BeaconElement.button)\\n","header":"Beacon Format","title":"Beacon Plugin"},"/plugins/beacon#beacon-plugins":{"path":"/plugins/beacon#beacon-plugins","content":"Beacon Plugins\\n\\nSimilar to how Player accepts plugins, the beacon-plugin itself accepts a list of plugins. These are able to mutate and augment the beacon payload as it makes its way through the publishing pipeline.\\n\\nThere are 3 hooks that are currently exposed:\\n\\nbuildBeacon - Assembles a given beacon ffor publishing\\ncancelBeacon - Given a current beacon, determine if it should be published or not.\\npublishBeacon - Receive the final becaon. This is a substitute for the callback in the beacon plugin options.\\n","header":"Beacon Plugins","title":"Beacon Plugin"},"/plugins/beacon#publishing-beacons":{"path":"/plugins/beacon#publishing-beacons","content":"Publishing Beacons\\n\\n","header":"Publishing Beacons","title":"Beacon Plugin"},"/plugins/beacon#beacon-expression":{"path":"/plugins/beacon#beacon-expression","content":"beacon expression\\n\\nThe beacon plugin adds support for a beacon expression that can be referenced within content. Each beacon referenced from this expression will be assumed to originate from a view (no local asset information will be attached)\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"my-action\\",\\n    \\"type\\": \\"action\\",\\n    \\"exp\\": \\"beacon(\'my-action\', \'some-data\')\\"\\n  }\\n}\\n","header":"beacon expression","title":"Beacon Plugin"},"/plugins/beacon#assets":{"path":"/plugins/beacon#assets","content":"Assets\\n\\n","header":"Assets","title":"Beacon Plugin"},"/plugins/check-path":{"path":"/plugins/check-path","content":"\\n\\n","title":"Check Path Plugin"},"/plugins/check-path#check-path-plugin":{"path":"/plugins/check-path#check-path-plugin","content":"Check Path Plugin\\n\\nThe Check Path Plugin enables users to query segments of the view tree for contextual rendering or behavior.\\nThis is best suited to be referenced during the UI rendering phase, where one can make decisions about the rendering of an asset based on where it lies in the tree.\\n","header":"Check Path Plugin","title":"Check Path Plugin"},"/plugins/check-path#usage":{"path":"/plugins/check-path#usage","content":"Usage\\n\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/check-path-plugin\\n\\nAdd it to Player:\\n\\nimport CheckPathPlugin from \'@player-ui/check-path-plugin\';\\n\\nconst checkPathPlugin = new CheckPathPlugin();\\nconst player = new Player({ plugins: [checkPathPlugin] });\\n\\n// Start your flow\\nplayer.start(myFlow);\\n\\nThen use the plugin to query the view:\\n\\nconst isCustomThing = checkPathPlugin.hasParentContext(\'my-asset-id\', [\\n  \'input\',\\n  \'myCustomViewType\',\\n]);\\n\\nInstall the plugin:\\n\\nyarn add @player-ui/check-path-plugin-react\\n\\nAdd it to Player:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { CheckPathPlugin } from \'@player-ui/check-path-plugin-react\';\\n\\nconst rp = new ReactPlayer({\\n  plugins: [new CheckPathPlugin()],\\n});\\n\\nThis will automatically create the underlying core version of the CheckPathPlugin to be made available via React Context for the hooks.\\n","header":"Usage","title":"Check Path Plugin"},"/plugins/check-path#api":{"path":"/plugins/check-path#api","content":"API\\n\\n","header":"API","title":"Check Path Plugin"},"/plugins/check-path#query":{"path":"/plugins/check-path#query","content":"Query\\n\\nIn most of the methods, the Query type is referenced.\\nThis can either be a function, string, or an object.\\n\\nstring - an alias for { type: \'\' }\\nobject - uses a partial-object match to query the object\\nfunction - a filter that gets passed an object, and returns a boolean\\n\\nThere are a few different functions exposed by the plugin you can use:\\n","header":"Query","title":"Check Path Plugin"},"/plugins/check-path#getparent":{"path":"/plugins/check-path#getparent","content":"getParent\\n\\nfunction getParent(id: string, query: Query | Query[]): Asset | undefined\\n\\nThe getParent method allows you to query up the tree, and return the first parent that matches the given query, or undefined.\\nIf an array is passed, the tree is parsed matching on each query item from left to right. The parent object that matches the last query item is returned.\\n","header":"getParent","title":"Check Path Plugin"},"/plugins/check-path#getparentprop":{"path":"/plugins/check-path#getparentprop","content":"getParentProp\\n\\nfunction getParentProp(id: string): string | undefined\\n\\nThe getParentProp method returns the property on the parent object that the current object falls under.\\nFor example, an input with a text asset as the label, will return label for the parentProp of the text asset.\\n","header":"getParentProp","title":"Check Path Plugin"},"/plugins/check-path#hasparentcontext":{"path":"/plugins/check-path#hasparentcontext","content":"hasParentContext\\n\\nfunction hasParentContext(id: string, query: Query | Query[]): boolean\\n\\nSimilar to getParent, the hasParentContext method responds with the existence of a parent with the given context.\\n","header":"hasParentContext","title":"Check Path Plugin"},"/plugins/check-path#haschildcontext":{"path":"/plugins/check-path#haschildcontext","content":"hasChildContext\\n\\nfunction hasChildContext(id: string, query: Query | Query[]): boolean\\n\\nThe compliment of hasParentContext, hasChildContext traverses down the tree for any path from the given node that satisfies the context requirements.\\n\\nThe API for the React version of the CheckPathPlugin is similar to the core version, just exposed through React hooks for easy use in custom assets:\\n\\nfunction useGetParent(id: string, query: Query | Query[]): Asset | undefined;\\nfunction useGetParentProp(id: string): string | undefined;\\nfunction useHasParentContext(id: string, query: Query | Query[]): boolean;\\nfunction useHasChildContext(id: string, query: Query | Query[]): boolean;\\n","header":"hasChildContext","title":"Check Path Plugin"},"/plugins/common-expressions":{"path":"/plugins/common-expressions","content":"\\n\\n","title":"Common Expressions"},"/plugins/common-expressions#common-expressions-plugin":{"path":"/plugins/common-expressions#common-expressions-plugin","content":"Common Expressions Plugin\\n\\nThis plugin exposes some basic expressions into Player content.\\n\\nIt also serves as a good reference to adding your own custom expressions into Player.\\n","header":"Common Expressions Plugin","title":"Common Expressions"},"/plugins/common-expressions#general":{"path":"/plugins/common-expressions#general","content":"General\\n\\n","header":"General","title":"Common Expressions"},"/plugins/common-expressions#size":{"path":"/plugins/common-expressions#size","content":"size\\nGets the size of a value. This is the number of keys in an object, the length of a string, or the number of items in an array.\\n\\nfunction size(value: string | array | object): number\\n","header":"size","title":"Common Expressions"},"/plugins/common-expressions#length":{"path":"/plugins/common-expressions#length","content":"length\\nAlias for size\\n","header":"length","title":"Common Expressions"},"/plugins/common-expressions#concat":{"path":"/plugins/common-expressions#concat","content":"concat\\nConcatenates arrays together, or strings into 1 value\\n\\nfunction concat(...values: Array): Array\\n","header":"concat","title":"Common Expressions"},"/plugins/common-expressions#strings":{"path":"/plugins/common-expressions#strings","content":"Strings\\n\\n","header":"Strings","title":"Common Expressions"},"/plugins/common-expressions#trim":{"path":"/plugins/common-expressions#trim","content":"trim\\nTrims whitespace from the leading and trailing edges of a string\\n\\nfunction trim(value: string): string\\n","header":"trim","title":"Common Expressions"},"/plugins/common-expressions#uppercase":{"path":"/plugins/common-expressions#uppercase","content":"upperCase\\nTransforms the string to all uppercase.\\n\\nfunction upperCase(value: string): string\\n","header":"upperCase","title":"Common Expressions"},"/plugins/common-expressions#lowercase":{"path":"/plugins/common-expressions#lowercase","content":"lowerCase\\nTransforms the string to all lowercase.\\n\\nfunction lowerCase(value: string): string\\n","header":"lowerCase","title":"Common Expressions"},"/plugins/common-expressions#titlecase":{"path":"/plugins/common-expressions#titlecase","content":"titleCase\\nTransforms the string to title case. Each word is capitalized.\\n\\nfunction titleCase(value: string): string\\n","header":"titleCase","title":"Common Expressions"},"/plugins/common-expressions#sentencecase":{"path":"/plugins/common-expressions#sentencecase","content":"sentenceCase\\nTransforms the string to sentence case. The first word is capitalized.\\n\\nfunction sentenceCase(value: string): string\\n","header":"sentenceCase","title":"Common Expressions"},"/plugins/common-expressions#replace":{"path":"/plugins/common-expressions#replace","content":"replace\\nReplaces all instances of pattern in string with replacement. The pattern can also be a regex.\\n\\nfunction replace(value: string, pattern: string | RegExp, replacement: string): string\\n","header":"replace","title":"Common Expressions"},"/plugins/common-expressions#containsany":{"path":"/plugins/common-expressions#containsany","content":"containsAny\\nChecks if a given string contains any keywords present in the given array.\\n\\nfunction containsAny(value: string, keywords: Array): boolean\\n","header":"containsAny","title":"Common Expressions"},"/plugins/common-expressions#math":{"path":"/plugins/common-expressions#math","content":"Math\\n\\n","header":"Math","title":"Common Expressions"},"/plugins/common-expressions#number":{"path":"/plugins/common-expressions#number","content":"number\\nConverts the given value to a number if possible. Will handle removing currency modifiers and comma delimitated values.\\n\\nfunction number(value: string): number | undefined\\n","header":"number","title":"Common Expressions"},"/plugins/common-expressions#round":{"path":"/plugins/common-expressions#round","content":"round\\nRounds the given number to the nearest integer.\\n\\nfunction round(value: number): number\\n","header":"round","title":"Common Expressions"},"/plugins/common-expressions#floor":{"path":"/plugins/common-expressions#floor","content":"floor\\nRounds the number down the the nearest integer\\n\\nfunction floor(value: number): number\\n","header":"floor","title":"Common Expressions"},"/plugins/common-expressions#ceil":{"path":"/plugins/common-expressions#ceil","content":"ceil\\nRounds the number up the the nearest integer\\n\\nfunction ceil(value: number): number\\n","header":"ceil","title":"Common Expressions"},"/plugins/common-expressions#sum":{"path":"/plugins/common-expressions#sum","content":"sum\\nSums up all arguments\\n\\nfunction sum(...values: Array): number\\n","header":"sum","title":"Common Expressions"},"/plugins/common-expressions#objectsarrays":{"path":"/plugins/common-expressions#objectsarrays","content":"Objects/Arrays\\n\\n","header":"Objects/Arrays","title":"Common Expressions"},"/plugins/common-expressions#findpropertyindex":{"path":"/plugins/common-expressions#findpropertyindex","content":"findPropertyIndex\\nFinds the index of the item in the given array (or array reference). Returns -1 for indexes that aren\'t found\\n\\nfunction findPropertyIndex(binding: Binding | Array, searchProperty: string, searchValue: any): number\\n","header":"findPropertyIndex","title":"Common Expressions"},"/plugins/common-types":{"path":"/plugins/common-types","content":"\\n\\n","title":"Common Types"},"/plugins/common-types#common-types-plugin":{"path":"/plugins/common-types#common-types-plugin","content":"Common Types Plugin\\n\\nThis plugin exposes some basic DataTypes, validations, and formats into Player content.\\n\\nIt also serves as a good reference to adding your own custom types into Player.\\n","header":"Common Types Plugin","title":"Common Types"},"/plugins/common-types#formats":{"path":"/plugins/common-types#formats","content":"Formats\\n\\n","header":"Formats","title":"Common Types"},"/plugins/common-types#commanumber":{"path":"/plugins/common-types#commanumber","content":"commaNumber\\n\\n\\nformat: Formats a number (or string containing only numbers) into a comma delineated string.\\ndeformat: Converts a comma delineated string into a number\\n\\nOptions:\\n\\n{\\n  precision?: number\\n}\\n","header":"commaNumber","title":"Common Types"},"/plugins/common-types#integer":{"path":"/plugins/common-types#integer","content":"integer\\n\\ndeformat: converts a string containing only integers to an integer\\n","header":"integer","title":"Common Types"},"/plugins/common-types#date":{"path":"/plugins/common-types#date","content":"date\\n\\nformat: Formats a string of numbers into a slash separated date\\n\\nOptions:\\n\\n{\\n  mask?: string\\n}\\n","header":"date","title":"Common Types"},"/plugins/common-types#currency":{"path":"/plugins/common-types#currency","content":"currency\\n\\nformat: Formats a number of string into a currency value\\ndeformat: Converts a currency value into a number\\n\\nOptions:\\n\\n{\\n  precision?: number;\\n  currencySymbol?: string;\\n  useParensForNeg?: boolean;\\n}\\n","header":"currency","title":"Common Types"},"/plugins/common-types#phone":{"path":"/plugins/common-types#phone","content":"phone\\n\\nformat: Formats the value as a phone number\\n\\nOptions:\\n\\n{\\n  mask?: string;\\n}\\n","header":"phone","title":"Common Types"},"/plugins/common-types#validations":{"path":"/plugins/common-types#validations","content":"Validations\\n\\n","header":"Validations","title":"Common Types"},"/plugins/common-types#required":{"path":"/plugins/common-types#required","content":"required\\nAsserts that a value is not null, undefined, or an empty string\\n\\nOptions:\\n{\\n  /* An expression to limit the assertion only if the expression evaluates to truthy */\\n  if?: Expression;\\n\\n  /* An expression to limit the assertion only if the expression evaluates to falsy */\\n  ifNot?: Expression;\\n}\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.required\\nmessage: \\"A value is required\\"\\n","header":"required","title":"Common Types"},"/plugins/common-types#expression":{"path":"/plugins/common-types#expression","content":"expression\\nUses an expression to evaluate the validation assertion\\n\\nOptions:\\n\\n{\\n  /* The expression to evaluate. If truthy, the value/validation passes. If falsy, it does not. */\\n  exp: Expression;\\n}\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.expression\\nmessage: \\"Expression evaluation failed\\"\\n","header":"expression","title":"Common Types"},"/plugins/common-types#readonly":{"path":"/plugins/common-types#readonly","content":"readonly\\nAsserts that the value cannot change\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.readonly\\nmessage: \\"Value cannot be modified\\"\\n","header":"readonly","title":"Common Types"},"/plugins/common-types#string":{"path":"/plugins/common-types#string","content":"string\\nAsserts that the value is a string\\n\\nConstants Support:\\n\\nnamespace: constants\\npath: validation.string\\nmessage: \\"Value must be a string\\"\\nparameters:\\n  type: the type of value being validated\\n","header":"string","title":"Common Types"},"/plugins/computed-properties":{"path":"/plugins/computed-properties","content":"\\n\\n","title":"Computed Properties"},"/plugins/computed-properties#computed-properties-plugin":{"path":"/plugins/computed-properties#computed-properties-plugin","content":"Computed Properties Plugin\\n\\nThis plugin allows users to specify a path in the data-model (binding) as a computed property in the schema.\\nAnytime this binding is read from, the given expression will be evaluated and returned instead of the it being read from the actual model. Writes to the binding will be prevented, and an error will be thrown.\\n","header":"Computed Properties Plugin","title":"Computed Properties"},"/plugins/computed-properties#usage":{"path":"/plugins/computed-properties#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ComputedPropertiesPlugin } from \'@player-ui/computed-properties-plugin\';\\n\\nconst player = new Player({\\n  plugins: [new ComputedPropertiesPlugin()],\\n});\\n","header":"Usage","title":"Computed Properties"},"/plugins/computed-properties#expression-data-type":{"path":"/plugins/computed-properties#expression-data-type","content":"Expression Data Type\\n\\nThe computed properties plugin introspects the schema, looking for any DataType that uses the Expression:\\n\\n{\\n  \\"type\\": \\"Expression\\",\\n  \\"exp\\": \\"@[ someExpression() ]@\\"\\n}\\n\\nAny data-lookup for that binding path will evaluate the given expression and return that value. Results are not cached, and will be recomputed on every fetch.\\n","header":"Expression Data Type","title":"Computed Properties"},"/plugins/console-logger":{"path":"/plugins/console-logger","content":"\\n\\n","title":"Console Logger"},"/plugins/console-logger#console-logger-plugin":{"path":"/plugins/console-logger#console-logger-plugin","content":"Console Logger Plugin\\n\\nA plugin to easily enable logs to be written to the JS console. Extremely helpful for local Player development and debugging.\\n","header":"Console Logger Plugin","title":"Console Logger"},"/plugins/data-change-listener":{"path":"/plugins/data-change-listener","content":"\\n\\n","title":"Data Change Listener"},"/plugins/data-change-listener#data-change-listener-plugin":{"path":"/plugins/data-change-listener#data-change-listener-plugin","content":"Data Change Listener Plugin\\n\\nThis plugin enables users to subscribe to data-change events within a view, and run expressions when the target value changes. Expressions are added to a listeners property of the view, with events prefixed by dataChange and the target binding:\\n\\n{\\n  \\"id\\": \\"example-view\\",\\n  \\"type\\": \\"info\\",\\n  \\"listeners\\": {\\n    \\"dataChange.foo.bar\\": \\"helloWorld()\\",\\n    \\"dataChange.foo.baz\\": [\\"helloWorld()\\", \\"doSomethingElseToo()\\"]\\n  }\\n}\\n","header":"Data Change Listener Plugin","title":"Data Change Listener"},"/plugins/data-change-listener#installation":{"path":"/plugins/data-change-listener#installation","content":"Installation\\n\\n\\nAdd it to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { DataChangePlugin } from \'@player-ui/data-change-plugin\';\\n\\nconst player = new Player({\\n  plugins: [new DataChangePlugin()]\\n});\\n","header":"Installation","title":"Data Change Listener"},"/plugins/data-change-listener#usage":{"path":"/plugins/data-change-listener#usage","content":"Usage\\n\\nThe format of dataChange. will execute the value (any valid expression or collection of expressions), anytime a value within the target binding\'s tree is updated (foo.bar and foo.baz in the example above).\\n\\nRegistrations can be made for any partial binding path, and will be evaluated anytime that path, or any child path, is mutated. The above example registration of dataChange.foo.bar will be triggered by a change to foo.bar, foo.bar.baz, or any other child path. (it will not be triggered by a change to foo.baz).\\n\\nThe subscriptions are tied to the lifecycle of the view they\'re defined in. They will not be called upon initial render of the view, and will expire when the view is no longer the active state (when transitioning to a new state in the flow).\\n","header":"Usage","title":"Data Change Listener"},"/plugins/data-filter":{"path":"/plugins/data-filter","content":"\\n\\n","title":"Data Filter"},"/plugins/data-filter#data-filter-plugin":{"path":"/plugins/data-filter#data-filter-plugin","content":"Data Filter Plugin\\n\\nThe data-filter-plugin enables users to filter out segments of the data-model during serialization.\\n","header":"Data Filter Plugin","title":"Data Filter"},"/plugins/expression":{"path":"/plugins/expression","content":"\\n\\n","title":"Expression"},"/plugins/expression#expression-plugin":{"path":"/plugins/expression#expression-plugin","content":"Expression Plugin\\n\\nThis plugin assists with exposing custom expressions to Player content.\\n","header":"Expression Plugin","title":"Expression"},"/plugins/expression#usage":{"path":"/plugins/expression#usage","content":"Usage\\n\\n\\nDefine handlers for the expressions you wish to add:\\n\\nimport { ExpressionHandler, ExpressionContext } from \'@player-ui/expression-plugin\';\\n\\nconst customExpressionHandler: ExpressionHandler = (ctx: ExpressionContext) => {\\n  return \'Hello World!\'\\n}\\n\\nRegister with Player. Subsequent registrations of an expression with the same name will override previous values.\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ExpressionPlugin } from \'@player-ui/expression-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new ExpressionPlugin([\\n      [\'myCustomFunction\', customExpressionHandler]\\n    ])\\n  ]\\n})\\n\\nAny calls to myCustomFunction() within the flow will utilize the newly registered expression:\\n\\n{\\n  \\"asset\\": {\\n    \\"id\\": \\"sample\\",\\n    \\"type\\": \\"text\\",\\n    \\"value\\": \\"@[ myCustomFunction() ]@\\"\\n  }\\n}\\n","header":"Usage","title":"Expression"},"/plugins/expression#use":{"path":"/plugins/expression#use","content":"Use\\n\\nThe ExpressionPlugin lets you register custom expressions to run native code:\\n\\n{\\n  \\"id\\": \\"textAsset\\",\\n  \\"type\\": \\"text\\",\\n  \\"value\\": \\"@[ myExpression() ]@\\"\\n}\\n\\nlet expressionPlugin = ExpressionPlugin(expressions: [\\n  \\"myExpression\\": { _ in\\n  \\t\\treturn \\"Some Value\\"\\n\\t}\\n])\\n","header":"Use","title":"Expression"},"/plugins/external-action-view-modifier":{"path":"/plugins/external-action-view-modifier","content":"\\n\\n","title":"External Action View Modifier"},"/plugins/external-action-view-modifier#external-action-view-modifier-plugin":{"path":"/plugins/external-action-view-modifier#external-action-view-modifier-plugin","content":"External Action View Modifier Plugin\\n\\nThis plugin is used to handle EXTERNAL states, allowing you to asynchronously tell Player when, and what to transition with once you have finished processing the external state request.\\n","header":"External Action View Modifier Plugin","title":"External Action View Modifier"},"/plugins/external-action-view-modifier#example":{"path":"/plugins/external-action-view-modifier#example","content":"Example\\n\\nFor an example flow with an external state such as:\\n\\n{\\n  \\"id\\": \\"test-flow\\",\\n  \\"data\\": {\\n    \\"transitionValue\\": \\"Next\\"\\n  },\\n  \\"navigation\\": {\\n    \\"BEGIN\\": \\"FLOW_1\\",\\n    \\"FLOW_1\\": {\\n      \\"startState\\": \\"EXT_1\\",\\n      \\"EXT_1\\": {\\n        \\"state_type\\": \\"EXTERNAL\\",\\n        \\"ref\\": \\"test-1\\",\\n        \\"transitions\\": {\\n          \\"Next\\": \\"END_FWD\\",\\n          \\"Prev\\": \\"END_BCK\\"\\n        },\\n        \\"extraProperty\\": \\"extraValue\\"\\n      },\\n      \\"END_FWD\\": {\\n        \\"state_type\\": \\"END\\",\\n        \\"outcome\\": \\"FWD\\"\\n      },\\n      \\"END_BCK\\": {\\n        \\"state_type\\": \\"END\\",\\n        \\"outcome\\": \\"BCK\\"\\n      }\\n    }\\n  }\\n}\\n\\nThe plugin can be declared to handle this external state:\\n\\nlet plugin = ExternalActionViewModifierPlugin { state, options, transition in\\n\\t\\treturn AnyView(\\n      VStack {\\n        Text(\\"External State\\")\\n        Button(action: {transition(\\"Next\\")}) { Text(\\"Continue\\") }\\n      }\\n    )\\n}\\n\\nlet player = SwiftUIPlayer(flow: json, plugins: [plugin])\\n","header":"Example","title":"External Action View Modifier"},"/plugins/external-action":{"path":"/plugins/external-action","content":"\\n\\n","title":"External Action"},"/plugins/external-action#external-action-plugin":{"path":"/plugins/external-action#external-action-plugin","content":"External Action Plugin\\n\\nThe External Action Plugin is an easy way to handle External states from the navigation of a Player flow.\\n","header":"External Action Plugin","title":"External Action"},"/plugins":{"path":"/plugins","content":"\\n\\n","title":"Plugins"},"/plugins/markdown":{"path":"/plugins/markdown","content":"\\n\\n","title":"Markdown"},"/plugins/markdown#markdown-plugin":{"path":"/plugins/markdown#markdown-plugin","content":"Markdown Plugin\\n\\nThe markdown-plugin adds support for parsing markdown content to Player Assets. This plugin is asset set agnostic, so it expects a mappers record to inform how to transform markdown content into valid Player Content with support from your asset set.\\n","header":"Markdown Plugin","title":"Markdown"},"/plugins/markdown#usage":{"path":"/plugins/markdown#usage","content":"Usage\\n\\n","header":"Usage","title":"Markdown"},"/plugins/markdown#defining-the-mappers":{"path":"/plugins/markdown#defining-the-mappers","content":"Defining The Mappers\\n\\nimport type { Mappers } from \'@player-ui/markdown-plugin\';\\n\\nexport const mappers: Mappers = {\\n  text: ({ originalAsset, value }) => ({\\n    id: ${originalAsset.id}-text,\\n    type: \'text\',\\n    value,\\n  }),\\n  image: ({ originalAsset, value, src }) => ({\\n    id: ${originalAsset.id}-image,\\n    type: \'image\',\\n    accessibility: value,\\n    metaData: {\\n      ref: src,\\n    },\\n  }),\\n  //...\\n};\\n","header":"Defining The Mappers","title":"Markdown"},"/plugins/meta":{"path":"/plugins/meta","content":"\\n\\n","title":"Meta"},"/plugins/meta#meta-plugin":{"path":"/plugins/meta#meta-plugin","content":"Meta Plugin\\n\\nThe Meta Plugin is an easy way to combine multiple other plugins into 1 group. It is often used when sharing a set of plugins across platforms (each platform registering 1 common set of core plugins).\\n","header":"Meta Plugin","title":"Meta"},"/plugins/metrics":{"path":"/plugins/metrics","content":"\\n\\n","title":"Metrics"},"/plugins/metrics#metrics-plugin":{"path":"/plugins/metrics#metrics-plugin","content":"Metrics Plugin\\n\\nThe Metrics Plugin is used to gather timing information about Player\'s execution of a flow. There are also platform specific integrations to include render and update times.\\n\\nThe diagram below illistrates some of the timing information gathered:\\n\\nMetrics Timing Diagram\\n","header":"Metrics Plugin","title":"Metrics"},"/plugins/metrics#usage":{"path":"/plugins/metrics#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { MetricsPlugin } from \'@player-ui/metrics-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new MetricsPlugin({\\n      onUpdate: (metrics) => {\\n        // Handle the update\\n      }\\n    })\\n  ]\\n})\\n\\nThe onUpdate callback will be invoked for any update to the metrics. There are also callbacks for finer-grained events (onRenderEnd, onInteractive, etc), as well as a hooks based API for even more control.\\n","header":"Usage","title":"Metrics"},"/plugins/metrics#using-a-custom-timer":{"path":"/plugins/metrics#using-a-custom-timer","content":"Using a custom timer\\n\\nBy default, all time is measured in ms using performance.now() with a fallback to the less-accurate Date.now().\\nIf you wish to supply your own timer, simply use the getTime option to set the function to use.\\n","header":"Using a custom timer","title":"Metrics"},"/plugins/metrics#measuring-render-time":{"path":"/plugins/metrics#measuring-render-time","content":"Measuring Render Time\\n\\nFor extensions of this plugin that wish to track the render (and update) times of nodes, add the trackRenderTime flag to options. You must then call metrics.renderEnd() to denote when content is painted on the screen. This is automatically handled for the platform specific versions of this plugin.\\n\\nThe react version of the Metrics Plugin adds support for render and update times to events. The API mirrors that of the core version:\\n\\nimport { ReactPlayer } from \'@player-ui/react\';\\nimport { MetricsPlugin } from \'@player-ui/metrics-plugin-react\';\\n\\nconst player = new ReactPlayer({\\n  plugins: [\\n    new MetricsPlugin({\\n      onUpdate: (metrics) => {\\n        // Handle the update\\n      }\\n    })\\n  ]\\n})\\n\\nThe ios version of the Metrics Plugin will track initial render time for each view in a flow. Due to current SwiftUI limitations, update time can\'t be tracked yet. It should be used in conjunction with a core plugin that utilizes the events.\\n\\nAdd the subspec:\\npod \'PlayerUI/MetricsPlugin\'\\n\\nConstruct the plugin:\\n\\nSwiftUIPlayer(\\n  flow: flow,\\n  plugins: [MetricsPlugin()],\\n  result: $result\\n)\\n","header":"Measuring Render Time","title":"Metrics"},"/plugins/partial-match-fingerprint":{"path":"/plugins/partial-match-fingerprint","content":"\\n\\n","title":"Partial Match"},"/plugins/partial-match-fingerprint#partial-match-plugin":{"path":"/plugins/partial-match-fingerprint#partial-match-plugin","content":"Partial Match Plugin\\n\\nThis plugin enables users to map matches of assets to any arbitrary value in a partial-match-registry.\\nFor each asset in a resolved view, the matches will be computed.\\n","header":"Partial Match Plugin","title":"Partial Match"},"/plugins/pub-sub":{"path":"/plugins/pub-sub","content":"\\n\\n","title":"PubSub"},"/plugins/pub-sub#pubsub-plugin":{"path":"/plugins/pub-sub#pubsub-plugin","content":"PubSub Plugin\\n\\nThe PubSub plugin adds a publish/subscribe interface between the host app and Player\'s content.\\n","header":"PubSub Plugin","title":"PubSub"},"/plugins/pub-sub#usage":{"path":"/plugins/pub-sub#usage","content":"Usage\\n\\n\\nAdd the plugin to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { PubSubPlugin } from \'@player-ui/pub-sub-plugin\';\\n\\nconst pubsub = new PubSubPlugin();\\n\\nconst token = pubsub.subscribe(\'some-event\', () => {\\n  // Callback\\n});\\n\\nconst player = new Player({\\n  plugins: [pubsub]\\n})\\n\\nTo unsubscribe:\\n\\npubsub.unsubscribe(token);\\n\\nIf your content uses the @[ publish() ]@ expression for actions, you can subscribe to these events by adding the PubSubPlugin to your plugin array:\\n\\nlet eventHandler: (String, AnyType?) -> Void = { (eventName, eventData) in\\n  // Handle event\\n}\\nlet plugin = PubSubPlugin([(\\"eventName\\", eventHandler)])\\n\\nIf your content uses a different name for publishing (such as publishEvent) you can customize the expression name that the plugin uses:\\n\\nlet plugin = PubSubPlugin([(\\"eventName\\", eventHandler)], options: PubSubPluginOptions(expressionName: \\"publishEvent\\"))\\n\\nNote: AnyType is a custom enum type to handle the arbitrary types that can be received from these events, as the data is set in your Player Content, ensure that it matches either String, [String], or [String: String].\\n\\nThe PubSubPlugin provides support for handling the publish expressions in Player content at the app level. The PubSubPlugin is included by default in the Android Player, so configuring events subscriptions can be done on Player using the provided extension methods.\\n\\n{\\n  \\"id\\": \\"action\\",\\n  \\"type\\": \\"action\\",\\n  \\"exp\\": \\"@[ publish(\'some-event\', {{foo.bar}}) ]@\\"\\n}\\nval player = AndroidPlayer(context)\\n\\n// extension method for subscribing to some event\\nval token = player.subscribe(\\"some-event\\") { name: String, data: Any? ->\\n    // name of event can be used for logging\\n    // data can be any structure passed by the content, if any\\n    // handle event\\n}\\n\\n// extension method for removing a specific event subscription\\nplayer.unsubscribe(token)\\n","header":"Usage","title":"PubSub"},"/plugins/set-timeout":{"path":"/plugins/set-timeout","content":"\\n\\n","title":"setTimeout Plugin"},"/plugins/set-timeout#settimeout-plugin":{"path":"/plugins/set-timeout#settimeout-plugin","content":"setTimeout Plugin\\n\\nThe only explicit runtime plugin in the core Android plugin set, the SetTimeoutPlugin is a RuntimePlugin written to provide the global setTimeout method to the runtime.\\n","header":"setTimeout Plugin","title":"setTimeout Plugin"},"/plugins/shared-constants":{"path":"/plugins/shared-constants","content":"\\n\\n","title":"Shared Constants"},"/plugins/shared-constants#shared-constants-plugin":{"path":"/plugins/shared-constants#shared-constants-plugin","content":"Shared Constants Plugin\\n\\nThe Shared Constants Plugin enables users to define and override commonly used static values. It can be leveraged by other plugins to enable localization.\\n","header":"Shared Constants Plugin","title":"Shared Constants"},"/plugins/shared-constants#usage":{"path":"/plugins/shared-constants#usage","content":"Usage\\n\\n\\nCreate the plugin and add it to Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { ConstantsPlugin } from \'@player-ui/shared-constants-plugin\';\\n\\nconst constantsPlugin = new ConstantsPlugin({\\n  data: {\\n    prop1: \'A\',\\n    prop2: \'B\'\\n  },\\n  namespace: \'constants\',\\n  dataPath: \'data.constants\'\\n});\\n\\nconst player = new Player({\\n  plugins: [ constantsPlugin ]\\n});\\n\\nYou can then query the plugin to get the value of a particular key:\\n\\nconstantsPlugin.getConstants(\'prop1\') // \'A\'\\n","header":"Usage","title":"Shared Constants"},"/plugins/shared-constants#overriding-values-in-content":{"path":"/plugins/shared-constants#overriding-values-in-content","content":"Overriding Values in Content\\n\\nThe dataPath configuration option enables content to override specific values for a particular flow:\\n\\n{\\n  \\"data\\": {\\n    \\"constants\\": {\\n      \\"prop1\\": \\"B\\"\\n    }\\n  }\\n}\\n\\nusing a similar query for prop1, the value in the content takes precidence and would return B.\\n","header":"Overriding Values in Content","title":"Shared Constants"},"/plugins/shared-constants#fallback-values":{"path":"/plugins/shared-constants#fallback-values","content":"Fallback Values\\n\\nAny query can also specify an optional default value to return:\\n\\nconstantsPlugin.getConstants(\'prop3\', \'default value\') // \'default value\'\\n","header":"Fallback Values","title":"Shared Constants"},"/plugins/shared-constants#examples":{"path":"/plugins/shared-constants#examples","content":"Examples\\n\\n","header":"Examples","title":"Shared Constants"},"/plugins/stage-revert-data":{"path":"/plugins/stage-revert-data","content":"\\n\\n","title":"Stage Revert Data"},"/plugins/stage-revert-data#stage-rvert-data":{"path":"/plugins/stage-revert-data#stage-rvert-data","content":"Stage Rvert Data\\n\\nThis plugin enables users to temporarily stage data changes before committing to the actual data model\\n\\nA stageData property flag inside of the view properties must be added on the desired view configs.\\n\\n{\\n  \\"VIEW_1\\": {\\n    \\"state_type\\": \\"VIEW\\",\\n    \\"ref\\": \\"view-1\\",\\n    \\"attributes\\": {\\n      \\"stageData\\": true,\\n      \\"commitTransitions\\": [\\"VIEW_2\\"]\\n    },\\n    \\"transitions\\": {\\n      \\"next\\": \\"VIEW_2\\",\\n      \\"*\\": \\"ACTION_1\\"\\n    }\\n  }\\n}\\n\\nIt also should include a list of acceptable commitTransitions valid VIEW name for the data to be committed when the transition occurs, A not included commit transition would trigger the staged data to be cleared. An acceptable transition will commit the data into the data model. e.g. as per the previous example transitioning to VIEW_2 will trigger the staged data to get committed in the model, since the next transition property is pointing to it and is listed on the commitTransitions array parameter, otherwise it would get thrown away.\\n","header":"Stage Rvert Data","title":"Stage Revert Data"},"/plugins/swiftui-pending-transaction":{"path":"/plugins/swiftui-pending-transaction","content":"\\n\\n\\ntitle: SwiftUIPendingTransactionPlugin\\nplatform: ios\\n"},"/plugins/swiftui-pending-transaction#swiftuipendingtransactionplugin":{"path":"/plugins/swiftui-pending-transaction#swiftuipendingtransactionplugin","content":"SwiftUIPendingTransactionPlugin\\n\\nThe SwiftUIPendingTransactionPlugin allows you to register pending transactions (callbacks) in the userInfo on the decoder. Users can decide when to register, commit and clear transactions based on the use case. Anytime there is a scenario where we want a native transaction to happen while a view update is taking place, we can make use of this plugin. Below is an example used in the sample app where we can see this take place:\\n","header":"SwiftUIPendingTransactionPlugin"},"/plugins/swiftui-pending-transaction#the-issue":{"path":"/plugins/swiftui-pending-transaction#the-issue","content":"The Issue:\\n\\nWhen you enter text on input and then click on an action to try to navigate (which triggers a view update), the text gets wiped out and only saves you hit enter or click on another input field.\\n","header":"The Issue:"},"/plugins/transition":{"path":"/plugins/transition","content":"\\n\\n","title":"Transition Plugin"},"/plugins/transition#transition-plugin":{"path":"/plugins/transition#transition-plugin","content":"Transition Plugin\\n\\nThe TransitionPlugin allows for specifying transitions for when Player loads a flow, and for transition between views in the same flow.\\n","header":"Transition Plugin","title":"Transition Plugin"},"/plugins/transition#usage":{"path":"/plugins/transition#usage","content":"Usage\\n\\nAdd the optional subspec to your Podfile or podspec:\\n\\npod \'PlayerUI/TransitionPlugin\'\\nSwiftUIPlayer(flow: flowString, plugins: [TransitionPlugin(popTransition: .pop)], result: $resultBinding)\\n","header":"Usage","title":"Transition Plugin"},"/plugins/transition#customizing-transitions":{"path":"/plugins/transition#customizing-transitions","content":"Customizing Transitions\\n\\nTo specify different transition, just supply a PlayerViewTransition to the plugin initializer:\\n\\nlet customTransition = PlayerViewTransition(\\n  transition: AnyTransition.opacity,\\n  animationCurve: Animation.linear\\n)\\nlet plugin = TransitionPlugin(\\n  stateTransition: customTransition,\\n  pushTransition: customTransition,\\n  popTransition: customTransition\\n)\\n","header":"Customizing Transitions","title":"Transition Plugin"},"/plugins/types-provider":{"path":"/plugins/types-provider","content":"\\n\\n","title":"Types Provider"},"/plugins/types-provider#types-provider-plugin":{"path":"/plugins/types-provider#types-provider-plugin","content":"Types Provider Plugin\\n\\nSimilar to the Expression Plugin, this plugin adds support for easily exposing new DataTypes, formats, and validations to Player\'s content.\\n","header":"Types Provider Plugin","title":"Types Provider"},"/plugins/types-provider#example":{"path":"/plugins/types-provider#example","content":"Example\\n\\n\\nDefine a new validation type:\\n\\nimport { ValidatorFunction } from \'@player-ui/player\';\\n\\nconst customValidator: ValidatorFunction = (context, value) => {\\n  if (value === \'bad-value\') {\\n    return {\\n      message: \\"This is a bad value.\\"\\n    }\\n  }\\n}\\n\\nCreate a new DataType that references it:\\n\\nimport { Schema } from \'@player-ui/player\';\\n\\nconst CustomDataType: Schema.DataType = {\\n  name: \'CustomType\',\\n  validation: [\\n    {\\n      type: \\"custom-validator\\"\\n    }\\n  ]\\n}\\n\\nRegister it with Player:\\n\\nimport { Player } from \'@player-ui/player\';\\nimport { TypesProviderPlugin } from \'@player-ui/types-provider-plugin\';\\n\\nconst player = new Player({\\n  plugins: [\\n    new TypesProviderPlugin({\\n      types: [CustomDataType],\\n      validations: [\\n        [\'custom-validator\', customValidator]\\n      ]\\n    })\\n  ]\\n});\\n\\nGiven a data-type reference to CustomType in the content, your new validation will be used:\\n\\n{\\n  \\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"data\\": {\\n        \\"type\\": \\"CustomDataType\\"\\n      }\\n    }\\n  }\\n}\\n\\nA wrapper is provided for the types-provider plugin for Core Player. This allows the use of Swift code to create custom types, validators, and formatters.\\n","header":"Example","title":"Types Provider"},"/plugins/types-provider#custom-validator":{"path":"/plugins/types-provider#custom-validator","content":"Custom Validator\\n\\nlet validationFunction = {context, value, options in\\n    if value == goodValue {\\n      return nil // Return nil to pass the validation\\n    } else {\\n      return [\\"message\\": \\"This Value is bad!\\"]\\n    }\\n}\\n\\nlet validator = ValidationDeclaration(\\n  type: \\"customValidator\\",\\n  handler: validationFunction\\n)\\n\\nlet plugin = TypesProviderPlugin(types: [], validators: [validator], formats: [])\\n\\nthen in the JSON schema for your type:\'\'\\n\\n\\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"\\": {\\n        \\"validation\\": [\\n            {\\"type\\": \\"customValidator\\"}\\n        ]\\n      }\\n    }\\n  }\\n","header":"Custom Validator","title":"Types Provider"},"/plugins/types-provider#custom-formatter":{"path":"/plugins/types-provider#custom-formatter","content":"Custom Formatter\\n\\nlet formatFunction = {value, options in\\n  if let stringValue = value as? String {\\n    return stringValue.replacingOccurrences(of: \\".\\", with: \\",\\") // Turn all periods into commas\\n  } else {\\n  \\treturn value\\n  }\\n}\\n\\nlet formatter = FormatDeclaration(\\n  name: \\"customFormatter\\",\\n  format: formatFunction,\\n  deformat: nil\\n)\\nlet plugin = TypesProviderPlugin(types: [], validators: [], formats: [formatter])\\n\\nthen in the JSON schema for your type:\\n\\n\\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"\\": {\\n          \\"format\\": {\\n              \\"type\\": \\"customFormatter\\"\\n          }\\n      }\\n    }\\n  }\\n","header":"Custom Formatter","title":"Types Provider"},"/plugins/types-provider#formatting-options":{"path":"/plugins/types-provider#formatting-options","content":"Formatting Options\\n\\nThe second parameter passed to the format/deformat functions is for additional options, it is of type [String: Any] and contains any other keys that were passed alongside the type of the formatter:\\n\\n\\"format\\": {\\n  \\"type\\": \\"customFormatter\\",\\n  \\"character\\": \\"X\\"\\n}\\n\\nlet formatFunction = {value, options in\\n  if let stringValue = value as? String {\\n    let char = options[\\"character\\"] as? String ?? \\",\\"\\n    return stringValue.replacingOccurrences(of: \\".\\", with: char)\\n    // Turn all periods into the specified character\\n  } else {\\n  \\treturn value\\n  }\\n}\\n","header":"Formatting Options","title":"Types Provider"},"/plugins/types-provider#custom-types":{"path":"/plugins/types-provider#custom-types","content":"Custom Types\\n\\nJust as you can define custom formats and validation, you can define a custom type that encapsulates that functionality into a type, to avoid the need to keep specifying options, this is how the common-types are defined, so when you choose a type like DateType the formatting is already set up.\\n\\nlet type = CustomType(\\n  type: \\"CustomType\\",\\n  validation: [\\n    ValidationReference(type: \\"customValidator\\")\\n  ],\\n  format: FormatReference(type: \\"customFormatter\\")\\n)\\n\\n// Construct the plugin\\nlet plugin = TypesProviderPlugin(types: [type], validators: [validator], formats: [formatter])\\n\\nthen in your JSON schema:\\n\\n\\"schema\\": {\\n    \\"ROOT\\": {\\n      \\"foo\\": {\\n        \\"type\\": \\"CustomType\\"\\n      }\\n    }\\n  }\\n","header":"Custom Types","title":"Types Provider"},"/tools/cli":{"path":"/tools/cli","content":"\\n\\n","title":"CLI"},"/tools/cli#cli":{"path":"/tools/cli#cli","content":"CLI\\n\\nThe CLI package is a simple way for users to interact with some of the build/validation tooling. As new capabilities are added to the ecosystem, they may be exposed via this cli to use of use for developers.\\n","header":"CLI","title":"CLI"},"/tools/cli#config":{"path":"/tools/cli#config","content":"Config\\n\\nConfig files are able to customize the behavior of the CLI commands without requiring args. Behavior specific to execution can leverage plugins, which can be composed together using presets. Full configs can also be shared using extensions.\\n\\nTo resolve a full configuration, the extension is taken as the base, the presets are applied in order, then local plugins.\\nThe format is similar to eslint, babel and other .rc/json/js based approaches.\\n\\nConfig files are searched using cosmiconfig, which will look for:\\n\\na player property in package.json\\na .playerrc file in JSON or YAML format\\na .player.json, .playerrc.yaml, .playerrc.yml, .playerrc.js, or .playerrc.cjs file\\na player.config.js or player.config.cjs CommonJS module exporting an object\\n\\nExample:\\n\\nmodule.exports = {\\n  extends: \'@my-scope/base\',\\n  plugins: [\\n    \'plugin-npm-package\',\\n    [\'some-plugin-with-config\', { config: true }],\\n    {\\n      // Plugins can also be defined inline\\n      handler: () => {},\\n    },\\n  ],\\n};\\n\\nOptions defined via the CLI arguments will take precedence over the config files (for things that overlap).\\n","header":"Config","title":"CLI"},"/tools/cli#plugins":{"path":"/tools/cli#plugins","content":"Plugins\\n\\nPlugins are the way to change runtime behavior of the CLI actions. This includes augmenting the behavior of the DSL compiler, language-service, and more.\\n","header":"Plugins","title":"CLI"},"/tools/dsl":{"path":"/tools/dsl","content":"\\n\\n","title":"Writing content using TSX"},"/tools/dsl#tsx-content-authoring":{"path":"/tools/dsl#tsx-content-authoring","content":"TSX Content Authoring\\n\\nWhile JSON content makes for a decent transport layer, it\'s not always the preferable authoring format. To take advantage of existing developer tool-chains, Player provides a mechanism for authoring content in (J/T)SX as React components. This is paired with a cli to transpile the React tree into a JSON content.\\n","header":"TSX Content Authoring","title":"Writing content using TSX"},"/tools/dsl#writing-tsx-content":{"path":"/tools/dsl#writing-tsx-content","content":"Writing TSX Content\\n\\nIn order to use the TSX-variant to write content, your asset library should ship a TSX component package to leverage. Read more here for more details on creating one.\\n\\nIn the examples below, we will assume one already exists.\\n","header":"Writing TSX Content","title":"Writing content using TSX"},"/tools/dsl#assetsviews":{"path":"/tools/dsl#assetsviews","content":"Assets/Views\\n\\nAssets and views are treated as basic React elements:\\n\\nimport { Input, Text, Collection } from \'@player-ui/reference-assets-components\';\\n\\nconst view = (\\n\\n    Some value\\n\\n      Some label\\n\\n);\\n\\nwhich would generate something equivalent to:\\n\\n{\\n  \\"id\\": \\"root\\",\\n  \\"type\\": \\"collection\\",\\n  \\"values\\": [\\n    {\\n      \\"asset\\": {\\n        \\"id\\": \\"root-values-1\\",\\n        \\"type\\": \\"text\\",\\n        \\"value\\": \\"Some value\\"\\n      }\\n    },\\n    {\\n      \\"asset\\": {\\n        \\"id\\": \\"root-values-2\\",\\n        \\"type\\": \\"input\\",\\n        \\"label\\": {\\n          \\"asset\\": {\\n            \\"id\\": \\"root-values-2-label\\",\\n            \\"type\\": \\"text\\",\\n            \\"value\\": \\"Some label\\"\\n          }\\n        }\\n      }\\n    }\\n  ]\\n}\\n","header":"Assets/Views","title":"Writing content using TSX"},"/tools/dsl#automatic-id-generation":{"path":"/tools/dsl#automatic-id-generation","content":"Automatic ID generation\\n\\nAny component leveraging the base Asset component will automatically generate an id if one isn\'t provided.\\n","header":"Automatic ID generation","title":"Writing content using TSX"},"/tools/dsl#automatic-textcollection-generation":{"path":"/tools/dsl#automatic-textcollection-generation","content":"Automatic Text/Collection generation\\n\\nIn thee event that an asset is expected, but a string or number is found, a Text node will automatically be created (provided the asset-library as a text-asset-factory configured).\\n\\nSimilarly, if a single asset is expected, but a list is found, a Collection node will be created.\\n","header":"Automatic Text/Collection generation","title":"Writing content using TSX"},"/tools/dsl#bindingsexpressions":{"path":"/tools/dsl#bindingsexpressions","content":"Bindings/Expressions\\n\\nBoth binding and expression in the TSX authoring leverages a tagged template, typically abbreviated as b and e respectively. In a similar fashion to using css or graphql in a TS/JS file, this enables syntax-highlighting and validation of bindings and expressions within a JS file.\\n\\nTo create a binding or expression:\\n\\nimport { binding as b, expression as e } from \'@player-tools/dsl\';\\n\\nconst myBinding = bfoo.bar;\\nconst myExpression = efoo();\\n\\nBindings and expressions can also be used within template strings and automatically dereference themselves:\\n\\nconst stringWithBinding = Some text: ${myBinding}; // \'Some text: {{foo.bar}}\'\\nconst stringWithExp = Some expr: ${myExpression}; // \'Some expr: @[foo()]@\'\\n","header":"Bindings/Expressions","title":"Writing content using TSX"},"/tools/dsl#templates":{"path":"/tools/dsl#templates","content":"Templates\\n\\nTemplate support is included via the @player-tools/dsl package. This can be used in place of an asset slot:\\n\\n      Template Value\\n\\n    Value 1\\n\\nTemplates can be nested within one another, and the auto-id generation will handle adding the index information to any generated id.\\n","header":"Templates","title":"Writing content using TSX"},"/tools/dsl#switches":{"path":"/tools/dsl#switches","content":"Switches\\n\\nIncluded as well is the ability to specify switches:\\n\\n        Text 1\\n\\n        Text 1\\n\\nUse the isDynamic flag to denote if it should be a static or dynamic switch.\\n","header":"Switches","title":"Writing content using TSX"},"/tools/dsl#schema":{"path":"/tools/dsl#schema","content":"Schema\\n\\nThe detailed format for the schema section is described here. The schema object is a mix of JS object structure with leaf nodes that are Player data types or type references. At DSL compile time, this data sctructure will be compiled down into the schema format required in JSON. While you can write the schema in the native format, using this noation allows it to be referenced directly in the TSX content in addition to being much more intuitive to write.\\n","header":"Schema","title":"Writing content using TSX"},"/tools/dsl#navigation":{"path":"/tools/dsl#navigation","content":"Navigation\\n\\nThe navigation content segment is a basic JS object. The @player-ui/player package exports TypeScript interfaces which can provide typings for these:\\n\\nimport { Navigation } from \'@player-ui/player\';\\n\\nconst navigation: Navigation = {\\n  BEGIN: \'Start\',\\n  Start: {\\n    startState: \'VIEW_1\',\\n    VIEW_1: {\\n      state_type: \'VIEW\',\\n      ref: \'view-1\',\\n      transitions: {\\n        \'*\': \'END_Done\',\\n      },\\n    },\\n    END_Done: {\\n      state_type: \'END\',\\n      outcome: \'done\',\\n    },\\n  },\\n};\\n","header":"Navigation","title":"Writing content using TSX"},"/tools/dsl#creating-tsx-components":{"path":"/tools/dsl#creating-tsx-components","content":"Creating TSX Components\\n\\nIn order to take advantage of the auto-completion and validation of TypeScript types, asset libraries can export a component library for content authoring. Creating components isn\'t much different than writing a React component for the web. The primative elements uses the react-json-reconciler to create the JSON content tree, with utilities to make it quick and painless to create new asset-components.\\n","header":"Creating TSX Components","title":"Writing content using TSX"},"/tools/dsl#creating-a-basic-component":{"path":"/tools/dsl#creating-a-basic-component","content":"Creating a basic component\\n\\nThe Asset component from the @player-tools/dsl package is the quickest way to create a new component.\\n\\nIn the examples below, we\'ll be creating a TSX component for the action asset in our reference set.\\n\\nThe action asset has a label slot (which is typically used as a text asset), a value (for flow transitions), and an exp for evaluating expressions.\\nIt\'s type resembles something akin to:\\n\\nimport { Asset, AssetWrapper, Expression } from \'@player-ui/player\';\\n\\nexport interface ActionAsset extends Asset {\\n  /* The transition value of the action in the state machine /\\n  value?: string;\\n\\n  /* A text-like asset for the action\'s label /\\n  label?: AssetWrapper;\\n\\n  /* An optional expression to execute before transitioning /\\n  exp?: Expression;\\n}\\n\\nTo turn this interface into a usable component, create a new React component that renders an Asset:\\n\\nimport { Asset, AssetPropsWithChildren } from \'@player-tools/dsl\';\\n\\nexport const Action = (props: AssetPropsWithChildren) => {\\n  return ;\\n}\\n\\nThis would allow users to import the Action component, and render it to JSON:\\n\\nconst myView =\\n\\nThe AssetPropsWithChildren type is a utility type to help convert the Asset type (which has a required id and type properties) to a type more suited for components. It changes the id to be optional, and adds a applicability property automatically.\\n","header":"Creating a basic component","title":"Writing content using TSX"},"/tools/storybook":{"path":"/tools/storybook","content":"\\n\\n","title":"Player + Storybook Integration"},"/tools/storybook#reference-assets":{"path":"/tools/storybook#reference-assets","content":"Reference Assets\\n\\nThe reference asset set, complete with the storybook-plugin integration below is available here\\n","header":"Reference Assets","title":"Player + Storybook Integration"},"/tools/storybook#storybook-plugin":{"path":"/tools/storybook#storybook-plugin","content":"Storybook Plugin\\n\\nThe @player-ui/storybook package is a storybook addon + wrapper that provides easy-to-use mechanisms for integrating Player flows into storybook.\\n","header":"Storybook Plugin","title":"Player + Storybook Integration"},"/tools/storybook#installation":{"path":"/tools/storybook#installation","content":"Installation\\n\\nThere are a few different parts required to integrate with storybook.\\n\\nStart by installing @player-ui/storybook:\\n\\nyarn add @player-ui/storybook\\n\\nNext, add @player-ui/storybook to the addons section in .storybook/main.js\\n\\nmodule.exports = {\\n  addons: [\\n    \'@player-ui/storybook\'\\n  ]\\n}\\n\\nIn .storybook/preview.js add the PlayerDecorator:\\n\\nimport { PlayerDecorator } from \'@player-ui/storybook\';\\n\\nexport const decorators = [\\n  PlayerDecorator\\n];\\n\\nLastly use the PlayerStory component to render a flow:\\n\\nimport { PlayerStory } from \'@player-ui/storybook\';\\n\\nexport const MyStory = (\\n\\n)\\n\\nThe reactPlayerPlugins story parameter allows you to add any custom plugins (like asset providers) to a story. This can also be set in the .storybook/preview.js file as a global option:\\n\\nimport { ReferenceAssetsPlugin } from \'@player-ui/reference-assets-plugin-react\';\\n\\nexport const parameters = {\\n  reactPlayerPlugins: [\\n    new ReferenceAssetsPlugin()\\n  ],\\n}\\n","header":"Installation","title":"Player + Storybook Integration"},"/tools/storybook#panels":{"path":"/tools/storybook#panels","content":"Panels\\n\\n","header":"Panels","title":"Player + Storybook Integration"},"/tools/storybook#events":{"path":"/tools/storybook#events","content":"Events\\n\\nThe events panel addon shows a timeline of events as the flow is processed. Here you will see logs, render/update metrics, data mutations, and more.\\n\\nEvents Addon Panel\\n","header":"Events","title":"Player + Storybook Integration"},"/tools/storybook#flow":{"path":"/tools/storybook#flow","content":"Flow\\n\\nThe flow panel addon enables users to view and edit the JSON content in the running Player.\\n\\nFlow Addon Panel\\n","header":"Flow","title":"Player + Storybook Integration"},"/xlr/concepts":{"path":"/xlr/concepts","content":"\\n\\n","title":"XLR Concepts"},"/xlr/concepts#xlr-definitions":{"path":"/xlr/concepts#xlr-definitions","content":"XLR Definitions\\n\\nWhen talking about anything its helpful to make sure everyone is on the same page, XLR is no exception. In this section we\'ll explore some concepts related to XLRs, how they work, and how they\'re used.\\n","header":"XLR Definitions","title":"XLR Concepts"},"/xlr/concepts#capability":{"path":"/xlr/concepts#capability","content":"Capability\\n\\nWhen we talk about a Capability, we are essentially talking about what it provides to Player. Most, if not all, capabilities are provided by Plugins. Capabilities are described in the manifest file in the xlr folder of a distribution. The manifest file, provided as both a .json and a .js file for static or dynamic use, contains the mapping of capabilities to a list of the XLRs.\\n","header":"Capability","title":"XLR Concepts"},"/xlr/concepts#xlr-objects":{"path":"/xlr/concepts#xlr-objects","content":"XLR Objects\\n\\nXLRs contain all of the information about a TypeScript type or interface. For an interface it will have the information on what parameters it has, the types of those parameters, and if those parameters are optional. For a type, it will similarly describe the properties/types that compose it. There is no distinction in XLR on whether the XLR came from a type or an interface as everything is just represented by a Node.\\n","header":"XLR Objects","title":"XLR Concepts"},"/xlr/concepts#xlr-nodes":{"path":"/xlr/concepts#xlr-nodes","content":"XLR Nodes\\nXLR nodes are similar to TypeScripts internal AST nodes but a bit simpler. Almost every type/language feature you would use in TypeScript has an equivalent XLR node type. The definitions for these types are available in the @player-tools/xlr package.\\n","header":"XLR Nodes","title":"XLR Concepts"},"/xlr/concepts#named-types":{"path":"/xlr/concepts#named-types","content":"Named Types\\n\\nNamed Types represent a top level interface/type and can be any XLR Node. Named types are generated from interfaces/types that are exported from a source file or plugin. It should be noted that when generating a Named Type, all referenced types are also serialized and included in place in the Named Type and not exported separately. That is unless The type is listed as a Custom Primitive. A reason to do this would be if that type definition changes based on use case or platform. For example, in the Player ecosystem Asset is considered a Custom Primitive because depending on the context, we might need to swap it out with a different type.\\n","header":"Named Types","title":"XLR Concepts"},"/xlr/concepts#xlr-sdk":{"path":"/xlr/concepts#xlr-sdk","content":"XLR SDK\\n\\nThe XLR SDK is used to abstract away the more tedious interactions XLRs like loading them from their package, managing them when they\'re loaded, and validating content against them. The SDK does include an simple object store so that it can be used out of the box, however if your use case requires some different logic it can be extended quite easily. In fact, we do that in the Player LSP.\\n","header":"XLR SDK","title":"XLR Concepts"},"/xlr/intro":{"path":"/xlr/intro","content":"\\n\\n","title":"Into to XLR"},"/xlr/intro#what-is-xlr":{"path":"/xlr/intro#what-is-xlr","content":"What is XLR\\n\\nXLR, short for cross(x) language representation, is a way to export a static and language agnostic description of a TypeScript type or interface packaged along with the original type or interface. XLR started as a fork of core-types to add support for some missing features (generics, supported types, inheritance) that are heavily used in Player but has evolved into a superset of its features with some opinionated functionality to support Player specific conventions. XLR now powers a majority of the Player language features such as content validation, editor suggestions, and in editor documentation.\\n","header":"What is XLR","title":"Into to XLR"},"/xlr/intro#why-do-we-need-it":{"path":"/xlr/intro#why-do-we-need-it","content":"Why Do We Need it\\n\\nXLR was developed to fill in one of the major gaps in the Player ecosystem: Because everything is dynamic, there is no way to statically/programmatically know what plugin provides what capabilities (assets, data types, validations, etc) to Player and what that capability looks like. This becomes a real issue in the tooling around Player when things like content authoring and validation. In both use-cases information on what assets are available for use, what parameters do those assets require, what types are those parameters, etc. is required but cannot be assumed. Historically we have seen this gap bridged by hardcoding the set of capabilities that are available but that has proven to be a never ending cycle of keeping those definitions updated when things change and knowing about the entire set of capabilities, even those that people develop silently. With XLR, a static description of all capabilities provided by a plugin can be compiled at build time, included in the package, and used at any point in the future for a multitude of capabilities.\\n","header":"Why Do We Need it","title":"Into to XLR"},"/xlr/intro#how-do-i-leverage-xlr":{"path":"/xlr/intro#how-do-i-leverage-xlr","content":"How Do I Leverage XLR\\n\\nHow much you use XLR is pretty dependant on your niche in the Player ecosystem.\\n","header":"How Do I Leverage XLR","title":"Into to XLR"},"/xlr/intro#as-a-typescript-plugincapability-author":{"path":"/xlr/intro#as-a-typescript-plugincapability-author","content":"As a TypeScript Plugin/Capability Author\\n\\nIf you are developing Player capabilities for Core/React, all you need to do is have your Plugin fill in the ExtendedPlayerPlugin interface and run the Player CLI during build time and the CLI will take care of compiling and bundling the capabilities. You can see an example of this in the Exporting Plugin Capabilities section.\\n","header":"As a TypeScript Plugin/Capability Author","title":"Into to XLR"},"/xlr/usage":{"path":"/xlr/usage","content":"\\n\\n","title":"Using XLR"},"/xlr/usage#part-1---creating-xlrs":{"path":"/xlr/usage#part-1---creating-xlrs","content":"Part 1 - Creating XLRs\\n\\nXLR creation is done through the Player CLI which can be added to your project like so:\\n\\nyarn install @player-tools/cli\\n","header":"Part 1 - Creating XLRs","title":"Using XLR"},"/xlr/usage#exporting-base-type-definitions":{"path":"/xlr/usage#exporting-base-type-definitions","content":"Exporting Base Type Definitions\\n\\nIf you want to compile all exported interfaces/types to XLRs run the following command as part of your build\\n\\nplayer xlr compile -m types\\n","header":"Exporting Base Type Definitions","title":"Using XLR"},"/xlr/usage#exporting-plugin-capabilities":{"path":"/xlr/usage#exporting-plugin-capabilities","content":"Exporting Plugin Capabilities\\n\\nIf you are writing a Player Plugin, you\'ll first need to have your plugin extend the ExtendedPlayerPlugin interface and fill in the generics with an array of the interfaces/types for each Capability. For example, you can see how its done below in the core reference assets plugin\\n\\nexport class ReferenceAssetsPlugin\\n  implements\\n    PlayerPlugin,\\n    ExtendedPlayerPlugin\\n\\nThen run the following command as part of your build\\n\\nplayer xlr compile -m plugin\\n","header":"Exporting Plugin Capabilities","title":"Using XLR"},"/xlr/usage#part-2---using-xlrs":{"path":"/xlr/usage#part-2---using-xlrs","content":"Part 2 - Using XLRs\\n\\n","header":"Part 2 - Using XLRs","title":"Using XLR"},"/xlr/usage#sdk-initialization":{"path":"/xlr/usage#sdk-initialization","content":"SDK: Initialization\\n\\nTo start using the XLR SDK you\'ll need to install the SDK package\\n\\nyarn install @player-tools/xlr-sdk\\n\\nNext, import the SDK\\n\\nimport { XLRSDK } from \\"@player-tools/xlr-sdk\\"\\n\\nIf you want to implement a custom object store, also import the XLRRegistry interface and have your custom registry implement it.\\n\\nLastly, just initialize an instance of it.\\n\\nimport { XLRSDK } from \\"@player-tools/xlr-sdk\\"\\n\\nconst sdk = new XLRSDK();\\n\\nor if you want to use your custom registry, just pass it in to the initializer.\\n\\nimport { XLRSDK } from \\"@player-tools/xlr-sdk\\"\\nimport { customRegistry } from \\"./customRegistry\\"\\n\\nconst sdk = new XLRSDK(customRegistry);\\n","header":"SDK: Initialization","title":"Using XLR"},"/xlr/usage#sdk-loading-types":{"path":"/xlr/usage#sdk-loading-types","content":"SDK: Loading Types\\n\\nIf you want to load XLR types from disk, you can use the loadDefinitionsFromDisk function and pass it the path to parent folder of the xlr directory.\\n\\nconst sdk = new XLRSDK();\\nsdk.loadDefinitionsFromDisk(\'./common/static_xlrs/core\');\\n\\nIf you want to load XLR types from a module, you can use the loadDefinitionsFromModule function and pass it the module to load from.\\n\\nconst sdk = new XLRSDK();\\nsdk.loadDefinitionsFromModule(require(\\"@player-ui/reference-assets-plugin\\").path);\\n\\nIf you want to filter any of the types that are being loaded, you can supply a Filters object as the second arguments\\nIf you want to apply any transform functions to the modules that you load, you can supply a list of TransformFunction as the third argument\\n","header":"SDK: Loading Types","title":"Using XLR"},"/xlr/usage#sdk-usage":{"path":"/xlr/usage#sdk-usage","content":"SDK: Usage\\n\\nAfter the types are loaded into the SDK there are a couple ways to interact with them.\\n","header":"SDK: Usage","title":"Using XLR"},"/xlr/usage#type-recall":{"path":"/xlr/usage#type-recall","content":"Type Recall\\n\\nTo get a type back you can use the getType function and pass the name of the type you want to retrieve. You can also use the hasType function to check to see if the type exists before you try and access it.\\n\\nconst sdk = new XLRSDK();\\nif(sdk.hasType(\\"InputAsset\\")){\\n  return sdk.getType(\\"InputAsset\\")\\n} else {\\n  throw new Error(\\"Oh no!\\")\\n}\\n","header":"Type Recall","title":"Using XLR"}}')}}]);