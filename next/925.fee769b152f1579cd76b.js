"use strict";(self.webpackChunk_player_ui_docs=self.webpackChunk_player_ui_docs||[]).push([[925],{83190:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>g});var a=t(52112);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},y=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=c(t),y=o,g=u["".concat(s,".").concat(y)]||u[y]||p[y]||l;return t?a.createElement(g,r(r({ref:n},d),{},{components:t})):a.createElement(g,r({ref:n},d))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var l=t.length,r=new Array(l);r[0]=y;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[u]="string"==typeof e?e:o,r[1]=i;for(var c=2;c<l;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}y.displayName="MDXCreateElement"},40925:(e,n,t)=>{t.r(n),t.d(n,{default:()=>d});t(52112);var a=t(83190),o=t(60742);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},l.apply(this,arguments)}const r=(i="PlatformTabs",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",e)});var i;const s={},c=(0,o.A)({title:"AsyncNode Plugin",platform:"core,react,ios,android",tableOfContents:[{text:"Async Node Plugin",id:"async-node-plugin",level:1},{text:"Continuous Streaming",id:"continuous-streaming",level:3},{text:"Usage",id:"usage",level:2},{text:"CocoaPods",id:"cocoapods",level:3},{text:"Swift Usage",id:"swift-usage",level:3}]});function d(e){let{components:n,...t}=e;return(0,a.yg)(c,l({},s,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"async-node-plugin"},(0,a.yg)("a",{parentName:"h1",href:"#async-node-plugin"},"Async Node Plugin")),(0,a.yg)("p",null,"The AsyncNode Plugin is used to enable streaming additional content into a flow that has already been loaded and rendered.",(0,a.yg)("br",{parentName:"p"}),"\n","A common use case for this plugin is conversational UI, as the users input more dialogue, new content must be streamed into Player in order to keep the UI up to date."),(0,a.yg)("p",null,"The pillar that makes this possible is the concept of an ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNode"),". An ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNode")," is any tree node with the property ",(0,a.yg)("inlineCode",{parentName:"p"},"async: true"),", it represents a placeholder node that will be replaced by a concrete node in the future."),(0,a.yg)("p",null,"In the example below, node with the id “some-async-node” will not be rendered on first render, but will be replaced with a UI asset node at a later time:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "id": "flow-1",\n    "views": [\n      {\n        "id": \'action\',\n        "actions": [\n          {\n            "id": "some-async-node",\n            "async": true,\n          },\n        ],\n      },\n    ],\n  ...\n}\n')),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNodePlugin")," exposes an ",(0,a.yg)("inlineCode",{parentName:"p"},"onAsyncNode")," hook on all platforms. The ",(0,a.yg)("inlineCode",{parentName:"p"},"onAsyncNode")," hook will be invoked with the current node when the plugin is available and an ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNode")," is detected during the resolve process. The node used to call the hook with could contain metadata according to content spec."),(0,a.yg)("p",null,"User should tap into the ",(0,a.yg)("inlineCode",{parentName:"p"},"onAsyncNode")," hook to examine the node’s metadata before making a decision on what to replace the async node with. The return could be a single asset node or an array of asset nodes, or the return could be even a null|undefined if the async node is no longer relevant."),(0,a.yg)("p",null,"Returning a value in the above context enables uses cases where the async node only needs to be resolved once. For use cases where the async node needs to be updated multiple times, the onAsyncNode hook provides a second callback argument that can be used to update the value multiple times. For example, if the async node is used to represent some placeholder for toasts, or notifications, the async node handler could initially resolve with some content, and then update with null after some time to remove those views."),(0,a.yg)("h3",{id:"continuous-streaming"},(0,a.yg)("a",{parentName:"h3",href:"#continuous-streaming"},"Continuous Streaming")),(0,a.yg)("p",null,"In order to keep streaming in new content, there must be at least 1 or more ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNode"),"s in the view tree at all times.",(0,a.yg)("br",{parentName:"p"}),"\n","This means there must be a constant renewal of new ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNode"),"s after the previous ones are resolved by the user."),(0,a.yg)("h2",{id:"usage"},(0,a.yg)("a",{parentName:"h2",href:"#usage"},"Usage")),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNodePlugin")," itself accepts an options object with a ",(0,a.yg)("inlineCode",{parentName:"p"},"plugins")," array, enabling the integration of multiple view plugins for extended functionality.\nThe ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNodePluginPlugin")," is provided as a default way of handling asset-async nodes, it is just one handler for one possible way of using async nodes. If the default behavior does not align with the desired usage, users are able to provide their own implementation of the handler in the form of a plugin to be passed to the base ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNodePlugin"),". The ",(0,a.yg)("inlineCode",{parentName:"p"},"AsyncNodePluginPlugin")," also comes from the ",(0,a.yg)("inlineCode",{parentName:"p"},"'@player-ui/async-node-plugin'")," and contains the resolver and parser functionality."),(0,a.yg)(r,{mdxType:"PlatformTabs"},(0,a.yg)("core",null,(0,a.yg)("p",null,"Add the plugin to Player:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"import { Player } from '@player-ui/player';\nimport { AsyncNodePlugin, AsyncNodePluginPlugin } from '@player-ui/async-node-plugin';\n\nconst asyncNodePlugin = new AsyncNodePlugin({\n    plugins: [new AsyncNodePluginPlugin()],\n});\n\n// Configuring async node behaviour\nasyncNodePlugin.hooks.onAsyncNode.tap('handleAsync', async (node: Node.Node) => {\n  ...\n  // Determine what to return to be parsed into a concrete UI asset\n});\n\n// For use cases where the async node needs to be updated multiple times\n\nasyncNodePlugin.hooks.onAsyncNode.tap(\"toast-provider\", async (node: Node.Async, update: (content) => void) => {\n    ...\n  // do some async task to get content\n  const toastContent = await makeToastFor(node.id);\n  // set timer for 5 seconds to remove the toast content from the view\n  setTimeout(() => update(null), 5000);\n  // uses same mechanism as before\n  return toastContent;\n});\n\nconst player = new Player({\n  plugins: [\n    asyncNodePlugin\n  ]\n})\n"))),(0,a.yg)("react",null,(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"react")," version of the AsyncNodePlugin is identical to using the core plugin. Refer to core usage for handler configuration:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-js"},"import { ReactPlayer } from '@player-ui/react';\nimport { AsyncNodePlugin, AsyncNodePluginPlugin } from '@player-ui/async-node-plugin';\n\nconst asyncNodePlugin = new AsyncNodePlugin({\n    plugins: [new AsyncNodePluginPlugin()],\n});\n\nconst player = new ReactPlayer({\n  plugins: [\n    asyncNodePlugin\n  ]\n})\n"))),(0,a.yg)("ios",null,(0,a.yg)("h3",{id:"cocoapods"},(0,a.yg)("a",{parentName:"h3",href:"#cocoapods"},"CocoaPods")),(0,a.yg)("p",null,"Add the subspec to your ",(0,a.yg)("inlineCode",{parentName:"p"},"Podfile")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ruby"},"pod 'PlayerUI/AsyncNodePlugin'\n")),(0,a.yg)("h3",{id:"swift-usage"},(0,a.yg)("a",{parentName:"h3",href:"#swift-usage"},"Swift Usage")),(0,a.yg)("p",null,"In integration code"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-swift"},'var body: some View {\n    SwiftUIPlayer(\n        flow: flow,\n        plugins: [\n          AsyncNodePlugin(plugins: [AsyncNodePluginPlugin()]) { node in\n              // Determine what to return either using the singleNode or multiNode case\n              // Then JSON can be provided using the concrete case, see below for using the encodable case\n              return .singleNode(.concrete(jsContext?.evaluateScript("""\n                  ({"asset": {"id": "text", "type": "text", "value":"new node from the hook"}})\n                  """) ?? JSValue()))\n\n              // OR\n              return .multiNode([\n                .concrete(jsContext?.evaluateScript("""\n                  ({"asset": {"id": "text", "type": "text", "value":"1st value in the multinode"}})\n                  """) ?? JSValue()),\n                .concrete(jsContext?.evaluateScript("""\n                  ({"asset": {"id": "async-node-2", "async": "true" }})\n                  """) ?? JSValue())\n              ])\n\n          }\n        ],\n        result: $resultBinding\n    )\n}\n')),(0,a.yg)("p",null,"The plugin also provides a default asset placeholder struct that is encodable, instead of passing in the JSON string users can use\n",(0,a.yg)("inlineCode",{parentName:"p"},"AssetPlaceholderNode")," which includes an ",(0,a.yg)("inlineCode",{parentName:"p"},"asset")," key that takes any user defined Encodable struct as the value. Assuming the following encodable struct is defined:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-swift"},"struct PlaceholderNode: Codable, Equatable, AssetData {\n    public var id: String\n    public var type: String\n    var value: String?\n\n    public init(id: String, type: String, value: String? = nil) {\n        self.id = id\n        self.type = type\n        self.value = value\n    }\n}\n")),(0,a.yg)("p",null,"Instead of using the JSON string above, the following can be used:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-swift"},'return .singleNode(.encodable(PlaceholderNode(id: "text", type: "text", value: "new node from the hook")))\n\n// OR\n\nreturn .multiNode([\n    ReplacementNode.encodable(PlaceholderNode(id: "text", type: "text", value: "1st value in the multinode")),\n    ReplacementNode.encodable(AsyncNode(id: "id"))])\n')),(0,a.yg)("p",null,"Note: the AsyncNode struct is already defined in the plugin with the ",(0,a.yg)("inlineCode",{parentName:"p"},"async")," property defaulted to true so only ",(0,a.yg)("inlineCode",{parentName:"p"},"id")," needs to be passed in"),(0,a.yg)("p",null,"As a convenience to the user, the AsyncNodePlugin just takes a callback which has the content to be returned, this is provided to the plugin which calls the the ",(0,a.yg)("inlineCode",{parentName:"p"},"onAsyncNode")," hook tap method. The return could be a single asset node or an array of asset nodes, or null if the async node is no longer relevant.")),(0,a.yg)("android",null,(0,a.yg)("p",null,"In build.gradle"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-kotlin"},'implementation "com.intuit.playerui.plugins:async-node:$PLAYER_VERSION"\n')),(0,a.yg)("p",null,"In integration code"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-kotlin"},'import com.intuit.playerui.plugins.asyncnode.AsyncNodePlugin\n\nval asyncNodePlugin = AsyncNodePlugin(plugins: [AsyncNodePluginPlugin()])\n\n// Configuring async node behaviour\nasyncNodePlugin.hooks.onAsyncNode.tap("handleAsync") { hookContext, node ->\n    ...\n    // Determine what to return in the form of a list of maps representing UI asset to be parsed\n    // e.g.\n    // listOf(\n    //  mapOf(\n    //    "asset" to mapOf(\n    //      "id" to "asset-1",\n    //      "type" to "text",\n    //      "value" to "new asset!"\n    //    )\n    //  )\n    // )\n}\n\nAndroidPlayer(asyncNodePlugin)\n')))),(0,a.yg)("hr",null),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://github.dev/player-ui/player/blob/main/docs/site/pages/plugins/async-node.mdx"},"Help to improve this page")))}d.isMDXComponent=!0},60742:(e,n,t)=>{t.d(n,{A:()=>A});var a=t(52112),o=t(9495),l=t(32532),r=t(83190),i=t(48884),s=t(90283),c=t(14769),d=t(63420),u=t(23013),p=t(47482),y=t(52947),g=t(4380),m=t(13516),h="chakra-skip-nav";function f(e){return{userSelect:"none",border:"0",height:"1px",width:"1px",margin:"-1px",padding:"0",outline:"0",overflow:"hidden",position:"absolute",clip:"rect(0 0 0 0)",...e,_focus:{clip:"auto",width:"auto",height:"auto",...e._focus}}}var N=(0,u.R)((function(e,n){const t=(0,p.Vl)("SkipLink",e),{id:a=h,...o}=(0,y.MN)(e);return(0,m.jsx)(g.B.a,{...o,ref:n,href:`#${a}`,__css:f(t)})}));N.displayName="SkipNavLink";var b=(0,u.R)((function(e,n){const{id:t=h,...a}=e;return(0,m.jsx)(g.B.div,{ref:n,id:t,tabIndex:-1,style:{outline:0},...a})}));b.displayName="SkipNavContent";var v=t(67435),w=t(63192);const P=e=>a.createElement(s.az,{display:{base:"none",xl:"block"}},"Table Of Contents",a.createElement(c._J,{spacing:1,ml:"0",mt:"4",styleType:"none"},e.tableOfContents?.map((e=>a.createElement("li",{key:e.text},a.createElement("a",{href:`#${e.id}`},e.text)))))),x=e=>{const{bannerExpanded:n}=a.useContext(v.BR),t="72px",l=`calc(100vh - 88px - ${n?t:"0px"})`,r=`calc(100vh - 88px - 105px - ${n?t:"0px"})`;return a.createElement(s.az,{minH:"100vh"},a.createElement(N,null,"Skip to Main Content"),a.createElement(o.s,{flexDir:"column",padding:"2"},a.createElement(w.IS,null),a.createElement(d.c,null),a.createElement(o.s,null,a.createElement(s.az,{as:"main",w:"100%",mx:"auto"},a.createElement(s.az,{display:{md:"flex"}},a.createElement(s.az,{display:{base:"none",md:"block"},overflow:"auto",maxH:l,pr:"8",ml:"4"},a.createElement(w.E1,null)),a.createElement(s.az,{flex:"1",minW:"0",overflow:"auto",maxH:l},a.createElement(s.az,{minH:r},a.createElement(b,null),e.children),a.createElement(s.az,{pt:"20"},a.createElement(w.wi,null))),e.tableOfContents&&a.createElement(P,{tableOfContents:e.tableOfContents}))))))};function A(e){return e=>a.createElement(x,null,a.createElement(o.s,{alignItems:"center"},a.createElement(l.m,{maxW:"container.lg"},a.createElement(r.xA,{components:i.Ul},e.children))))}}}]);
//# sourceMappingURL=925.fee769b152f1579cd76b.js.map